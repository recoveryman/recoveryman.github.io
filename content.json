{"meta":{"title":"회복맨","subtitle":"Wellcome ..!","description":"회복맨 입니다.","author":"회복맨","url":"https://recoveryman.github.io"},"pages":[{"title":"About","date":"2017-12-03T16:14:50.000Z","updated":"2017-12-04T15:10:52.804Z","comments":true,"path":"about/index.html","permalink":"https://recoveryman.github.io/about/index.html","excerpt":"","text":"환영합니다.안녕하세요. UI개발자 회복맨 입니다.이곳에 방문해 주신분들과 유익한 소통을 하고싶어서 개설하게 되었습니다.부족한게 많은 글들이지만 점점 나아지는 모습을 기록하려합니다. 지금 적극적으로 실행되는 괜찮은 계획이 다음 주의 완벽한 계획보다 낫다. George S. Patton Skills HTML CSS &amp; SASS javascript jQuery Git &amp; SVN Gulp"},{"title":"Portfolio","date":"2017-12-03T16:26:51.000Z","updated":"2017-12-07T04:53:47.565Z","comments":true,"path":"portfolio/index.html","permalink":"https://recoveryman.github.io/portfolio/index.html","excerpt":"","text":"한빛소프트2017~ 하이브랩2016~2017 엘엔케이로직코리아2015~2016"}],"posts":[{"title":"[jQuery플러그인제작] jQuery 확장 소개","slug":"jQuery플러그인제작-jQuery-확장-소개","date":"2017-12-28T05:08:04.000Z","updated":"2017-12-28T08:00:19.305Z","comments":true,"path":"2017/12/28/jQuery플러그인제작-jQuery-확장-소개/","link":"","permalink":"https://recoveryman.github.io/2017/12/28/jQuery플러그인제작-jQuery-확장-소개/","excerpt":"","text":"jQuery 확장에는 유틸리티와 플러그인 두 가지가 있습니다. jQuery 확장이란123456// 자바스크립트 방식var tabMenu1 = new TabMenu('.tabMenu1');TabMenuenu.setSelectAt(1);// jQuery 플러그인 방식$(\".tabMenu1\").setSelectAt(1); jQuery 확장 요소 종류1.유틸리티 문자열의 공백을 제거해주는 jQuery의 trim() 메서드와 같은 유틸리티는 주로 도움을 주는 기능을 합니다.jQuery 인스턴스를 생성하지 않고 jQuery 클래스에 직접 접근하여 사용합니다. 1jQuery.유틸리티(); 1$.유틸리티(); 2.플러그인 특정 기능을 재사용 하고자 할 때 사용하는 포장 기능 입니다. 1$('선택자').플러그인(옵션); 12var $결과 = $('선택자');$결과.플러그인(옵션);","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-학습/"}],"tags":[]},{"title":"패키지","slug":"패키지","date":"2017-12-27T07:21:44.000Z","updated":"2017-12-28T04:46:51.856Z","comments":true,"path":"2017/12/27/패키지/","link":"","permalink":"https://recoveryman.github.io/2017/12/27/패키지/","excerpt":"","text":"패키지란함수는 특정 알고리즘이나 구문의 영역을 나누기 위해 사용하는 포장 기술.클래스는 연관있는 변수와 함수를 묶을때 사용. 패키지는 연관있는 클래스를 묶을 때 사용 자바스크립트에서 패키지자바스크립트는 다른 언어와 달리 패키지 문법을 제공하지 않습니다.그래서 패키지 스럽게 흉내를 냅니다. 123456789101112131415161718192021222324252627282930313233var study = &#123;&#125;;study.ui = &#123;&#125;// property 선언study.ui.TabMenu = function() &#123; this.property = \"TAB MENU\";&#125;study.ui.Slider = function() &#123; this.property = \"SLIDER\"&#125;// method 선언study.ui.TabMenu.prototype.method = function() &#123; return this.property;&#125;study.ui.Slider.prototype.method = function() &#123; return this.property;&#125;// 버전및 제작자 정보study.version = \"0.1.0\";study.getInfo = function() &#123; var info = &#123; developer: \"반찬가게알바\", email: \"고등어@등푸른생선.com\", desc: \"저희 가게의 반찬은 고등어가 제일 맛있습니다!\" &#125; return info;&#125;// 인스턴스 생성var tabMenu = new study.ui.TabMenu();var slider = new study.ui.Slider(); 위의 코드를 약간만 정리해 보면 다음과 같이 나올듯 합니다. 1234567891011121314151617181920212223242526272829303132var study = &#123; // 클래스 프로퍼티 메소드 를 여기에 넣었습니다. version: \"0.1.0\", getInfo: function() &#123; var info = &#123; developer: \"반찬가게알바\", email: \"고등어@등푸른생선.com\", desc: \"저희 가게의 반찬은 고등어가 제일 맛있습니다!\" &#125; return info; &#125;&#125;;study.ui = &#123; // property 선언을 ui 안쪽에 두었습니다. TabMenu: function() &#123; this.property = \"TAB MENU\"; &#125;, Slider: function() &#123; this.property = \"SLIDER\" &#125;&#125;// method 선언study.ui.TabMenu.prototype.method = function() &#123; return this.property;&#125;study.ui.Slider.prototype.method = function() &#123; return this.property;&#125;// 인스턴스 생성var tabMenu = new study.ui.TabMenu();var slider = new study.ui.Slider(); 사용 방법[사용]123456// 인스턴스 프로퍼티 메소드 사용tabMenu.method();slider.method();// 클래스 프로퍼티 메소드 사용study.getInfo().desc; 결과 클래스정의 3가지 비교 함수 단위 코딩vs클래스 단위 코딩 인스턴스 프로퍼티와 메서드vs클래스 프로퍼티와 메서드 패키지","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-학습/"}],"tags":[]},{"title":"인스턴스 프로퍼티와 메서드vs클래스 프로퍼티와 메서드","slug":"인스턴스-프로퍼티와-메서드vs클래스-프로퍼티와-메서드","date":"2017-12-27T02:07:02.000Z","updated":"2017-12-28T04:36:00.088Z","comments":true,"path":"2017/12/27/인스턴스-프로퍼티와-메서드vs클래스-프로퍼티와-메서드/","link":"","permalink":"https://recoveryman.github.io/2017/12/27/인스턴스-프로퍼티와-메서드vs클래스-프로퍼티와-메서드/","excerpt":"","text":"인스턴스 프로퍼티와 메서드란[인스턴스 프로퍼티와 메서드]클래스의 인스턴스를 생성 후 사용할 수 있는 프로퍼티와 메서드를 뜻함 [예]12var tabMenu1 = new TabMenu(\".tab1\");tabMenu1.setSelectItemAt(1); 클래스 프로퍼티와 메서드란[클래스 프로퍼티와 메서드]인스턴스를 생성하지 않고도 사용할 수 있는 프로퍼티와 메서드 만드는 방법 [문법]12345function 클래스_이름() &#123; // ...&#125;클래스_이름.프로퍼티 = 값;클래스_이름.메서드 = function()&#123;&#125; 여기서 클래스 이름은 인스턴스가 아닙니다. [차이]123456789101112131415161718function TabMenu() &#123; // ..&#125;// 인스턴스 프로퍼티와 메서드TabMenu.prototype.property1 = \"string\";TabMenu.prototype.method1 = function()&#123;return \"method1\"&#125;;// 클래스 프로퍼티와 메서드TabMenu.property2 = \"string\";TabMenu.method2 = function()&#123;return \"method2\"&#125;;var tabMenu = new TabMenu();console.log(\"1. \" + tabMenu.property1);console.log(\"2. \" + tabMenu.property2);console.log(\"3. \" + tabMenu.method1());console.log(\"4. \" + tabMenu.method2()); 결과 콘솔로 나온 결과 중에서 2, 4번의 출력은 저렇게 하면 안되고 다음과 같이 해야 합니다. [클래스 프로퍼티와 메서드 출력]12console.log(\"2. \" + TabMenu.property2);console.log(\"4. \" + TabMenu.method2()); 결과[클래스 프로퍼티와 메서드 의 주 용도]주로 도움을 주는 유틸리티성 기능이나 또는 실행하더라도 내부 데이터에 영향을 주지 않고 독립적으로 실행되는 기능이나 정보를 담을 때 사용 예 12345678910111213141516function TabMenu() &#123; // .. &#125;TabMenu.version = \"0.1.0\";TabMenu.getInfo = function() &#123; var info = &#123; developer: \"반찬가게알바\", email: \"고등어@등푸른생선.com\", desc: \"저희 가게의 반찬은 고등어가 제일 맛있습니다!\" &#125; return info;&#125;console.log(TabMenu.version);console.log(TabMenu.getInfo()); 클래스 프로퍼티와 메서드는 없거나 추가되더라도 기능이 동작하는데 전혀 지장을 주지 않습니다. 클래스정의 3가지 비교 함수 단위 코딩vs클래스 단위 코딩 인스턴스 프로퍼티와 메서드vs클래스 프로퍼티와 메서드 패키지","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-학습/"}],"tags":[]},{"title":"함수 단위 코딩vs클래스 단위 코딩","slug":"함수-단위-코딩vs클래스-단위-코딩","date":"2017-12-26T02:00:59.000Z","updated":"2017-12-28T04:24:44.069Z","comments":true,"path":"2017/12/26/함수-단위-코딩vs클래스-단위-코딩/","link":"","permalink":"https://recoveryman.github.io/2017/12/26/함수-단위-코딩vs클래스-단위-코딩/","excerpt":"","text":"함수단위 코딩1함수만을 이용해서 다음과 같이 독립적으로 동작하는 n개의 탭패널을 제작 가능 합니다. 소스코드 다운받기 이렇게 만든 함수는 두가지 단점이 있습니다. tabMenu() 함수를 호출할 때마다 내부에 선언된 중첩 함수가 만들어 집니다. tabMenu 함수를 호출할 때마다 내부에 들어가는 함수들이 중복해서 만들어 집니다. 외부에서 내부 속성과 함수를 접근할 수 없습니다. javascript 탭을 눌러보시면 setSelectItemAt 함수를 tabMenu 함수 외부에서 호출할 수 없습니다. 함수단위 코딩2함수만을 이용한 함수단위 코딩으로도 함수 내부의 함수를 호출하는 방법이 있습니다. 소스코드 다운받기 먼저 함수 내부의 함수를 호출하기 위해 내부 함수를 객체로 포장해 리턴해 줍니다. tabMenu 함수를 호출할 때 변수로 한번 감싸줍니다. 이렇게 감싼 변수는 tabMenu 함수 내부에 객체 리터럴 방식으로 리턴해준 함수를 사용할 수 있습니다. 아마 갑자기 객체 리터널이 나와서 이해가 안가실 수 있습니다.그래서 아래 코드를 보시고 결과를 예측하시면 좋을듯 합니다. 1234567891011121314151617181920212223242526// 1.function a() &#123; // ..&#125;console.log(\"함수 a 는 어떻게 출력될까요? \" + a);console.log(\"함수 a 를 '실행'시키면 어떻 뭐가 출력 될까요? \" + a());console.log(\"함수 a 의 타입은? \" + (typeof a));console.log(\"함수 a 가 '실행'시키면 그 타입은? \" + (typeof a()));// 2.function b() &#123; var str = \"string\"&#125;console.log(\"함수 b 는 어떻게 출력될까요? \" + b);console.log(\"함수 b 를 '실행'시키면 어떻 뭐가 출력 될까요? \" + b());console.log(\"함수 b 의 타입은? \" + (typeof b));console.log(\"함수 b 가 '실행'시키면 그 타입은? \" + (typeof b()));// 3.function c() &#123; return \"string\";&#125;console.log(\"함수 c 는 어떻게 출력될까요? \" + c);console.log(\"함수 c 를 '실행'시키면 어떻 뭐가 출력 될까요? \" + c());console.log(\"함수 c 의 타입은? \" + (typeof c));console.log(\"함수 c 가 '실행'시키면 그 타입은? \" + (typeof c())); ..........결과 함수를 호출하면 리턴해온 반환값에 의해 타입이 바뀌게 되는걸 알 수 있습니다.그래서 마지막에 객체를 반환하게 될 경우 타입이 객체로 바뀌게 됩니다. 123456789function d() &#123; return &#123; str: \"string\" &#125;&#125;console.log(\"함수 d 는 어떻게 출력될까요? \" + d);console.log(\"함수 d 를 '실행'시키면 어떻 뭐가 출력 될까요? \" + d());console.log(\"함수 d 의 타입은? \" + (typeof d));console.log(\"함수 d 가 '실행'시키면 그 타입은? \" + (typeof d())); 결과 함수안에 객체(Object)를 리턴하게 되면 객체가 되므로 객체의 프로퍼티 또는 메서드를 사용할 수 있게 됩니다. 클래스 단위 코딩 소스코드 다운받기 클래스 단위 코딩은 함수 단위 코딩에서 가지고 있는 단점들을 해소할 수 있습니다. 클래스 단위 코딩에서 보이듯 프로토 타입 방식의 경우 여러개의 인스턴스에서 메서드를 공유해서 사용합니다. 함수단위 코딩과는 다르게 함수 외부에서 함수 내부로 접근할 수 있는 형태를 가지고 있습니다. 클래스정의 3가지 비교 함수 단위 코딩vs클래스 단위 코딩 인스턴스 프로퍼티와 메서드vs클래스 프로퍼티와 메서드 패키지","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-학습/"}],"tags":[]},{"title":"this (2) - 이벤트리스너,메서드,메서드 내부의 중첩 함수에서의 this","slug":"this-2","date":"2017-12-12T23:48:57.000Z","updated":"2017-12-13T15:16:46.873Z","comments":true,"path":"2017/12/13/this-2/","link":"","permalink":"https://recoveryman.github.io/2017/12/13/this-2/","excerpt":"","text":"자바스크립트 this (2)이벤트 리스너에서의 this예제 [다음 7,8,9 결과 예상해보기]1234567891011var num = 1;$(function() &#123; $('.btn').on('click', function() &#123; this.num = 2; num = 3; console.log(num); console.log(this.num); console.log(window.num); &#125;)&#125;) 예제 다운받기..........결과제이쿼리를 사용한 예제 입니다.클래스명이 btn 인 엘리먼트를 클릭하면 안의 내용을 실행 합니다.예제의 결과를 보시면 조금 헷갈리실 수 있습니다. 4번 라인의 this.num 은 $(‘.btn’) 이라는 객체의 속성(property) 로 들어게 됩니다. 변수와는 다릅니다.※ $(‘.btn’) 은 제이쿼리에 의해 객체(object) 가 됩니다. console.log(typeof $(‘.btn’)); 을 찍어서 확인하시면 $(‘.btn’) 의 데이터 타입이 나옵니다. 5번 라인의 num 은 $(‘.btn’) 의 익명함수 내부에서 지역변수 num을 찾습니다. 익명함수 내부에서 지역변수 num이 없기에 한단계 위인 $(function(){}) 에서 지역변수 num 을 찾습니다. 거기도 없기 때문에 window 전역객체에 선언된 전역변수 num을 찾아서 3이라는 값을 할당합니다. 7번 라인의 num 은 전역에 선언된 num 을 의미합니다. 8번 라인의 this.num은 함수를 호출한 시점이 되는 $(‘.btn’) 객체의 속성(property) 인 num 을 의미합니다. 9번 라인의 window.num 은 윈도우 객체에 선언된 num을 의미합니다. 7번과 9번의 num은 동일한 객체안에 있습니다. 메서드에서의 this예제 [다음 9,10,11 결과 예측해보기]123456789101112131415var num = 1;function MyClass() &#123; this.num = 2;&#125;MyClass.prototype.method1 = function() &#123; this.num = 3; num = 4; console.log(num); console.log(this.num); console.log(window.num);&#125;var my1 = new MyClass();my1.method1(); .............결과 3번 라인의 this.num 은 아직은 어떤 객체의 num 이될지 알 수 없는 상태 입니다. MyClass 라는 함수(클래스)를 어떻게 호출하냐에 따라 달라집니다. (클래스로 사용할 함수는 앞 글자를 대문자로 표시하는 규칙이 있습니다.) 6번 라인의 this.num 은 MyClass 를 호출한 객체의 속성(property)이 됩니다. 아직은 어떤 객체의 속성이 될지 모르는 상태 입니다. 7번 라인의 num 은 자세히 보시면 method1 이라는 함수 안의 변수처럼 보입니다. 다만 앞에 예약어인 var 가 없기 때문에 지역변수 num 을 찾다가 없으니깐 window 전역객체의 변수 num에 4라는 값이 할당되게 됩니다. 9번 라인의 num 은 15번 라인에서 my1.method1(); 을 호출할 때 안의 실행절차에 따라 전역변수 num 에 4라는 값이 할당됩니다. 10번 라인의 this.num은 method1 을 호출한 객체인 my1 의 속성(property) 로써 3이라는 값이 할당받게 됩니다. 11번 라인의 window.num 은 1번 라인의 num 입니다. 7번 라인의 동작에 따라 1번 라인의 num 은 4라는 값을 할당 받았습니다. 메서드 내부의 중첩 함수에서의 this[다음 10,11,12 결과 예측해보기]123456789101112131415161718var num = 1;function MyClass() &#123; this.num = 2;&#125;MyClass.prototype.method1 = function() &#123; function inner() &#123; this.num = 3; num = 4; console.log(num); console.log(this.num); console.log(window.num); &#125; inner();&#125;var my1 = new MyClass();my1.method1(); ...........결과아마 11 번 라인의 this.num 이 왜 4가 찍히는지 조금 의아할 수 있습니다.중첩함수 내부의 this 는 window 객체를 의미합니다. 메서드 안의 중첩함수도 예외는 아닙니다.앞선 포스팅에서 중첩함수 내부의 this 에 대해서 포스팅 한 적이 있습니다. 10번 라인의 num 은 inner 함수 내부에서 지역변수 num을 찾습니다. 근데 지역변수 num이 없으니 한단계 위인 MyClass 함수에서의 지역변수 num을 찾습니다. 그래도 없으니까 window 객체의 num 을 찾아 4 라는 값을 할당해주게 됩니다. 11번 라인의 this.num 은 중첩함수 inner 안에 있습니다. 중첩함수 내부의 this 는 window 객체 입니다. 따라서 7번 라인에 의해 전역변수 num 에 3 이라는 값을 대입했지만. 8번라인의 코드에 의해 num 이 4라는 값을 가지게 되므로 4를 출력합니다. 12번 라인은 전역변수 num을 의미합니다. 1번라인을 바라보고 있습니다. 8번 라인에 의해 4라는 값을 할당받게 되어서 4가 찍힙니다. this (1) - 일반함수,일반중첩함수 의 this this (2) - 이벤트리스너,메서드,메서드 내부의 중첩 함수에서의 this","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-학습/"}],"tags":[]},{"title":"this (1) - 일반함수,일반중첩함수 의 this","slug":"this-1","date":"2017-12-12T12:54:23.000Z","updated":"2017-12-13T15:18:28.102Z","comments":true,"path":"2017/12/12/this-1/","link":"","permalink":"https://recoveryman.github.io/2017/12/12/this-1/","excerpt":"","text":"자바스크립트 this (1)this는 일반적으로 메서드를 호출한 객체가 저장되어 있는 속성 콘솔 찍어보기 전까지 예상하기 어려운 녀석이네요.코딩을 하면서 조금씩 움찔움찔 합니다. 어… 이게 이걸 가르키나 하구요. 일반 함수에서의 this1234567891011var data = 10;function outer() &#123; this.data = 20; data = 30; console.log(\"1. data = \" + data); // 30 console.log(\"2. this.data = \" + this.data); // 30 console.log(\"3. window.data = \" + window.data); // 30&#125;outer(); outer 라는 함수를 호출하기 전에 this가 무엇인지 생각해 봅시다......예상하신게 이 다음 적을 결과와 같다면 아마 this를 이미 잘 아시는 분이실꺼 같습니다.저는 자바스크립트 에서의 this 는 많이 공부해야 하지만 얕게 알고있는 내용이라도 몇자 남겨 보겠습니다.자바스크립트의 this만 하더라도 책한권의 분량이 나온다고 하니 많이 공부가 필요할듯싶습니다.이 글에서 전달하고자 하는 부분이 잘못되어 있으면 지적 부탁드립니다.후에 명확한 내용을 전달할 수 있을때 다시 포스팅 하겠습니다....결과 일반 함수에서의 this 는 window 객체를 가르키고 있습니다. 3번 라인의 this.data = 20; 은 전역변수 data 에 20을 할당해 줍니다. 4번 라인의 data = 30; 은 지역변수 num을 일단 찾고 없으면 전역으로 올라가 전역변수 data 를 찾습니다. 그리고 그 전역변수 data 에 30을 다시 할당합니다. 그래서 모두 같은 30 이라는 값이 출력이 되고 있네요. 여기서 알 수 있는 사실은this는 무조건 ‘객체’ 입니다. 그리고 좀 더 명확하게 알기 위해서는 ‘함수를 호출한 시점’을 알아야 합니다.간단한 코드로 예를 보여드리겠습니다. 12345function a() &#123; console.log(this);&#125;a(); 이 코드를 콘솔로 찍어보면 window 객체가 찍힙니다. 이 윈도우 객체를 펼쳐보면 a 라는 함수가 보입니다. 이렇다는 건 다음의 코드로도 a함수를 호출할 수 있습니다.같은 결과가 나오고 있네요.두번째로 알 수 있는건 이렇게 호출한 시점의 ‘객체’ 가 this 가 됩니다. 그럼 예제의 3번 코드와 4번 코드 사이에지역변수 data 을 넣어보겠습니다. 예제2 123456789101112var data = 10;function outer() &#123; this.data = 20; var data = 50; data = 100; console.log(\"1. data = \" + data); // 100 console.log(\"2. this.data = \" + this.data); // 20 console.log(\"3. window.data = \" + window.data); // 20&#125;outer(); 3번 코드에 의해 전역변수 data 에 20 이 할당 4번 코드 에 의해 outer 함수 안에 지역변수 data 에 50 이라는 값을 가짐 5번 코드에 의해 outer 함수 안의 지역변수 data 에 100 이라는 값이 담김 7번 에서의 data 는 함수 내부의 지역변수를 data을 찾음 // 100 8번 에서의 this.data 은 a라는 함수를 호출한 window 객체의 data(전역변수) 을 찾음 // 20 9번 에서의 window.data 은 전역변수 data 을 가르킴. // 20 결과 일반 중첩 함수에서의 this[다음 7,8,9번 코드의 출력값 예상하기]123456789101112var data = 10;function outer() &#123; function inner() &#123; this.data = 20; data = 30; console.log(\"1. data = \" + data); console.log(\"2. this.data = \" + this.data); console.log(\"3. window.data = \" + window.data); &#125; inner();&#125; 이 예제도 this 가 무엇을 가르키는지 맞추셨다면 this 를 이미 잘 아시는 분이실듯 합니다. ...자바스크립트를 이제 막 접하신 분들이라면 위의 예제를 해보고 난 뒤 inner 함수가 호출되는 시점을 찾았을 것이라 생각됩니다.inner 함수는 outer 함수 안에서 실행이 되니깐 아마 예상하기론 outer 함수가 찍혀있지 않을까 예상실꺼 같다고 생각이 듭니다...............일단 inner 함수를 호출해 보기 위해 첫번째 시도를 하겠습니다.이 사진에서 보시다시피 inner 함수는 outer 라는 함수 내부에 있기 때문에 그냥 inner 함수를 호출 못시킴니다. 따라서 outer라는 함수를 호출해야지 outer 함수 내부의 동작을 수행하면서 inner 함수가 호출이 됩니다.그런데 잘 보시면 outer 함수가 콘솔로 찍혀 있을 줄 알았지만 예상과는 다르게 콘솔로 찍은 문제의 답이 찍혀져 있었네요. 4번 라인의 this.data 는 inner 함수 내부에 있습니다. inner 함수는 outer 함수 내부에 있는 함수 입니다. 일반 중첩 함수에서 this는 ‘window’ 가 됩니다. 5번 라인은 data 는 지역변수 data 를 먼저 찾고 없으면 전역으로 올라갑니다. 전역에 선언되어 있는 data 변수에 30 이라는 값을 할당 합니다. 7번 라인은 지역변수 data 를 찾고 없으니까 전역으로 올라가서 data 를 찾습니다. data 는 30이라는 값이 할당되어 있습니다. 8번 라인은 함수를 호출한 시점이 되는 객체의 data 변수를 의미합니다. data 변수는 window 객체에서의 변수로 정의되어 있습니다. 9번 라인은 윈도우 전역객체의 data 변수를 의미합니다. this (1) - 일반함수,일반중첩함수 의 this this (2) - 이벤트리스너,메서드,메서드 내부의 중첩 함수에서의 this","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-학습/"}],"tags":[]},{"title":"클래스정의 3가지 비교","slug":"클래스정의-3가지-비교","date":"2017-12-10T13:14:43.000Z","updated":"2017-12-28T04:24:42.328Z","comments":true,"path":"2017/12/10/클래스정의-3가지-비교/","link":"","permalink":"https://recoveryman.github.io/2017/12/10/클래스정의-3가지-비교/","excerpt":"","text":"특징 방식 특징 프로토타입방식 일반적인 클래스 제작 방법인스턴스마다 공통된 메서드를 공유해서 사용하는 장점이 있음jQuery도 prototype방식으로 만들어져 있음 함수 방식 간단한 클래스 제작 시 사용인스탄스마다 메서드가 독립적으로 만들어지는 단점이 있음 리터럴 방식 클래스 만드는 용도는 아니며 주로 여러개의 매개변수를 그룹으로 묶어 함수의 매개변수로 보낼 때 사용정의와 함께 인스턴스가 만들어지는 장점이 있음. 단! 인스턴스는 오직 하나만 만들 수 있음 클래스 정의 방법(포장) 비교리터럴방식 123456789var 인스턴스 = &#123; 프로퍼티1: 초깃값, 프로퍼티2: 초깃값, 메서드1: function() &#123; &#125;, 메서드2: function() &#123; &#125;&#125; 함수방식 123456789function 클래스이름() &#123; this.프로퍼티1 = 초깃값; this.프로퍼티2 = 초깃값; this.메서드1 = function() &#123; &#125; this.메서드2 = function() &#123; &#125;&#125; 프로토타입 방식 123456789function 클래스이름()&#123; this.프로퍼티1 = 초깃값; this.프로퍼티2 = 초깃값;&#125;클래스이름.prototype.메서드1 = function() &#123;&#125;클래스이름.prototype.메서드2 = function() &#123;&#125; 인스턴스 생성 방법 리터럴 방식 함수 방식 프로토타입 방식 var 인스턴스 = {}; var 인스턴스 = new 클래스이름(); var 인스턴스 = new 클래스이름(); 객체 외부에서 프로퍼티와 메서드 접근 방법리터럴 방식 123456789101112var 인스턴스 = &#123; 프로퍼티1: 초깃갑, 프로퍼티2: 초깃갑, 메서드1: function() &#123; &#125; 메서드2: function() &#123; &#125;&#125;인스턴스.프로퍼티1;인스턴스.메서드1(); 함수방식 123456789101112function 클래스이름() &#123; this.프로퍼티1 = 초깃값; this.프로퍼티2 = 초깃값; this.메서드1 = function() &#123; &#125; this.메서드2 = function() &#123; &#125;&#125;인스턴스.프로퍼티1;인스턴스.메서드1(); 프로토타입 방식 123456789101112function 클래스이름()&#123; this.프로퍼티1 = 초깃값; this.프로퍼티2 = 초깃값;&#125;클래스이름.prototype.메서드1 = function() &#123;&#125;클래스이름.prototype.메서드2 = function() &#123;&#125;인스턴스.프로퍼티1;인스턴스.메서드1(); 객체 내부에서 프로퍼티와 메서드 접근 방법리터럴 방식 1234567891011var 인스턴스 = &#123; 프로퍼티1: 초깃갑, 프로퍼티2: 초깃갑, 메서드1: function() &#123; alert(this.프로퍼티1); this.메서드2(); &#125; 메서드2: function() &#123; &#125;&#125; 함수방식 1234567891011function 클래스이름() &#123; this.프로퍼티1 = 초깃값; this.프로퍼티2 = 초깃값; this.메서드1 = function() &#123; alert(this.프로퍼티1); this.메서드2(); &#125; this.메서드2 = function() &#123; &#125;&#125; 프로토타입 방식 1234567891011function 클래스이름()&#123; this.프로퍼티1 = 초깃값; this.프로퍼티2 = 초깃값;&#125;클래스이름.prototype.메서드1 = function() &#123; alert(this.프로퍼티1); this.메서드2();&#125;클래스이름.prototype.메서드2 = function() &#123;&#125; 클래스정의 3가지 비교 함수 단위 코딩vs클래스 단위 코딩 인스턴스 프로퍼티와 메서드vs클래스 프로퍼티와 메서드 패키지","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-학습/"}],"tags":[]},{"title":"jQuery 마우스휠2","slug":"jQuery-마우스휠2","date":"2017-12-07T04:18:57.000Z","updated":"2017-12-07T04:51:30.312Z","comments":true,"path":"2017/12/07/jQuery-마우스휠2/","link":"","permalink":"https://recoveryman.github.io/2017/12/07/jQuery-마우스휠2/","excerpt":"","text":"앞에서 했던 이론이 이해가 되셨다면이제 UI를 만드는건 아주 쉽겟죠? 음수값(마우스를 내릴때)과 양수값(마우스를 올릴때)을 조건식으로 걸어주면 브라우저 이벤트객체 이슈를 고려한 UI 를 만들 수 있겠죠! 더해서 jQuery 플러그 인 중에 Scroll Lock 를 적절하게 응용한다면재밌는 UI를 만드리라 생각합니다! Scroll Lockdemo자 일단 이전글에 있던 마크업을 미리 복사해 줍니다. ㅋㅋ;; 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt;&lt;/style&gt; &lt;script src=\"http://code.jquery.com/jquery-1.11.3.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; $(\"html, body\").on('mousewheel DOMMouseScroll', function(e) &#123; var E = e.originalEvent; delta = 0; if (E.detail) &#123; delta = E.detail * -40; &#125;else&#123; delta = E.wheelDelta; &#125;; &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 이제 body 안에간단하게 ul, li 태그를 사용하여 몇가지 작성해 보도록 합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123;margin: 0;padding: 0;list-style-type: none;&#125; .clearfix&#123;*zoom: 1;&#125; .clearfix:after&#123;content: '';display: block;clear: both;&#125; div&#123;position: relative;width: 1000px;height: 200px;margin: 0 auto;overflow: hidden;&#125; ul&#123;position: absolute;left: 0;top: 0;width: 3000px;&#125; ul li&#123;width: 1000px;height: 200px;float: left;&#125; .box1&#123;background-color: #b3c4f8;&#125; .box2&#123;background-color: #f8bfb4;&#125; .box3&#123;background-color: #b4f8b6;&#125; &lt;/style&gt; &lt;script src=\"http://code.jquery.com/jquery-1.11.3.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; $(\"html, body\").on('mousewheel DOMMouseScroll', function(e) &#123; var E = e.originalEvent; delta = 0; if (E.detail) &#123; delta = E.detail * -40; &#125;else&#123; delta = E.wheelDelta; &#125;; &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;ul class=\"clearfix\"&gt; &lt;li class=\"box1\"&gt;&lt;/li&gt; &lt;li class=\"box2\"&gt;&lt;/li&gt; &lt;li class=\"box3\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 이런식으로??div 의 크기는 현재 보여줄 li 의 크기만큼ul 의 크기는 li 의 갯수 곱하기 li의 width 값 만큼.( 이 부분은 스크립트로 처리하는게 범용성이 뛰어나겠죠? ) 자.. 스크립트를 작성해 봅니다. 스크립트는 자꾸자꾸 스스로 시도해 보면서 시행착오를 겪어봅시다.시행 착오를 직접 겪는것과 안겪는것은 큰 차이가 있습니다!정말로요..이 예제는 별거 아니지만…ㅠㅠ;; 저는 헤맸어요..;;.................................. iframe 에 스크롤 이 생겨서 휠 이벤트 를 보여주기 힘드네요 ㅎㅎ; 소스코드 다운받기 이걸 참고 하셔서 UI 를 만들어 보셔요 위의것과 동일합니다. jQuery 마우스휠1 jQuery 마우스휠2","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"마크업부터 시작하는 UI","slug":"JS/마크업부터-시작하는-UI","permalink":"https://recoveryman.github.io/categories/JS/마크업부터-시작하는-UI/"}],"tags":[]},{"title":"jQuery 마우스휠1","slug":"jQuery-마우스휠1","date":"2017-12-07T00:26:43.000Z","updated":"2017-12-07T04:50:19.601Z","comments":true,"path":"2017/12/07/jQuery-마우스휠1/","link":"","permalink":"https://recoveryman.github.io/2017/12/07/jQuery-마우스휠1/","excerpt":"","text":"마우스 휠을 이용하여 이벤트를 만들어 봅시다.이 장에서는 마우스 휠에 대한 이론을 살펴 보도록 합시다. 예제용 UI를 찾아보려고 했는데 도통 간단한게 없어서 일단 예를 보여드리도록 하겠습니다. 마우스 휠을 아랫방향으로 했을 때에는 -120마우스 휠을 윗 방향으로 했을 때에는 120 이라는 숫자가 뜨죠? 이해를 돕기 위해 js 피들의 javascript 탭에 주석으로 달아 놓긴 했지만다시한번 글을 적어보도록 하겠습니다. 일단 제가 설치한 브라우저는크롬(Chrome), 익스(IE), 파이어폭스(Firefox) 기준으로 말씀드리겠습니다. 다른 브라우저는 테스트 해보진 않았지만 아마도(죄송합니다.. ㅠㅠ)익스, 크롬, 사파리, 오페라 의 경우엔mousewheel 이라는 이벤트를 사용할 수 있고 파이어폭스 의 경우엔DOMMouseScroll 이라는 이벤트를 사용할 수 있습니다. 즉… 파이어 폭스는 mousewheel 이라는 이벤트가 없기 때문에mousewheel 과 DOMMouseScroll 이벤트 두개를 동시에 걸어주는 메서드인 .on() 를 사용해야 합니다. Example123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt;&lt;/style&gt; &lt;script src=\"http://code.jquery.com/jquery-1.11.3.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; $(\"html, body\").on('mousewheel DOMMouseScroll', function(e) &#123; var E = e.originalEvent; delta = 0; console.log(E); if (E.detail) &#123; delta = E.detail * -40; $('body').text(delta); &#125;else&#123; delta = E.wheelDelta; $('body').text(delta); &#125;; &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 일단 저의 마크업은 이렇습니다.이 마크업을 보시면 13번 라인에 콘솔창으로 E 를 찍어보게 됩니다.크롬에서 E 에 담긴걸 찍어보도록 하겠습니다.여기서 function()의 괄호 안에 있는 e 는 mousewheel 입니다! WheelEvent {}이라는 게 뜨죠? 정확히 13번 라인입니다.이걸 펼쳐보면… wheelDelta 라는 속성이 있습니다. 저 값이마우스 휠을 ‘내리게’ 되면 -120 을 출력하고마우스 휠을 ‘올리게’ 되면 120 을 출력합니다. 익스도 마찬가지로 크롬과 동일하게e.originalEvent 의 속성으로 wheelDelta 속성을 사용합니다. 하지만 파이어폭스는e.originalEvent &lt;- 여기서의 e 는 DOMMouseScroll 이벤트 입니다. 파이어폭스 에서도 똑같이 위와같은 마크업의 13번째 라인이 콘솔창에 출력 되었습니다.저 DOMMouseScroll 을 클릭해 보면 detail 이라는 속성이 들어있습니다.저 detail 속성은 파이어폭스에서만 사용할수 있는e.originalEvent 의 속성 입니다. 하지만…크롬도 익스도 120을 출력하는데얘만 3 출력하게 놔둔다면조건문을 이용한 UI를 만들때 불편하겠죠??? 그래서 -40을 곱하기 해주는 겁니다.파이어 폭스는 마우스를 휠을 올릴경우 음수값을마우스 휠을 내릴경우 양수값을 출력합니다. jQuery 마우스휠1 jQuery 마우스휠2","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"마크업부터 시작하는 UI","slug":"JS/마크업부터-시작하는-UI","permalink":"https://recoveryman.github.io/categories/JS/마크업부터-시작하는-UI/"}],"tags":[]}]}
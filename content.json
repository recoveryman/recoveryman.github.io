{"meta":{"title":"회복맨","subtitle":"Wellcome ..!","description":"회복맨 입니다.","author":"회복맨","url":"https://recoveryman.github.io"},"pages":[{"title":"About","date":"2017-12-03T16:14:50.000Z","updated":"2017-12-04T15:10:52.804Z","comments":true,"path":"about/index.html","permalink":"https://recoveryman.github.io/about/index.html","excerpt":"","text":"환영합니다.안녕하세요. UI개발자 회복맨 입니다.이곳에 방문해 주신분들과 유익한 소통을 하고싶어서 개설하게 되었습니다.부족한게 많은 글들이지만 점점 나아지는 모습을 기록하려합니다. 지금 적극적으로 실행되는 괜찮은 계획이 다음 주의 완벽한 계획보다 낫다. George S. Patton Skills HTML CSS &amp; SASS javascript jQuery Git &amp; SVN Gulp"},{"title":"Portfolio","date":"2017-12-03T16:26:51.000Z","updated":"2017-12-07T04:53:47.565Z","comments":true,"path":"portfolio/index.html","permalink":"https://recoveryman.github.io/portfolio/index.html","excerpt":"","text":"한빛소프트2017~ 하이브랩2016~2017 엘엔케이로직코리아2015~2016"}],"posts":[{"title":"[객체지향 프로그래밍 기초] 객체지향 프로그래밍 언어에서 제공하는 기본 기능","slug":"객체지향-프로그래밍-언어에서-제공하는-기본-기능","date":"2018-02-11T14:35:08.000Z","updated":"2018-02-14T15:58:04.654Z","comments":true,"path":"2018/02/11/객체지향-프로그래밍-언어에서-제공하는-기본-기능/","link":"","permalink":"https://recoveryman.github.io/2018/02/11/객체지향-프로그래밍-언어에서-제공하는-기본-기능/","excerpt":"","text":"기본 기능 종류일반적으로 객체지향 프로그래밍 언어의 경우 다음과 같이 기본적인 문법 세 가지를 제공합니다. 클래스(class) 인터페이스(interface) 추상클래스(abstract class) 이 세가지 문법을 조합해 객체 지향 프로그래밍의 네 가지 특징을 구현하게 됩니다. 선언 부분과 구현 부분먼저 기본 문법 세 가지를 이해하기 위해서는 선언 부분과 구현 부분에 대한 이해가 필요합니다. 일반적으로 객체는 선언 부분과 구현 부분으로 구성됩니다. 선언 부분선언 부분은 메서드 이름은 뭐고 매개변수는 몇 개인지 등의 메서드 정보가 바로 선언 부분입니다. 선언 부분을 달리 말하면 일종의 규칙입니다. 여기서 규칙이란 구현 부분에서는 선언 부분에 작성되어 있는 메서드 이름과 매개변수를 똑같이 만들어 구현해야 합니다. 그렇지 않으면 오류가 발생해 동작하지 않게 됩니다. 구현 부분구현 부분은 말 그대로 선언 부분에 있는 메서드의 기능을 직접 구현한 코드를 말합니다. 선언 부분과 구현 부분으로 나눠 구현하는 이유는?일반적으로 객체지향 프로그래밍의 경우 선언 부분과 구현 부분으로 나눠 작업을 합니다. 그리고 이를 위해 존재하는 문법이 객체지향 프로그래밍 기본 문법 세 가지 입니다. 먼저 이 기본 문법 세 가지와 선언 부분-구현 부분과의 관계를 살펴보면 다음과 같습니다. 부분 클래스 인터페이스 추상클래스 선언 부분 X O O 구현 부분 O X O 그렇다면 왜? 객체지향 프로그래밍에서는 선언 부분과 구현 부분으로 나눠 작업하는 것일까요? 바로! 객체지향 프로그래밍의 핵심 기능은 다형성(Polymorphism) 때문입니다. 다형성을 적용해 코드를 만들게 되면 특정 작업을 소스 수정을 거의 하지 않고 다양한 방법으로 연결해서 만들 수 있습니다. 클래스주 용도다시 한 번 정리하면 클래스(class)는 연관 있는 변수와 함수를 묶어 재사용하기 위해 사용하는 문법입니다. 선언 부분과 구현 부분의 개념을 적용해 클래스의 용도를 설명하면 클래스는 객체의 실제 동작을 처리하는 구현 부분을 맡게 됩니다. 예를 들어 지금까지 사용한 클래스는 독립적으로 작성하는 클래스 이기 때문에 잘 몰랐겠지만 사실 클래스는 다음과 같이 아직 배우지 않은 두 가지 문법과 조합되어 많이 사용됩니다. 클래스 + 인터페이스 클래스 + 추상클래스 클래스 + 추상클래스 + 인터페이스 이때 선언 부분은 인터페이스와 추상클래스 문법을 이용해 만들고 이들의 구현 부분은 바로 클래스가 담당하게 됩니다. 그럼 왜 선언 부분과 구현 부분을 나눠서 코딩을 할까요? 바로 객체지향 프로그래밍의 핵심인 다형성 때문입니다. 생김새 1234567891011121314151617// 클래스 정의function User(name, age) &#123; // 프로퍼티 만들기 this.userName = name; this.age = age;&#125;// 메서드 만들기User.prototype.showInfo = function() &#123; document.write(\"userName = \" + this.userName + \", age = \" + this.age);&#125;// 인스턴스 생성var user1 = new User(\"recoveryman\", 30);// 메서드 호출user1.showInfo(); 자바스크립트 지원 유무일반 객체지향 프로그래밍 언어의 경우 class라는 명령어를 이용해 클래스를 생성합니다. 하지만 아쉽게도 자바스크립트는 클래스 전용 명령어를 제공하진 않습니다. 대신 자바스크립트에서는 다음과 같이 세 가지 방법을 이용해 클래스를 비슷하게 만들어 사용할 수 있습니다. 오브젝트 리터럴 방식 함수 방식 프로토타입 방식 인터페이스주 용도앞서 설명한 것처럼 객체는 크게 선언 부분과 구현 부분으로 나눈다는 것을 배웠습니다. 인터페이스(interface)는 바로 구현 부분 없이 오직 선언 부분만을 만들 때 사용하는 문법입니다. 좀더 풀어 설명하자면 인터페이스(interface)는 객체가 반드시 구현해야 할 메서드 명세서를 만들 때 주로 사용한다고 볼 수 있습니다. 이렇게 만들어진 인터페이스는 클래스와 연결해 사용됩니다. 인터페이스와 연결한 클래스는 반드시 인터페이스에 명시된 대로 메서드를 만들어 실제 동작하는 구현 부분을 작성해야 합니다. 만약 메서드 이름과 매개변수 개수가 다른 경우 바로 에러가 납니다. 생김새자바스크립트에서는 문법적으로 인터페이스를 지원하지 않기 때문에 다른 언어는 어떻게 지원하는지 살펴봐야 합니다. [JAVA]123456789101112131415161718192021222324252627282930313233// 인터페이스 정의public interface IUser &#123; public void showInfo(); public void setUserName(String name);&#125;// 클래스 정의public class User implements IUser &#123; // 프로퍼티 만들기 private String userName = \"\"; private int age = 0; // 생성자 public User(name, age) &#123; this.userName = name; this.age = age; &#125; // 메서드 만들기 public void showInfo() &#123; System.out.println(\"userName = \" + this.userName + \", age = \" + this.age); &#125; public void setUserName(name) &#123; this.userName = name; &#125;&#125;// 인스턴스 생성User user1 = new User();// 메서드 호출user1.showInfo(); 객체지향 프로그래밍에서 알 수 있는 것처럼 일반 객체지향 프로그래밍의 경우 문법적으로 인터페이스를 지원하기 때문에 이 기능을 이용하면 선언 부분과 구현 부분을 나눠 작업할 수 있습니다. 자바스크립트 지원 유무일반 객체지향 프로그래밍의 경우 interface라는 명령어를 이용해 인터페이스를 생성합니다. 아쉽게도 자바스크립트에서는 인터페이스 문법을 지원하지 않습니다. 다시 한 번 언급하자면 여기서 지원하지 않는다는 의미는 인터페이스와 연결된 클래스에서 구현 코드 작성 시 인터페이스에 선언된 메서드와 다르게 만드는 경우 문법적으로 오류가 발생해 실행조차 할 수 없게 된다는 뜻입니다.바로 이런 경우를 ‘문법을 지원한다.’ 라고 합니다. 그럼 자바스크립트에서는 어떻게 인터페이스를 사용할까요? 자바스크립트에서는 그냥 인터페이스가 있다는 가정하에 코딩을 하는 방법밖에 없습니다. 추상 클래스주 용도추상 클래스(abstract class)를 이해하려면 우선 상속의 개념을 먼저 이해해야 합니다. 일단 간단히 설명하자면 상속은 부모 클래스의 기능을 자식 클래스에서 물려 받아 재사용 할 수 있는 기능 입니다. 흔하디 흔한 코드 복사(Ctrl + C), 코드 붙이기(Ctrl + V) 하나 없이 말이지요. 상속을 사용하다 보면 부모 클래스의 기능 중 특정 기능을 부모 클래스에서 구현하는 게 아니라 자식 클래스에게 구현하도록 강요해야 하는 경우가 발생합니다. 바로 이때 사용하는 문법이 추상 클래스 입니다. 자식 클래스에게 구현을 강요하고 싶은 기능을 부모 클래스의 추상 메서드로 만들어 줍니다. 추상 메서드는 클래스 내에 선언 부분만 있는 메서드를 말합니다. 추상 클래스를 상속받는 자식 클래스는 추상 클래스에 선언되어 있는 추상 메서드의 구현 코드를 반드시 작성해 줘야 합니다. 만약 구현하지 않는 경우 문법적으로 에러가 발생해 실행이 되질 않습니다. 정리해보면 추상 클래스는 일반 클래스 기능과 인터페이스 기능을 합한 형태입니다. 생김새 [부모 클래스(약간의 선언 부분과 구현 부분이 동시에 존재)]12345678910111213141516171819// 클래스 정의abstract class AUser &#123; // 프로퍼티 만들기 private String userName = \"\"; private int age = 0; // 생성자 public User(name, age) &#123; this.userName = name; this.age = age; &#125; // 메서드 만들기 public void showInfo() &#123; System.out.println(\"userName = \" + this.userName + \", age = \" + this.age); &#125; abstract void setUserName(name);&#125; [자식 클래스(구현 부분 존재)]12345678910111213// 클래스 정의public class MyUser extend AUser &#123; public void setUserName(name) &#123; this.userName = name; &#125;&#125;// 인스턴스 생성MyUser user1 = new MyUser();user1.setUserNmae(\"recoveryman\");// 메서드 호출user1.showInfo(); 자바스크립트 지원 유무일반 객체지향 프로그래밍의 경우 abstract라는 명령어를 이용해 추상 클래스와 추상 메서드를 생성합니다. 아쉽게도 자바스크립트에서는 추상 클래스를 위한 문법을 지원하지 않습니다. 그래서 자바스크립트 에서는 추상 클래스가 있다는 가정하에 작업하게 됩니다. UML 소개UML이란?방금 확인한 것처럼 언어마다 클래스와 인터페이스 그리고 추상 클래스 등을 표현하는 방식이 다르다는 것을 확인했습니다. 또, 클래스가 가지고 있는 메서드를 코드로 확인하는 경우 한눈에 파악하기 어려워집니다. 이를 위해서 객체지향 프로그래밍을 위해 UML이란 멋진 도구를 제공합니다. UML은 Unified Modeling Language의 약자로 특별한 의미가 있는 모형을 활용해 객체지향 분석 및 설계에 사용하는 모델링 언어입니다. UML은 수많은 기능을 갖고 있으며 이중 가장 기본적인 단위로 클래스와 인터페이스 그리고 추상 클래스를 비주얼적으로 모델링할 수 있는 기능을 제공합니다. UML로 클래스 표현하기UML로 클래스를 표현하면 다음과 같이 나타낼 수 있습니다. UML을 이용하면 프로그래밍 언어와 상관 없이 클래스를 비주얼하게 설계할 수 있습니다. 이와 동일한 방식으로 인터페이스와 추상 클래스를 표현해 보겠습니다. UML로 인터페이스 표현하기UML로 인터페이스를 표현하면 다음과 같습니다. 예를 들어 자바로 만든 IUser 인터페이스를 UML로 표현하면 다음과 같습니다. 12345// 인터페이스 정의public interface IUser &#123; public void showInfo(); public void setUserName(String name);&#125; IUser 인터페이스를 UML로 표현하면 다음과 같이 표현할 수 있어요. (interface)IUser showInfo()setUserName(name) UML로 추상 클래스 표현하기UML로 추상 클래스를 표현하면 다음과 같습니다. 예를 들어 자바로 만든 AUser 추상 클래스를 UML로 표현하면 다음과 같습니다. 1234abstact class Auser&#123; //... abstact void setUserName(name); // 추상 메서드&#125; AUser 추상클래스를 UML 로 표현하면 다음과 같이 표현할 수 있어요 AUser userName=””age = 0 User(name, age)showInfo()setUserName(name) [객체지향 프로그래밍 기초] 절차지향 프로그래밍 VS 객체지향 프로그래밍 [객체지향 프로그래밍 기초] 객체지향 프로그래밍의 특징 [객체지향 프로그래밍 기초] 객체지향 프로그래밍 언어에서 제공하는 기본 기능","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-학습/"},{"name":"객체지향 프로그래밍 기초","slug":"JS/js-학습/객체지향-프로그래밍-기초","permalink":"https://recoveryman.github.io/categories/JS/js-학습/객체지향-프로그래밍-기초/"}],"tags":[]},{"title":"[객체지향 프로그래밍 기초] 객체지향 프로그래밍의 특징","slug":"객체지향-프로그래밍의-특징","date":"2018-02-11T13:41:21.000Z","updated":"2018-02-11T14:58:55.887Z","comments":true,"path":"2018/02/11/객체지향-프로그래밍의-특징/","link":"","permalink":"https://recoveryman.github.io/2018/02/11/객체지향-프로그래밍의-특징/","excerpt":"","text":"객체지향 프로그래밍의 특징 네 가지(추상화, 캡슐화, 상속, 다형성)와 객체지향 프로그래밍 학습법에 대해 알아보겠습니다. 객체지향 프로그래밍이란?간단한 의미의 객체지향 프로그래밍앞서 살펴본 것처럼 객체지향 프로그래밍이란 객체 단위로 기능을 나눠 구현하는 방식을 말합니다. 이때 클래스 문법은 객체의 속성과 기능을 작성할때 사용한다고 배웠습니다. 또한 클래스 단위 코딩 역시 객체 지향 프로그래밍에 포함된다고도 배웠습니다. 진정한 의미의 객체지향 프로그래밍객체지향 프로그래밍이란 일종의 논문과도 같은 연구 결과의 산물입니다. 이미 우리보다 훨씬 전부터 프로그래밍을 한 선배님들이 어떻게 하면 프로그래밍을 유지보수하기 쉽고 냄새 나지 않는 멋진 코드를 만들 수 있을까 수없이 노력한 끝에 완성한 최상의 결과물 입니다. 이 결과물에는 크게 네가지 특징이 담겨 있습니다. 간단하게 정리해보면 다음과 같습니다. 1)추상화(Abstraction)쉽게 말해 추상화는 설계하는 작업 자체를 나타냅니다. 예를 들어 세탁기를 클래스로 표현한다고 했을때 예상되는 프로퍼티와 메서드를 정의하게 되는데 바로 이 작업을 추상화라고 합니다. 추상화의 가장 큰 특징은 프로퍼티와 메서드의 이름을 작성하는 선언 부분만 만들 뿐 구현 소스를 구현하지 않는다는 점입니다. 연관 문법: 클래스, 추상 클래스, 인터페이스 2)캡슐화(Encapsulation)추상화 작업 내용 중 어떤 프로퍼티와 메서드는 외부에서 접근 가능하고 또 어떤 프로퍼티와 메서드는 외부에서 접근하지 못하게 해야 하는 경우가 있습니다. 바로 이 작업을 캡슐화라고 합니다. 예를 들어 세탁기의 기능 중 사용자에게는 세탁 명령과 세탁 진행 정보만 제공해주면 됩니다. 그 외의 기능은 세탁기 내부에서 일어나는 일이기 때문에 일반 사용자에게는 감춰져 있어야 하는 거죠. 연관 문법: 접근 지정자(private, protected, public) 3)상속(Inheritance)상속은 특정 클래스(부모 클래스)의 속성과 메서드를 하위(자식) 클래스가 물려받는 것을 의미합니다. 예를 들어 일반 세탁기에 말리는 기능이 필요한 경우 일반 세탁기의 기능을 상속받은 후 말리는 기능만 추가하면 일반 세탁기를 전혀 수정하지 않고 원하는 기능을 추가할 수 있습니다. 연관 문법: 상속 4)다형성(Polymorphism)다형성은 객체지향 프로그래밍의 핵심입니다. 다형성을 이용하면 선언 부분과 구현 부분을 나눠 다양하게 처리할 수 있습니다. 일종의 플러그인을 만든다고 보면 됩니다. 연관 문법: 상속, 인터페이스, 추상클래스, 합성 객체지향 프로그래밍 언어란?다시 한 번 설명하자면 객체지향 프로그래밍은 일종의 방법론일 뿐입니다. “이렇게 코딩하면 유지보수하기 쉬운 코드를 만들 수 있어요.” 와 같은 내용이 담긴 문서라는 거죠. 바로 객체지향 프로그래밍 언어란 객체지향 프로그래밍 방법론에 담긴 네 가지 특징을 사용할 수 있게 문법적으로 제공해주는 프로그래밍 언어를 말합니다. 오늘날 가장 대표적인 객체지향 프로그래밍 언어는 C#, JAVA, Objective-C이며 이들은 자기들만의 고유 방식으로 객체지향 프로그래밍 특징 네 가지를 구현하고 있으며 개발자가 사용할 수 있게 다양한 문법을 제공해 줍니다. 정리하자면, 문법이 다르더라도 어떤 방법으로든 객체지향 프로그래밍 특징 네 가지를 사용할 수 있게 되어 있다면 모두 객체지향 프로그래밍 언어로 부른다는 것입니다. 객체지향 프로그래밍 언어 학습법예를 들어 어느 날 회사에 아이폰 개발 의뢰가 들어와 Objective-C를 배워야 한다고 했을 때 예상 학습 기간은 어느 정도 걸릴 거라 생각되나요? 단, 오직 Objective-C 언어만을 배운다는 가정하에 말이지요(UI와 일반 라이브러리 기능 제외). 만약 객체지향 프로그래밍 특징 네 가지의 개념과 사용 용도를 이미 알고 있다면 넉넉잡아 10일 내외면 충분할 것입니다. 이유는 앞에서 알아본 것처럼 자바와 Objective-C 언어 모두 객체지향 프로그래밍 언어이기 때문입니다. “Objective-C는 클래스를 이렇게 만드는 구나, 오! 메서드를 참 특이하게 만드네, 인터페이스를 프로토콜이라고 부르는군!” 식으로 이미 자바에서 알고 사용한 객체지향 프로그래밍 개념을 비교해가며 쭉쭉! 넘어가는 것입니다. 중요한 건 바로 객체지향 프로그래밍 특징 네 가지 개념의 이해입니다. 정리하자면 객체지향 프로그래밍은 특징 네 가지를 저마다의 고유한 방법으로 제공하고 있기 때문에 지금 가장 자신 있게 사용하고 있는 프로그래밍 언어로 객체지향 프로그래밍 특징 네 가지를 배우면 됩니다. 자바스크립트는 객체지향 프로그래밍 언어인가요?결론부터 이야기하자면 아닙니다. 아쉽게도 자바스크립트는 객체지향 프로그래밍 언어가 갖추어야 할 특징 네 가지를 모두 지원하지 않습니다. 기껏해야 상속 정도만 제공하며 그 외의 기능은 거의 지원하지 않습니다. 지원하는 상속마저도 완벽하지 않습니다. 나머지 특징은 지원한다는 가정하에 비슷하게 만들어 사용하거나 아니면 아예 없는 걸로 간주하고 사용하지 않는 거죠. [객체지향 프로그래밍 기초] 절차지향 프로그래밍 VS 객체지향 프로그래밍 [객체지향 프로그래밍 기초] 객체지향 프로그래밍의 특징 [객체지향 프로그래밍 기초] 객체지향 프로그래밍 언어에서 제공하는 기본 기능","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-학습/"},{"name":"객체지향 프로그래밍 기초","slug":"JS/js-학습/객체지향-프로그래밍-기초","permalink":"https://recoveryman.github.io/categories/JS/js-학습/객체지향-프로그래밍-기초/"}],"tags":[]},{"title":"[객체지향 프로그래밍 기초] 절차지향 프로그래밍 VS 객체지향 프로그래밍","slug":"절차지향-프로그래밍-VS-객체지향-프로그래밍","date":"2018-02-05T01:19:04.000Z","updated":"2018-02-11T14:59:01.933Z","comments":true,"path":"2018/02/05/절차지향-프로그래밍-VS-객체지향-프로그래밍/","link":"","permalink":"https://recoveryman.github.io/2018/02/05/절차지향-프로그래밍-VS-객체지향-프로그래밍/","excerpt":"","text":"일반적으로 프로그래밍 방식은 크게 절차지향 프로그래밍과 객체지향 프로그래밍 방식 두 가지로 나눌 수 있습니다. 이 두가지 방식을 비교해가며 객체지향 프로그래밍에 대해 알아보겠습니다. 절차지향 프로그래밍정의절차지향 프로그래밍(Procedural Oriented Programming)은 문제를 여러 개의 작은 함수로 나눠 작성하며 이 함수들을 원하는 순서에 맞게 작성하는 방식을 말합니다. 이 방식은 전통적인 프로그래밍 방식이며 C, 파스칼 코볼과 같은 초기 프로그래밍 언어가 대표적으로 지원하는 방식입니다. 여기서 지원한다는 의미는 절차적으로 실행할 수 있는 다양한 문법을 제공한다는 의미입니다. 절차지향 프로그래밍 특징절차지향 프로그래밍의 가장 큰 특징은 처리 부분인 함수들에서 전역 데이터를 공유해서 사용한다는 점 입니다. 데이터는 일반적으로 전역 데이터로 만들어지며 함수 호출 시 공유 데이터를 매개변수 값으로 넘기는 구조로 되어 있습니다. 절차지향 프로그래밍 예다음 코드는 함수 기반 탭메뉴 입니다. 먼저 코드를 자세히 보세요. 1234567891011121314151617181920212223242526var $tab1MenuItems = null, $tab2MenuITems = null;$(function() &#123; // 탭메뉴 데이터 생성 $tab1MenuItems = $('.tab1 li'); $tab2MenuItems = $('.tab2 li'); // 탭메뉴 생성 tabMenu($tab1MenuItems); tabMenu($tab2MenuItems);&#125;);// 탭메뉴 생성function tabMenu($menuItems) &#123; $menuItems.click(function(e) &#123; e.preventDefault(); selectMenuItemAt($menuItems, $(this).index()); &#125;)&#125;// n번째 탭메뉴 선택function selectMenuItemAt($menuItems, index) &#123; $menuItems.removeClass(\"on\"); $menuItems.eq(index).addClass(\"on\");&#125; 소스코드 다운받기 설명지금까지 만든 탭메뉴와 약간 다르지만 내용은 모두 같기 때문에 쉽게 이해할 수 있을 것입니다. 코들에서 주의 깊게 살펴볼 내용은 탭메뉴를 생성하는 tabMenu() 함수를 호출할 때와 n번째 탭메뉴를 선택할 수 있는 selectMenuItemAt() 함수를 호출할 때 탭메뉴 아이템 정보($menuItems)를 내부에 가지고 있는 구조가 아니라 매개변수 값으로 넘겨 사용하는 것을 알 수 있습니다. 이는 전형적인 절차지향 프로그래밍 구조입니다. 또한 선택한 탭메뉴 아이템이 없는 상태로 만드는 리셋 처리 기능을 추가하는 아래 예제와 같은 코딩 방법 역시 절차지향 프로그래밍 구조입니다. 1234567891011121314151617181920212223242526272829303132333435363738var $tab1MenuItems = null, $tab2MenuITems = null;$(function() &#123; // 탭메뉴 데이터 생성 $tab1MenuItems = $('.tab1 li'); $tab2MenuItems = $('.tab2 li'); // 탭메뉴 생성 tabMenu($tab1MenuItems); tabMenu($tab2MenuItems); // 탭메뉴 선택 초기화 $('.btnReset').click(function(e) &#123; e.preventDefault(); resetTabMenu($tab1MenuItems); resetTabMenu($tab2MenuItems); &#125;)&#125;);// 탭메뉴 생성function tabMenu($menuItems) &#123; $menuItems.click(function(e) &#123; e.preventDefault(); selectMenuItemAt($menuItems, $(this).index()); &#125;)&#125;// n번째 탭메뉴 선택function selectMenuItemAt($menuItems, index) &#123; $menuItems.removeClass(\"on\"); $menuItems.eq(index).addClass(\"on\");&#125;// 탭메뉴 선택 초기화function resetTabMenu($menuItems) &#123; $menuItems.removeClass(\"on\");&#125; 소스코드 다운받기 설명리셋 버튼 클릭시 선택 초기화를 처리하는 resetTabMenu() 함수를 호출할 때도 메뉴 아이템($menuItems) 정보를 매개 변수 값으로 넘겨 사용하는 것을 알 수 있습니다. 바로 이런 구조를 절차지향 프로그래밍 이라고 부릅니다. 절차지향 프로그래밍의 단점앞의 예제를 통해 확인한 것처럼 절차지향 프로그래밍은 함수 호출 시 전역 데이터를 매개변수 값으로 넘겨 공유해서 사용하는 구조이기 때문에 전역 데이터가 잘못 처리될 수 있는 치명적인 단점을 가지고 있습니다. 즉 데이터가 보호되지 않는다는 의미입니다. 또 하나의 단점은 전역 데이터를 넘겨 받는 식의 구조이다 보니 하나의 프로젝트를 여러 사람으로 나눠 작업하는 방식에는 적합하지 않습니다. 이런 단점 때문에 절차지향 프로그래밍은 규모가 있는 프로젝트에 사용하기 보다 비교적 간단한 프로젝트에 주로 사용합니다. 예를 들자면 간단한 웹사이트 제작 시 내비게이션이나 이미지 슬라이더 그리고 배너 등을 만들 때 함수 단위 코딩을 하는 경우가 바로 절차지향 프로그래밍의 대표적인 예입니다. 절차지향 프로그래밍과 구조적 프로그래밍 그리고 함수기반 프로그래밍아마도 절차지향 프로그래밍 정보를 찾아본 분이라면 절차적 프로그래밍과 많이 비슷한 구조적 프로그래밍과 함수 기반 프로그래밍에 대해 궁금증이 생길 것입니다. 정확한 의미로 보자면 모두 차이점이 있지만 핵심은 세 가지 모두 데이터를 전역에 두고 함수 매개변수 값으로 넘기는 방식으로 대부분의 작업을 처리 한다는 점입니다. 객체지향 프로그래밍정의객체지향 프로그래밍(Object Oriented Programming)은 문제를 여러 개의 객체 단위로 나눠 작업하는 방식을 말합니다. 이 방식은 오늘날 가장 많이 사용하는 대표적인 프로그래밍 방식입니다. JAVA, C#등이 대표적인 객체지향 프로그래밍 언어 입니다. 객체지향 프로그래밍 특징객체지향 프로그래밍의 가장 큰 특징은 클래스를 이용해 연관 있는 처리부분(함수)과 데이터 부분(변수)을 하나로 묶어 객체(인스턴스)를 생성해 사용한다는 점입니다. 객체지향 프로그래밍 예 1234567891011121314151617181920212223242526272829303132$(function() &#123; // 탭메뉴 생성 var tabMenu1 = new TabMenu('.tab1'); var tabMenu2 = new TabMenu('.tab2');&#125;);// 탭메뉴 클래스function TabMenu(selector) &#123; this.init(selector); this.initEvent();&#125;// 탭메뉴 요소 초기화TabMenu.prototype.init = function(selector) &#123; this.tabMenu = $(selector); this.$menuItems = this.tabMenu.find('li');&#125;// 이벤트 초기화TabMenu.prototype.initEvent = function() &#123; var objectThis = this; this.$menuItems.on('click', function(e) &#123; e.preventDefault(); objectThis.setSelectMenuItemAt($(this).index()); &#125;)&#125;// n번째 탭메뉴 선택TabMenu.prototype.setSelectMenuItemAt = function(index) &#123; this.$menuItems.removeClass('on'); this.$menuItems.eq(index).addClass('on');&#125; 소스코드 다운받기 설명코드를 살펴보면 탭메뉴와 관련 있는 기능과 데이터를 모두 TabMenu라는 클래스에 묶여 있으며 이 클래스를 이용해 독립적으로 동작하는 탭메뉴 객체(인스턴스)를 만들었습니다. 이로써 기능을 실행할 때마다 데이터를 넘길 필요 없이 “객체군! 이 기능을 처리하세요.” 식으로 객체 단위로 처리할 수 있습니다. 또한 리셋 처리 기능을 추가하는 경우 다음 예제와 같이 클래스에 메서드를 추가해 객체 단위로 작업할 수 있습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243$(function() &#123; // 탭메뉴 생성 var tabMenu1 = new TabMenu('.tab1'); var tabMenu2 = new TabMenu('.tab2'); $('.btnReset').on('click', function(e) &#123; e.preventDefault(); tabMenu1.resetTabMenu(); tabMenu2.resetTabMenu(); &#125;)&#125;);// 탭메뉴 클래스function TabMenu(selector) &#123; this.init(selector); this.initEvent();&#125;// 탭메뉴 요소 초기화TabMenu.prototype.init = function(selector) &#123; this.tabMenu = $(selector); this.$menuItems = this.tabMenu.find('li');&#125;// 이벤트 초기화TabMenu.prototype.initEvent = function() &#123; var objectThis = this; this.$menuItems.on('click', function(e) &#123; e.preventDefault(); objectThis.setSelectMenuItemAt($(this).index()); &#125;)&#125;// n번째 탭메뉴 선택TabMenu.prototype.setSelectMenuItemAt = function(index) &#123; this.$menuItems.removeClass('on'); this.$menuItems.eq(index).addClass('on');&#125;// 탭메뉴 선택 초기화TabMenu.prototype.resetTabMenu = function() &#123; this.$menuItems.removeClass(\"on\");&#125; 소스코드 다운받기 설명리셋 버튼 클릭 시 선택메뉴를 초기화하고 싶은 경우에도 객체 단위로 resetTabMenu() 메서드를 호출해 각각 처리할 수 있습니다. 객체지향 프로그래밍의 장점앞의 예제를 통해 확인한 것처럼 객체지향 프로그래밍에서는 프로젝트를 독립적인 객체 단위로 분리해서 작업할 수 있기 때문에 여러 개발자와 협업해 규모가 큰 프로젝트를 진행할 수 있는 장점이 있습니다. 객체지향 프로그래밍을 이용하면 여러 개의 객체로 나눠 작업할 수 있습니다. 객체지향 프로그래밍 vs 클래스 기반 프로그래밍위의 글을 보면 클래스 단위 프로그래밍과 객체지향 프로그래밍이 똑같은 내용 아닐까 라고 생각하실 수 있을꺼 같습니다. 결론 부터 이야기 하자면 맞는 말일 수도 있고 아닐 수도 있습니다. 먼저 엄격한 의미해서 해석하면 이 둘은 다음과 같은 차이점이 있습니다. 일반적으로 객체지향 프로그래밍은 객체지향 프로그래밍 네 가지 특징(추상화, 캡슐화, 상속, 다형성)을 골고루 사용해 코딩하는 프로그래밍을 객체지향이라고 부릅니다. 클래스 단위 프로그래밍은 이런 객체지향 특징을 전혀 사용하지 않고 오직 클래스만을 이용해 코딩하는 방식을 말합니다. 이처럼 이 둘은 전혀 다른 프로그래밍 방법입니다. 이와 반대로 클래스 단위 코딩을 객체지향 프로그래밍이라고 부를 수 있는 이유는 클래스를 만들어 코딩하는 자체에 이미 객체지향 프로그래밍 네 가지 특성 중 추상화와 캡슐화를 사용하고 있기 때문입니다. 이처럼 클래스 기반 프로그래밍은 객체지향 프로그래밍에 포함되는 구조를 가지고 있습니다. 그리고 중요한 사실을 하나 알려드리자면 객체지향 프로그래밍을 배우려면 우선 클래스 기반 프로그래밍에 익숙해 있어야 한다는 점입니다. 이유는 앞에서도 언급한 것처럼 객체를 만드는 수단이 클래스이기 때문입니다. 절차지향 프로그래밍 vs 객체지향 프로그래밍그럼 이제부터 무조건 객체지향 프로그래밍을 이용해서 작업해야 하는 걸까요? 아닙니다. 무조건 객체지향 프로그래밍을 할 필요는 없습니다. 간단한 테스트나 프로젝트를 진행하기 위해 함수 기반인 절차지향 방식으로 하면 쉽게 해결할 수 있는 걸 아직 익숙하지도 않은 객체지향 프로그래밍으로 굳이 할 필요는 없습니다. 즉 필요에 따라 두 가지 방식 중 하나를 선택해서 사용하면 됩니다. 만약 규모 있는 사이트나 웹앱 제작이 목적이라면 간단한 예제를 가지고 객체지향 프로그래밍을 연습해보는 것도 좋은 방법입니다. 구분 절차지향 프로그래밍 객체지향 프로그래밍 처리방식 문제를 여러 개의 함수로 나눠 순차적으로 호출해 처리하는 방식 문제를 여러 개의 객체 단위로 나눠 처리하는 방식 단점 오래전 방식이며 협업해서 진행하는 큰 프로젝트에 맞지 않음 학습 난이도가 높음개발자의 활용 능력이 무엇보다 중요 장점 간단한 프로젝트에 용이함비교적 배우기 쉬움 요즘 가장 많이 사용하는 방식협업에서 진행하는 큰 프로젝트에 적합함 [객체지향 프로그래밍 기초] 절차지향 프로그래밍 VS 객체지향 프로그래밍 [객체지향 프로그래밍 기초] 객체지향 프로그래밍의 특징 [객체지향 프로그래밍 기초] 객체지향 프로그래밍 언어에서 제공하는 기본 기능","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-학습/"},{"name":"객체지향 프로그래밍 기초","slug":"JS/js-학습/객체지향-프로그래밍-기초","permalink":"https://recoveryman.github.io/categories/JS/js-학습/객체지향-프로그래밍-기초/"}],"tags":[]},{"title":"[jQuery플러그인제작] extend() 메서드를 활용한 플러그인 옵션 처리","slug":"jQuery플러그인제작-extend-메서드를-활용한-플러그인-옵션-처리","date":"2018-01-15T01:38:11.000Z","updated":"2018-02-04T12:44:56.722Z","comments":true,"path":"2018/01/15/jQuery플러그인제작-extend-메서드를-활용한-플러그인-옵션-처리/","link":"","permalink":"https://recoveryman.github.io/2018/01/15/jQuery플러그인제작-extend-메서드를-활용한-플러그인-옵션-처리/","excerpt":"","text":"jQuery 플러그인의 경우 기능을 변경할 수 있는 옵션값이 존재합니다. jQuery 에서 제공하는 extend() 메서드를 활용해 좀 더 효율적인 옵션값 처리 방법을 학습해 보겠습니다. 기본 옵션값플러그인을 만들다 보면 플러그인 호출 시 넘겨야 하는 매개변수 값이 많은 경우가 있습니다. 이 값들은 주로 옵션값 입니다. 옵션값은 일반적으로 jQuery 플러그인을 만들때 기본 옶션값을 만들어 사용하고 사용자가 필요로 할때 원하는 값으로 변경할 수 있는 구조로 만듭니다. 먼저 [jQuery플러그인제작] jQuery 플러그인 만들기 에서 예제로 만들어 봤던 플러그인을 확인해 보겠습니다.소스코드 다운받기 [javascript]1234567891011121314151617(function($) &#123; $.fn.removeLi = function() &#123; this.each(function(index) &#123; var $target = $(this); $target.delay(index * 1000).animate(&#123; height: 0 &#125;, 500, \"easeInQuint\" function() &#123; $target.remove(); &#125;) &#125;) return this; &#125;&#125;)(jQuery)$(function() &#123; $(\".menu\").removeLi();&#125;) 코드를 살펴보면 지연시간(5번라인: 1000)과 애니메이션 진행시간(7번라인: 500) 그리고 이징값(7번라인 500 뒤)이 각각 1000밀리초, 500밀리초, “easeInQuint”로 고정돼 있는 것을 확인할 수 있습니다. 현재로서는 이들의 값을 수정해야 하는 경우 플러그인의 내부 코드를 직접 수정해줘야 합니다. 이들의 값을 좀더 쉽게 수정할 수 있게 플러그인에 옵션 값을 추가해 보겠습니다. 추가로 플러그인의 기본 옵션값을 만들어 사용자가 옵션값을 설정하지 않는 경우 기본 옵션값이 적용되게 만들어 보겠습니다. 먼저 풀이 순서에 맞게 다음 내용을 입력해 주세요. 12345678910111213141516171819202122232425262728293031// 플러그인 만들기(function($) &#123; $.defaultOption = &#123; duration: 500, easing: \"easeInQuint\", delayTime: 1000 &#125; $.fn.removeAni = function(duration, easing, delayTime) &#123; // 사용자 옵션 정보 유무 판단 후, 값이 없는 경우 기본값으로 설정 duration = duration || $.defaultOption.duration; easing = easing || $.defaultOption.easing; delayTime = delayTime || $.defaultOption.delayTime; // 옵션값을 변경 this.each(function(index) &#123; var $target = $(this); $target.delay(index * delayTime).animate(&#123; height: 0 &#125;, duration, easing, function() &#123; $target.remove(); &#125;) &#125;) return this; &#125;&#125;)(jQuery)$(function() &#123; // 플러그인 호출 $('.menu li').removeAni();&#125;) 소스코드 다운받기 상단 코드를 기준으로 3번라인: 먼저 오브젝트 리터럴을 이용해 기본 옵션값을 만듭니다. $.defaultOption = {} 9번라인: removeAni 플러그인에 매개변수(duration, easing, delayTime)를 신규로 추가해 줍니다. $.fn.removeAni = function(duration, easing, delayTime) {} 11~13번라인: 옵션값이 없는 경우 기본 옵션값으로 설정할 수 있게 구문을 작성합니다. duration = duration || $.defaultOption.duration; easing = easing || $.defaultOption.easing; delayTime = delayTime || $.defaultOption.delayTime; 20번라인: animate() 메서드에 하드 코딩된 애니메이션 시 값과 이징 함수 값 그리고 지연시간 값 대신 매개변수를 채워 줍니다. $target.delay(index * delayTime).animate({height: 0 }, duration, easing, function() {$target.remove(); }) 소스코드를 다운받아서 removeAni플러그인을 실행시켜 보세요! 123456789/*@ duration = Type: number@ easing = Type: string@ delayTime = Type: number*/$(function() &#123; // 플러그인 호출 $('.menu li').removeAni(duration, easing, delayTime);&#125;) jQuery의 extend() 메서드 소개1 소개jQuery의 extend() 메서드는 객체의 기능(프로퍼티와 메서드)을 합칠 때 사용하는 메서드 입니다. 이 기능은 특히 플러그인 제작 시 옵션값 처리에 유용하게 사용됩니다. 사용법var result = jQuery.extend(target[,object1][,objectN]); 매개변수target: 합쳐진 기능을 최종적으로 저장할 객체object1, objectN: 합쳐질 기능을 가진 객체 리턴값리턴값은 target에 저장되는 값과 같습니다. extend() 메서드 기능예제를 통해 extend() 메서드의 기능을 알아보겠습니다. 12345678910111213141516171819202122232425262728$(function() &#123; var target = &#123; property1: \"a\", property2: \"b\", method1: function() &#123; console.log(\"m1()\"); &#125;, method2: function() &#123; console.log(\"m2()\"); &#125; &#125; var object1 = &#123; property1: \"1_a\", property3: \"1_c\", method1: function() &#123; console.log(\"1_m1()\"); &#125;, method3: function() &#123; console.log(\"1_m3()\"); &#125; &#125; var result = jQuery.extend(target, object1); console.log(\"target = \", target); console.log(\"object1 = \", object1); console.log(\"result = \", result);&#125;) 소스코드 다운받기 결과 설명코드 입력 후 실행 결과를 살펴보면 object1의 기능이 모두 target으로 합쳐지는 것을 확인할 수 있습니다. 또, target과 object1이 같은 기능을 가진 경우 target의 기능은 무시되고 object1의 기능이 우선적으로 합쳐지는 것을 확인할 수 있습니다. 팁var result = jQuery.extend(target, object1); 이 코드는var result = $.extend(target, object1); 이렇게 줄여 쓸 수 있습니다. extend 메서드 사용 시 주의사항 및 해결책extend() 메서드 사용 시 주의해야 할 사실이 하나 있는데요. 앞 예제의 실행 결과에서도 알 수 있는 것처럼 extend() 메서드 실행 후 target 자체도 변경된다는 것입니다. 즉 target과 extend() 메서드의 결과 값이 같게 된다는 것입니다. 뒤에서 설명하겠지만 플러그인에서 extend() 메서드를 활용해 옵션값을 처리할 때 target에 해당하는 기본 옵션값이 변경되면 안 되는 경우가 있습니다. 이때는 다음과 같이 첫 번째 매개변수 값이 빈 값을 넣어주면 됩니다. 예제 실행 후 결과를 확인해 봅시다. 123456789101112131415161718192021222324252627282930$(function() &#123; var target = &#123; property1: \"a\", property2: \"b\", method1: function() &#123; console.log(\"m1()\"); &#125;, method2: function() &#123; console.log(\"m2()\"); &#125; &#125; var object1 = &#123; property1: \"1_a\", property3: \"1_c\", method1: function() &#123; console.log(\"1_m1()\"); &#125;, method3: function() &#123; console.log(\"1_m3()\"); &#125; &#125; var result = $.extend(null, target, object1); // 또는 // var result = jQuery.extend(&#123;&#125;, target, object1); console.log(\"target = \", target); console.log(\"object1 = \", object1); console.log(\"result = \", result);&#125;) 소스코드 다운받기 결과 이어서 extend가 jQuery 플러그인에서 어떻게 유용하게 사용되는지 알아보겠습니다. extend() 메서드를 활용한 플러그인 옵션 처리extend() 메서드를 활용하면 좀 더 쉽게 플러그인 옵션 처리를 할 수 있습니다. 다음 내용은 앞에서 만든 removeAni 플러그인에 extend() 메서드를 활용해 옵션 처리를 한 예제입니다. 123456789101112131415161718192021222324252627282930313233// 플러그인 만들기(function($) &#123; $.defaultOption = &#123; duration: 500, easing: \"easeInQuint\", delayTime: 1000 &#125; $.fn.removeAni = function(options) &#123; // 사용자 옵션 정보 유무 판단 후, 값이 없는 경우 기본값으로 설정 options = $.extend(null, $.defaultOption, options); // 옵션값을 변경 this.each(function(index) &#123; var $target = $(this); $target.delay(index * options.delayTime).animate(&#123; height: 0 &#125;, options.duration, options.easing, function() &#123; $target.remove(); &#125;) &#125;) return this; &#125;&#125;)(jQuery)$(function() &#123; // 플러그인 호출 $('.menu li').removeAni(&#123; duration: 1000, easing: \"easeOutElastic\", delayTime: 500 &#125;);&#125;) 소스코드 다운받기 설명 9번라인: 먼저 removeAni 플러그인에서 옵션값을 3개의 매개변수(duration, easing, delayTime) 대신 하나의 오브젝트 리터럴을 만들어 사용할 것이기 때문에 매개변수를 하나의 매개변수로 변경해 줍니다. $.fn.removeAni = function(options) {} 11번라인: extend() 메서드를 활용해 기본 옵션값과 사용자가 입력한 옵션값을 합쳐 줍니다. options = $.extend(null, $.defaultOption, options); 16,18번라인: 지연시간과 애니메이션 시간 그리고 이징 함수 정보를 11번 라인에서 만든 옵션값으로 변경해 줍니다. $target.delay(index * options.delayTime).animate({height: 0 }, options.duration, options.easing, function() {$target.remove(); }) 29~31번라인: 옵션값을 오브젝트 리터럴로 변경해 줍니다. [jQuery플러그인제작] jQuery 확장 소개 [jQuery플러그인제작] jQuery유틸리티 만들기 [jQuery플러그인제작] jQuery 플러그인 만들기 [jQuery플러그인제작] 함수 기반 플러그인 만들기 [jQuery플러그인제작] 클래스 기반 플러그인 만들기 [jQuery플러그인제작] 플러그인 그룹 만들기 [jQuery플러그인제작] extend() 메서드를 활용한 플러그인 옵션 처리","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-학습/"}],"tags":[]},{"title":"[jQuery플러그인제작] 플러그인 그룹 만들기","slug":"jQuery플러그인제작-플러그인-그룹-만들기","date":"2018-01-10T23:30:29.000Z","updated":"2018-01-15T01:39:41.858Z","comments":true,"path":"2018/01/11/jQuery플러그인제작-플러그인-그룹-만들기/","link":"","permalink":"https://recoveryman.github.io/2018/01/11/jQuery플러그인제작-플러그인-그룹-만들기/","excerpt":"","text":"jQuery 플러그인을 만들다 보면 하나 이상의 연관된 플러그인을 만들게 됩니다. 이 포스팅에서는 플러그인 그룹 만드는 방법과 플러그인 간의 연동 방법을 해보겠습니다. 소개플러그인 그룹이란 연관된 클래스 기반으로 jQuery 플러그인을 만들 때 클래스 인스턴스를 연관 있는 플러그인에서 공유 해서 사용하는 구조룰 의미합니다. 예제[jQuery플러그인제작] 클래스 기반 플러그인 만들기에서 만든 tabMenu 플러그인을 좀 더 확장해 보겠습니다. 소스코드 다운받기 이전장 마지막에 적어놨던것과 같이 페이지 로딩 시 원하는 탭메뉴의 원하는 탭을 미리 선택하는 기능을 만들어 보겠습니다. [플러그인 그룹 플러그인 js 코드]12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273(function($) &#123; function TabMenu(selector) &#123; var $tabMenu = null; var $menuItems = null; var $selectMenuItem = null; // 요소 초기화 및 이벤트 등록 호출 this.init(selector); this.initEvent(); &#125; // 요소 초기화 TabMenu.prototype.init = function(selector) &#123; this.$tabMenu = $(selector); this.$menuItems = this.$tabMenu.find(\"ul\").find(\"li\"); &#125; // 이벤트 등록 TabMenu.prototype.initEvent = function() &#123; var objThis = this; this.$menuItems.on('click', function(e) &#123; e.preventDefault(); objThis.setSelectItem($(this)); &#125;) &#125; // $menuItem에 해당하는 메뉴 아이템 선택하기 TabMenu.prototype.setSelectItem = function($menuItem) &#123; // 기존 선택메뉴 아이템을 비활성화 처리 if(this.$selectMenuItem)&#123; this.$selectMenuItem.removeClass('on'); &#125; // 신규 아이템 활성화 처리하기 this.$selectMenuItem = $menuItem; this.$selectMenuItem.addClass('on'); &#125; // 인덱스에 해당하는 메뉴 아이템 선택하기 TabMenu.prototype.setSelectItemAt = function(index) &#123; var $menuItem = this.$menuItems.eq(index); // 기존 메서드 재사용 this.setSelectItem($menuItem); &#125; $.fn.tabMenu = function() &#123; this.each(function(index) &#123; // 인스턴스 생성 var tabMenu = new TabMenu(this); $(this).data(\"tabMenu\", tabMenu); &#125;) return this; &#125; // n번째 탭메뉴 아이템 선택하기 $.fn.selectTabMenuItemAt = function(selectIndex) &#123; this.each(function(index) &#123; // 저장한 TabMenu 객체 구하기 var tabMenu = $(this).data(\"tabMenu\"); if(tabMenu) &#123; // n번째 메뉴 아이템 선택하기 tabMenu.setSelectItem(tabMenu.$menuItems.eq(selectIndex)) &#125; &#125;) return this; &#125;&#125;)(jQuery)$(function() &#123; $(\".tab1\").tabMenu().selectTabMenuItemAt(1); $(\".tab2\").tabMenu().selectTabMenuItemAt(2);&#125;) 결과소스코드 다운받기 우선 [플러그인 그룹 플러그인 js 코드] 기준으로 51번 라인: 먼저 기존 tabMenu 플러그인 구문에 생성한 TabMenu 클래스 인스턴스를 data()를 활용해 저장합니다. data() 메서드를 통해서 어떤 값이 들어가 있는지 확인이 가능합니다. 57번 라인: n번째 탭메뉴 아이템을 선택하는 플러그인(selectTabMenuItemAt)을 신규로 만듭니다. 이 selectTabMenuItemAt 플러그인은 n번째 탭메뉴를 선택하게 하는 플러그인 입니다. 60번 라인: 51번 라인에서 저장한 탭메뉴 인스턴스를 구합니다. 아래와 같은 형태의 값이 변수에 담기게 됩니다. 63번 라인: 이 라인은 if 문으로 감싸져 있습니다. if 문에서는 60번 라인의 지역변수 tabMenu에 값이 담기게 되어 true를 반환합니다. 그래서 그 안의 63번째 라인이 실행되는데요. 탭메뉴에서 제공하는 setSelectItem() 메서드를 호출해 n번째에 해당하는 메뉴 아이템을 활성화해 주는 기능을 하고 있습니다. 아래 그림을 보시면 63번 라인의 코드에 대한 의미를 알 수 있습니다. 결론플러그인 그룹이란?예제를 가지고 설명하면 tabMenu 플러그인과 selectTabMenuItemAt 플러그인이 탭메뉴 플러그인 그룹이 됩니다. 플러그인 그룹 구조특정 플러그인에서 생성한 클래스의 인스턴스를 다른 플러그인에서 재사용 해야하는 경우 jQuery의 data() 메서드를 활용해 생성한 인스턴스를 저장해 재사용 하면 됩니다. [jQuery플러그인제작] jQuery 확장 소개 [jQuery플러그인제작] jQuery유틸리티 만들기 [jQuery플러그인제작] jQuery 플러그인 만들기 [jQuery플러그인제작] 함수 기반 플러그인 만들기 [jQuery플러그인제작] 클래스 기반 플러그인 만들기 [jQuery플러그인제작] 플러그인 그룹 만들기 [jQuery플러그인제작] extend() 메서드를 활용한 플러그인 옵션 처리","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-학습/"}],"tags":[]},{"title":"[jQuery플러그인제작] 클래스 기반 플러그인 만들기","slug":"jQuery플러그인제작-클래스-기반-플러그인-만들기","date":"2018-01-10T07:22:45.000Z","updated":"2018-01-15T01:39:52.523Z","comments":true,"path":"2018/01/10/jQuery플러그인제작-클래스-기반-플러그인-만들기/","link":"","permalink":"https://recoveryman.github.io/2018/01/10/jQuery플러그인제작-클래스-기반-플러그인-만들기/","excerpt":"","text":"01. 문법123456789101112131415161718192021(function($) &#123; function MyClass() &#123; this.프로퍼티1; this.프로퍼티2; // ... &#125; MyClass.prototype.메서드1 = function() &#123; // ... &#125; MyClass.prototype.메서드2 = function() &#123; // ... &#125; $.fn.플러그인이름 = function() &#123; this.each(function(index) &#123; // 인스턴스 생성 var obj = new MyClass(); &#125;) return this; &#125;&#125;)(jQuery) 문법을 살펴보면 기능을 prototype 기반 클래스로 만든 후 플러그인 에서 클래스 인스턴스를 생성한 후 사용하는 구조로 돼 있습니다. 이렇게 구성하면 [jQuery플러그인제작] 함수 기반 플러그인 만들기 에서 가지고 있던 문제점을 해결할 수 있습니다. 예를 들어 탭메뉴가 3개라면 init(), initEvent(), setSelectItem() 메서드는 모두 prototype 에 만들어지기 때문에 공유해서 사용됩니다. 또한 이 메서드들은 오직 한번만 만들어 집니다. 참고: 함수 단위 코딩vs클래스 단위 코딩 02. 예제예제를 해보기 전에 먼저 함수 단위 코딩vs클래스 단위 코딩에서 만들어 보았던 예제 하나를 먼저 확인해 보겠습니다.소스코드 다운받기위의 코드를 클래스 기반 플러그인으로 제작하기. 풀이클래스 기반 플러그인 역시 jQuery 플러그인 문법에 맞게 플러그인 기본 구조를 만들어 줍니다. 코드에 대한 설명은 [jQuery플러그인제작] 함수 기반 플러그인 만들기에서 하단의 클래스 단위 코딩을 참고하시기 바랍니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354(function($) &#123; function TabMenu(selector) &#123; var $tabMenu = null; var $menuItems = null; var $selectMenuItem = null; // 요소 초기화 및 이벤트 등록 호출 this.init(selector); this.initEvent(); &#125; // 요소 초기화 TabMenu.prototype.init = function(selector) &#123; this.$tabMenu = $(selector); this.$menuItems = this.$tabMenu.find(\"ul\").find(\"li\"); &#125; // 이벤트 등록 TabMenu.prototype.initEvent = function() &#123; var objThis = this; this.$menuItems.on('click', function(e) &#123; e.preventDefault(); objThis.setSelectItem($(this)); &#125;) &#125; // $menuItem에 해당하는 메뉴 아이템 선택하기 TabMenu.prototype.setSelectItem = function($menuItem) &#123; // 기존 선택메뉴 아이템을 비활성화 처리 if(this.$selectMenuItem)&#123; this.$selectMenuItem.removeClass('on'); &#125; // 신규 아이템 활성화 처리하기 this.$selectMenuItem = $menuItem; this.$selectMenuItem.addClass('on'); &#125; // 인덱스에 해당하는 메뉴 아이템 선택하기 TabMenu.prototype.setSelectItemAt = function(index) &#123; var $menuItem = this.$menuItems.eq(index); // 기존 메서드 재사용 this.setSelectItem($menuItem); &#125; $.fn.tabMenu = function() &#123; this.each(function(index) &#123; // 인스턴스 생성 var obj = new MyClass(); &#125;) return this; &#125;&#125;)(jQuery) 우선 함수 단위 코딩vs클래스 단위 코딩의 클래스 단위 코딩 부분을 jQuery 플러그인 으로 사용할 수 있게 포장을 했습니다. 클래스 단위 로 플러그인을 만들기 때문에 인스턴스를 생성해 줘야 합니다. 다음의 코드를 보시기 바랍니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354(function($) &#123; function TabMenu(selector) &#123; var $tabMenu = null; var $menuItems = null; var $selectMenuItem = null; // 요소 초기화 및 이벤트 등록 호출 this.init(selector); this.initEvent(); &#125; // 요소 초기화 TabMenu.prototype.init = function(selector) &#123; this.$tabMenu = $(selector); this.$menuItems = this.$tabMenu.find(\"ul\").find(\"li\"); &#125; // 이벤트 등록 TabMenu.prototype.initEvent = function() &#123; var objThis = this; this.$menuItems.on('click', function(e) &#123; e.preventDefault(); objThis.setSelectItem($(this)); &#125;) &#125; // $menuItem에 해당하는 메뉴 아이템 선택하기 TabMenu.prototype.setSelectItem = function($menuItem) &#123; // 기존 선택메뉴 아이템을 비활성화 처리 if(this.$selectMenuItem)&#123; this.$selectMenuItem.removeClass('on'); &#125; // 신규 아이템 활성화 처리하기 this.$selectMenuItem = $menuItem; this.$selectMenuItem.addClass('on'); &#125; // 인덱스에 해당하는 메뉴 아이템 선택하기 TabMenu.prototype.setSelectItemAt = function(index) &#123; var $menuItem = this.$menuItems.eq(index); // 기존 메서드 재사용 this.setSelectItem($menuItem); &#125; $.fn.tabMenu = function() &#123; this.each(function(index) &#123; // 인스턴스 생성 var tabMenu = new TabMenu(this); &#125;) return this; &#125;&#125;)(jQuery) 50번 라인에서 tabMenu 플러그인 내부에서 TabMenu 클래스의 인스턴스를 생성하는 구문을 작성해 주었습니다. 다만 이렇게 코드를 작성했어도 아직은 페이지가 시작하자마자 원하는 탭을 선택할 수 없습니다.그건 다음장에서 확인해 보도록 하겠습니다. 프로토타입 클래스 기반 플러그인 결과소스코드 다운받기 [jQuery플러그인제작] jQuery 확장 소개 [jQuery플러그인제작] jQuery유틸리티 만들기 [jQuery플러그인제작] jQuery 플러그인 만들기 [jQuery플러그인제작] 함수 기반 플러그인 만들기 [jQuery플러그인제작] 클래스 기반 플러그인 만들기 [jQuery플러그인제작] 플러그인 그룹 만들기 [jQuery플러그인제작] extend() 메서드를 활용한 플러그인 옵션 처리","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-학습/"}],"tags":[]},{"title":"[jQuery플러그인제작] 함수 기반 플러그인 만들기","slug":"jQuery플러그인제작-함수-기반-플러그인-만들기","date":"2018-01-09T07:50:15.000Z","updated":"2018-01-15T01:39:58.853Z","comments":true,"path":"2018/01/09/jQuery플러그인제작-함수-기반-플러그인-만들기/","link":"","permalink":"https://recoveryman.github.io/2018/01/09/jQuery플러그인제작-함수-기반-플러그인-만들기/","excerpt":"","text":"구문[구문]12345678910111213141516(function($) &#123; this.each(function(index) &#123; // 이 안쪽에 플러그인 구현 코드가 위치 var 변수1; var 변수2; function 함수1() &#123; // ... &#125; function 함수2() &#123; // ... &#125; &#125;)&#125;)(jQuery) [함수기반 플러그인 이란?]플러그인 구현 코드를 each() 메서드의 매개변수 값으로 넘기는 함수 내부에 작성하는 구조를 의미합니다. 예제예제를 해보기 전에 먼저 함수 단위 코딩vs클래스 단위 코딩에서 만들어 보았던 예제 하나를 먼저 확인해 보겠습니다.소스코드 다운받기 파일을 실행하거나 jsFiddle 로 확인해 보시면 이렇게 독립적으로 실행되는 두개의 탭메뉴를 확인할 수 있습니다. 코드를 살펴보면 여러개의 변수와 함수로 구성이 되어 있는데요. 코드 설명은 함수 단위 코딩vs클래스 단위 코딩 에서 설명을 했기에 생략하겠습니다. 이번 예제는 바로 함수기반으로 만들어진 탭메뉴를 jQuery 플러그인 으로 만드는 것입니다. $(&quot;.tabArea&quot;).tabMenu(); 같이 jQuery 스타일로 구문이 동작할 수 있게 tabMenu 플러그인을 만들어 보겠습니다. 풀이[01] jQuery 플러그인 기본 구조 만들기 123456789101112131415// tabMenu 플러그인(function($) &#123; $.fn.tabMenu = function() &#123; this.each(function(index) &#123; // 구현 코드 위치 console.log(this); &#125;) return this; &#125;&#125;)(jQuery)$(function() &#123; // 플러그인 호출 $('.tabArea').tabMenu();&#125;) 3번 라인: jQuery 플러그인 구조에 맞게 tabMenu플러그인을 만들어 줍니다. 4번 라인: 선택자에 해당하는 노드 개수만큼 탭메뉴를 생성하기 위해 each() 메서드를 실행합니다. 6번 라인: 탭메뉴 코드를 작성하기 전 탭메뉴 개수만큼 each() 메서드로 넘긴 콜백함수가 실행되는지 확인하기 위해 현재 루프에 해당하는 노드(this)를 콘솔창에 출력합니다. 코드를 입력한 후 크롬브라우저에서 console창을 확인해봤습니다.소스코드 다운받기 [02] 탭메뉴 구현코드 넣기우선 탭메뉴가 구현되는 구현코드를 jQuery 플러그인 구조 안에 this.each(function(index) { })사이에 넣어줍니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445// tabMenu 플러그인(function($) &#123; $.fn.tabMenu = function() &#123; this.each(function(index) &#123; // 구현 코드 위치 var $tabMenu = null; var $menuItems = null; var $selectMenuItem = null; // 요소 초기화 function init(selector) &#123; $tabMenu = $(selector); $menuItems = $tabMenu.find(\"ul\").find(\"li\"); &#125; // 이벤트 등록 function initEvent() &#123; $menuItems.on('click', function(e) &#123; e.preventDefault(); setSelectItem($(this)); &#125;) &#125; // $menuItem에 해당하는 메뉴 아이템 선택하기 function setSelectItem($menuItem) &#123; // 기존 선택메뉴 아이템을 비활성화 처리 if($selectMenuItem)&#123; $selectMenuItem.removeClass('on'); &#125; $selectMenuItem = $menuItem; $selectMenuItem.addClass('on'); &#125; // 인덱스에 해당하는 메뉴 아이템 선택하기 function setSelectItemAt(index) &#123; setSelectItem($menuItems.eq(index)); &#125; init(selector); initEvent(); &#125;) return this; &#125;&#125;)(jQuery) 이 코드를 넣은 플러그인을 실행시키면 위 코드의 40번째 라인에서 선택자의 문제로 코드가 동작하지 않습니다. 때문에 jQuery 플러그인 tabMenu() 가 호출될때 현재 노드를 반환해 줘야 합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445// tabMenu 플러그인(function($) &#123; $.fn.tabMenu = function() &#123; this.each(function(index) &#123; // 구현 코드 위치 var $tabMenu = null; var $menuItems = null; var $selectMenuItem = null; // 요소 초기화 function init(selector) &#123; $tabMenu = $(selector); $menuItems = $tabMenu.find(\"ul\").find(\"li\"); &#125; // 이벤트 등록 function initEvent() &#123; $menuItems.on('click', function(e) &#123; e.preventDefault(); setSelectItem($(this)); &#125;) &#125; // $menuItem에 해당하는 메뉴 아이템 선택하기 function setSelectItem($menuItem) &#123; // 기존 선택메뉴 아이템을 비활성화 처리 if($selectMenuItem)&#123; $selectMenuItem.removeClass('on'); &#125; $selectMenuItem = $menuItem; $selectMenuItem.addClass('on'); &#125; // 인덱스에 해당하는 메뉴 아이템 선택하기 function setSelectItemAt(index) &#123; setSelectItem($menuItems.eq(index)); &#125; init(this); // this로 현재 노드를 반환 initEvent(); &#125;) return this; &#125;&#125;)(jQuery) 결과소스코드 다운받기 정리앞 예제를 이용해 기존 함수 기반으로 만들어진 탭메뉴를 jQuery 플러그인 방식으로 만들어 봤습니다. 하지만 이 방식에는 tabMenu 플러그인에 의해 탭메뉴가 만들어 지는 만큼 init(), initEvent() 등의 내부 함수가 중복해서 만들어 지는 문제점이 있습니다. 다음 장에선 prototype 클래스를 이용해서 이 문제를 해결한 플러그인을 제작해 보겠습니다. [jQuery플러그인제작] jQuery 확장 소개 [jQuery플러그인제작] jQuery유틸리티 만들기 [jQuery플러그인제작] jQuery 플러그인 만들기 [jQuery플러그인제작] 함수 기반 플러그인 만들기 [jQuery플러그인제작] 클래스 기반 플러그인 만들기 [jQuery플러그인제작] 플러그인 그룹 만들기 [jQuery플러그인제작] extend() 메서드를 활용한 플러그인 옵션 처리","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-학습/"}],"tags":[]},{"title":"[jQuery플러그인제작] jQuery 플러그인 만들기 ","slug":"jQuery플러그인제작-jQuery-플러그인-만들기","date":"2018-01-04T05:44:43.000Z","updated":"2018-01-15T01:40:04.977Z","comments":true,"path":"2018/01/04/jQuery플러그인제작-jQuery-플러그인-만들기/","link":"","permalink":"https://recoveryman.github.io/2018/01/04/jQuery플러그인제작-jQuery-플러그인-만들기/","excerpt":"","text":"jQuery 플러그인 소개제이쿼리 플러그인은 아코디언 메뉴, 탭메뉴, 슬라이더 등과 같이 특정 기능을 재사용 할 때 사용하고자 하는 포장 기술 입니다. jQuery 플러그인 구조12345678(function($) &#123; $.fn.플러그인이름 = function() &#123; this.each(function(index) &#123; // 기능 구현 &#125;) return this; &#125;&#125;)(jQuery) jQuery 유틸리티의 경우 jQuery 클래스 메서드로 만드는 것과 달리 jQuery 플러그인은 jQuery 클래스의 fn 이란 곳에 만듭니다. 여기서 fn은 protorype을 줄여쓴 닉네입 입니다. 예를 들어 지금까지 즐겨 사용한 find(), filter(), children() 등의 기능은 다음과 같이 표현할 수 있습니다. 12345678910111213function jQuery() &#123; // ...&#125;jQuery.prototype.find = function() &#123; // ...&#125;jQuery.prototype.filter = function() &#123; // ...&#125;jQuery.prototype.children = function() &#123; // ...&#125; 즉 사용 해왔던 jQuery 플러그인은 모두 jQuery 의 인스턴스 메서드일 뿐입니다. 인스턴스 프로퍼티와 메서드vs클래스 프로퍼티와 메서드 사용자 플러그인 또한 동일한 구조를 가지므로 다음과 같이 jQuery 클래스 메서드(플러그인 이름)를 추가한 것뿐입니다. 123456789function jQuery() &#123; // ...&#125;// ...jQuery.prototype.플러그인이름 = function() &#123; // ...&#125; jQuery 플러그인 구조 분석jQuery 플러그인을 만들기 위해서는 jQuery 유틸리티와 달리 jQuery 플러그인은 내부 구조를 확실히 알고 있어야 합니다.p 태그의 외곽선을 붉은색으로 바꿔주는 간단한 플러그인제작을 하면서 설명하겠습니다. [예제1]1234567891011121314// redColor 플러그인 정의(function($) &#123; $.fn.redColor = function() &#123; this.each(function(index) &#123; $(this).css('border', '4px solid #f00'); &#125;) return this; &#125;&#125;)(jQuery)$(function() &#123; // redColor 플러그인 사용 $('p').redColor();&#125;) 소스코드 다운받기 [1.] this.each()*: 일단 this.each() 를 해석하기 위해서는 앞에 위치한 this가 무엇을 의미하는지 파악해야 합니다. 앞에서도 알아본 것처럼 $.fn.redColor을 풀어서 설명하면 다음과 같이 표현할 수 있습니다. 12345678910111213141516$.fn.redColor = function() &#123; this.each(function(index) &#123; $(this).css('border', '4px solid #f00'); &#125;) return this;&#125;// 위 코드와 아래 코드는 동일합니다.// 달라진 점은 $.fn 을 풀어쓰면 $.prototype 으로 사용할 수 있습니다.$.prototype.redColor = function() &#123; this.each(function(index) &#123; $(this).css('border', '4px solid #f00'); &#125;) return this;&#125; 즉 redColor 플러그인은 jQuery 메서드를 부르는 또하나의 이름일 뿐 클래스의 일반 메서드와 동일하다는 것을 알 수 있습니다. 클래스의 일반 메서드를 사용하기 위해서는 먼저 인스턴스를 생성해야 하는데요. 이 인스턴스는 바로 아래 코드중 3번 코드에 의해 실행됩니다. [클래스의 일반 메서드를 사용하기 위한 인스턴스 생성]1234$(function() &#123; // redColor 플러그인 사용 $('p').redColor();&#125;) 정리하자면 $(&#39;p&#39;).redColor(); 부분의 $(&#39;p&#39;) 에 의해서 인스턴스가 생성되고 접근연산자(.)를 활용해 신규 생성한 redColor() 메서드(신규 플러그인)를 호출한 것이 됩니다.이에 따라 redColor() 메서드 내부의 this는 redColor() 메서드를 호출한 jQuery 객체 자체가 되며 this.each()는 jQuery 에서 제공하는 eahc() 메서드를 호출한 것이 됩니다. [2.] $(this).css(‘border’, ‘4px solid #f00’);: each() 메서드 내부에서 this 는 현재 처리하고 있는 자바스크립트 DOM 노드 입니다. 자바스크립트에는 스타일을 변경할때 유용하게 사용하는 .css() 메서드가 없기 때문에 $(this) 구문을 이용해 jQuery 인스턴스를 생성한 후 css() 메서드를 사용했습니다. [3.] return this의 정체: $(&#39;p&#39;).redColor().on(...)과 같이 redColor() 플러그인 호출 후 jQuery 메서드를 체인구조로 호출할 수 있게 하기 위해서는 this 를 리턴해줘야 합니다. 좀더 풀어서 설명하면 $(&#39;p&#39;).redColor().on(...)을 다음과 같이 표현할 수도 있습니다. 12var $temp = $('p').redColor();$temp.on('...'); 이때 $temp에 저장되는 값이 바로 return this 값이 됩니다. [1.] 에서 알아본 것처럼 this는 jQuery 인스턴스 이기 때문에 $temp.on() 메서드를 연속해서 호출할 수 있게 됩니다. 사용자 정의 jQuery플러그인 만들기li를 순차적으로 지우는 플러그인 만들기 [Markup]1234567&lt;ul class=\"menu\"&gt; &lt;li&gt;menu1&lt;/li&gt; &lt;li&gt;menu2&lt;/li&gt; &lt;li&gt;menu3&lt;/li&gt; &lt;li&gt;menu4&lt;/li&gt; &lt;li&gt;menu5&lt;/li&gt;&lt;/ul&gt; [jQuery plugin]1234567891011121314151617(function($) &#123; $.fn.removeLi = function() &#123; this.each(function(index) &#123; var $target = $(this); $target.delay(index * 1000).animate(&#123; height: 0 &#125;, 500, function() &#123; $target.remove(); &#125;) &#125;) return this; &#125;&#125;)(jQuery)$(function() &#123; $(\".menu\").removeLi();&#125;) 결과 (결과를 다시 보고 싶을 땐 다른 탭 클릭 후 result 탭 클릭) 소스코드 다운받기 [jQuery플러그인제작] jQuery 확장 소개 [jQuery플러그인제작] jQuery유틸리티 만들기 [jQuery플러그인제작] jQuery 플러그인 만들기 [jQuery플러그인제작] 함수 기반 플러그인 만들기 [jQuery플러그인제작] 클래스 기반 플러그인 만들기 [jQuery플러그인제작] 플러그인 그룹 만들기 [jQuery플러그인제작] extend() 메서드를 활용한 플러그인 옵션 처리","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-학습/"}],"tags":[]},{"title":"[jQuery플러그인제작] jQuery유틸리티 만들기","slug":"jQuery플러그인제작-jQuery유틸리티-만들기","date":"2017-12-28T08:02:19.000Z","updated":"2018-01-15T01:40:15.967Z","comments":true,"path":"2017/12/28/jQuery플러그인제작-jQuery유틸리티-만들기/","link":"","permalink":"https://recoveryman.github.io/2017/12/28/jQuery플러그인제작-jQuery유틸리티-만들기/","excerpt":"","text":"유틸리티 소개 jQuery 유틸리티는 jQuery 의 trim() 메서드와 같이 주로 도움을 주는 기능을 합니다. jQuery 유틸리티는 jQuery 인스턴스를 생성하지 않고 직접 접근해서 사용 합니다. 12345jQuery.유틸리티();// 또는$.유틸리티(); jQuery 에서 기본으로 제공해 주는 유틸리티 - 바로가기 유틸리티 구조[문법]123456(function($) &#123; $.유틸리티 = function() &#123; // 기능구현 &#125;&#125;)(jQuery);jQuery.유틸리티(); // 사용하기 2번 라인의 $ 는 jQuery 클래스 자체를 나타내며 jQuery 의 클래스 메서드 입니다. 즉. 클래스 인스턴스를 생성하지 않고 바로 접근해서 사용할 수 있다는 의미 입니다. 인스턴스 프로퍼티와 메서드vs클래스 프로퍼티와 메서드 [사용법]12345jQuery.유틸리티();// 또는$.유틸리티(); 사용법은 일반 클래스 메서드 호출하듯 호출. [사용 예]12345$(function() &#123; var str = \" 회복맨 \"; console.log($.trim(str)); console.log(jQuery.trim(str));&#125;) 사용자 정의 jQuery 유틸리티 만들기인자로 숫자를 넣으면 3자리 마다 콤마(,) 를 삽입 하는 유틸리티 1234567891011121314151617181920212223(function($) &#123; $.addComma = function(value) &#123; // 숫자를 문자로 형변환 var data = value + \"\"; // 문자를 배열로 var aryResult = data.split(\"\"); // 배열 요소를 뒤에서 세자리 수마다 콤마 추가 하기 var startIndex = aryResult.length - 3; for( var i = startIndex; i &gt; 0; i -= 3 )&#123; aryResult.splice(i, 0, \",\"); &#125; // 배열을 문자열 처리후 리턴 return aryResult.join(\"\"); &#125;&#125;)(jQuery);// 사용console.log($.addComma(123))console.log($.addComma(12345))console.log($.addComma(12345678)) 소스코드 다운받기 [jQuery플러그인제작] jQuery 확장 소개 [jQuery플러그인제작] jQuery유틸리티 만들기 [jQuery플러그인제작] jQuery 플러그인 만들기 [jQuery플러그인제작] 함수 기반 플러그인 만들기 [jQuery플러그인제작] 클래스 기반 플러그인 만들기 [jQuery플러그인제작] 플러그인 그룹 만들기 [jQuery플러그인제작] extend() 메서드를 활용한 플러그인 옵션 처리","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-학습/"}],"tags":[]},{"title":"[jQuery플러그인제작] jQuery 확장 소개","slug":"jQuery플러그인제작-jQuery-확장-소개","date":"2017-12-28T05:08:04.000Z","updated":"2018-01-15T01:40:10.572Z","comments":true,"path":"2017/12/28/jQuery플러그인제작-jQuery-확장-소개/","link":"","permalink":"https://recoveryman.github.io/2017/12/28/jQuery플러그인제작-jQuery-확장-소개/","excerpt":"","text":"jQuery 확장에는 유틸리티와 플러그인 두 가지가 있습니다. jQuery 확장이란123456// 자바스크립트 방식var tabMenu1 = new TabMenu('.tabMenu1');TabMenuenu.setSelectAt(1);// jQuery 플러그인 방식$(\".tabMenu1\").setSelectAt(1); jQuery 확장 요소 종류1.유틸리티 문자열의 공백을 제거해주는 jQuery의 trim() 메서드와 같은 유틸리티는 주로 도움을 주는 기능을 합니다.jQuery 인스턴스를 생성하지 않고 jQuery 클래스에 직접 접근하여 사용합니다. 1jQuery.유틸리티(); 1$.유틸리티(); 2.플러그인 특정 기능을 재사용 하고자 할 때 사용하는 포장 기능 입니다. 1$('선택자').플러그인(옵션); 12var $결과 = $('선택자');$결과.플러그인(옵션); [jQuery플러그인제작] jQuery 확장 소개 [jQuery플러그인제작] jQuery유틸리티 만들기 [jQuery플러그인제작] jQuery 플러그인 만들기 [jQuery플러그인제작] 함수 기반 플러그인 만들기 [jQuery플러그인제작] 클래스 기반 플러그인 만들기 [jQuery플러그인제작] 플러그인 그룹 만들기 [jQuery플러그인제작] extend() 메서드를 활용한 플러그인 옵션 처리","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-학습/"}],"tags":[]},{"title":"패키지","slug":"패키지","date":"2017-12-27T07:21:44.000Z","updated":"2017-12-28T04:46:51.856Z","comments":true,"path":"2017/12/27/패키지/","link":"","permalink":"https://recoveryman.github.io/2017/12/27/패키지/","excerpt":"","text":"패키지란함수는 특정 알고리즘이나 구문의 영역을 나누기 위해 사용하는 포장 기술.클래스는 연관있는 변수와 함수를 묶을때 사용. 패키지는 연관있는 클래스를 묶을 때 사용 자바스크립트에서 패키지자바스크립트는 다른 언어와 달리 패키지 문법을 제공하지 않습니다.그래서 패키지 스럽게 흉내를 냅니다. 123456789101112131415161718192021222324252627282930313233var study = &#123;&#125;;study.ui = &#123;&#125;// property 선언study.ui.TabMenu = function() &#123; this.property = \"TAB MENU\";&#125;study.ui.Slider = function() &#123; this.property = \"SLIDER\"&#125;// method 선언study.ui.TabMenu.prototype.method = function() &#123; return this.property;&#125;study.ui.Slider.prototype.method = function() &#123; return this.property;&#125;// 버전및 제작자 정보study.version = \"0.1.0\";study.getInfo = function() &#123; var info = &#123; developer: \"반찬가게알바\", email: \"고등어@등푸른생선.com\", desc: \"저희 가게의 반찬은 고등어가 제일 맛있습니다!\" &#125; return info;&#125;// 인스턴스 생성var tabMenu = new study.ui.TabMenu();var slider = new study.ui.Slider(); 위의 코드를 약간만 정리해 보면 다음과 같이 나올듯 합니다. 1234567891011121314151617181920212223242526272829303132var study = &#123; // 클래스 프로퍼티 메소드 를 여기에 넣었습니다. version: \"0.1.0\", getInfo: function() &#123; var info = &#123; developer: \"반찬가게알바\", email: \"고등어@등푸른생선.com\", desc: \"저희 가게의 반찬은 고등어가 제일 맛있습니다!\" &#125; return info; &#125;&#125;;study.ui = &#123; // property 선언을 ui 안쪽에 두었습니다. TabMenu: function() &#123; this.property = \"TAB MENU\"; &#125;, Slider: function() &#123; this.property = \"SLIDER\" &#125;&#125;// method 선언study.ui.TabMenu.prototype.method = function() &#123; return this.property;&#125;study.ui.Slider.prototype.method = function() &#123; return this.property;&#125;// 인스턴스 생성var tabMenu = new study.ui.TabMenu();var slider = new study.ui.Slider(); 사용 방법[사용]123456// 인스턴스 프로퍼티 메소드 사용tabMenu.method();slider.method();// 클래스 프로퍼티 메소드 사용study.getInfo().desc; 결과 클래스정의 3가지 비교 함수 단위 코딩vs클래스 단위 코딩 인스턴스 프로퍼티와 메서드vs클래스 프로퍼티와 메서드 패키지","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-학습/"}],"tags":[]},{"title":"인스턴스 프로퍼티와 메서드vs클래스 프로퍼티와 메서드","slug":"인스턴스-프로퍼티와-메서드vs클래스-프로퍼티와-메서드","date":"2017-12-27T02:07:02.000Z","updated":"2017-12-28T04:36:00.088Z","comments":true,"path":"2017/12/27/인스턴스-프로퍼티와-메서드vs클래스-프로퍼티와-메서드/","link":"","permalink":"https://recoveryman.github.io/2017/12/27/인스턴스-프로퍼티와-메서드vs클래스-프로퍼티와-메서드/","excerpt":"","text":"인스턴스 프로퍼티와 메서드란[인스턴스 프로퍼티와 메서드]클래스의 인스턴스를 생성 후 사용할 수 있는 프로퍼티와 메서드를 뜻함 [예]12var tabMenu1 = new TabMenu(\".tab1\");tabMenu1.setSelectItemAt(1); 클래스 프로퍼티와 메서드란[클래스 프로퍼티와 메서드]인스턴스를 생성하지 않고도 사용할 수 있는 프로퍼티와 메서드 만드는 방법 [문법]12345function 클래스_이름() &#123; // ...&#125;클래스_이름.프로퍼티 = 값;클래스_이름.메서드 = function()&#123;&#125; 여기서 클래스 이름은 인스턴스가 아닙니다. [차이]123456789101112131415161718function TabMenu() &#123; // ..&#125;// 인스턴스 프로퍼티와 메서드TabMenu.prototype.property1 = \"string\";TabMenu.prototype.method1 = function()&#123;return \"method1\"&#125;;// 클래스 프로퍼티와 메서드TabMenu.property2 = \"string\";TabMenu.method2 = function()&#123;return \"method2\"&#125;;var tabMenu = new TabMenu();console.log(\"1. \" + tabMenu.property1);console.log(\"2. \" + tabMenu.property2);console.log(\"3. \" + tabMenu.method1());console.log(\"4. \" + tabMenu.method2()); 결과 콘솔로 나온 결과 중에서 2, 4번의 출력은 저렇게 하면 안되고 다음과 같이 해야 합니다. [클래스 프로퍼티와 메서드 출력]12console.log(\"2. \" + TabMenu.property2);console.log(\"4. \" + TabMenu.method2()); 결과[클래스 프로퍼티와 메서드 의 주 용도]주로 도움을 주는 유틸리티성 기능이나 또는 실행하더라도 내부 데이터에 영향을 주지 않고 독립적으로 실행되는 기능이나 정보를 담을 때 사용 예 12345678910111213141516function TabMenu() &#123; // .. &#125;TabMenu.version = \"0.1.0\";TabMenu.getInfo = function() &#123; var info = &#123; developer: \"반찬가게알바\", email: \"고등어@등푸른생선.com\", desc: \"저희 가게의 반찬은 고등어가 제일 맛있습니다!\" &#125; return info;&#125;console.log(TabMenu.version);console.log(TabMenu.getInfo()); 클래스 프로퍼티와 메서드는 없거나 추가되더라도 기능이 동작하는데 전혀 지장을 주지 않습니다. 클래스정의 3가지 비교 함수 단위 코딩vs클래스 단위 코딩 인스턴스 프로퍼티와 메서드vs클래스 프로퍼티와 메서드 패키지","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-학습/"}],"tags":[]},{"title":"함수 단위 코딩vs클래스 단위 코딩","slug":"함수-단위-코딩vs클래스-단위-코딩","date":"2017-12-26T02:00:59.000Z","updated":"2017-12-28T04:24:44.069Z","comments":true,"path":"2017/12/26/함수-단위-코딩vs클래스-단위-코딩/","link":"","permalink":"https://recoveryman.github.io/2017/12/26/함수-단위-코딩vs클래스-단위-코딩/","excerpt":"","text":"함수단위 코딩1함수만을 이용해서 다음과 같이 독립적으로 동작하는 n개의 탭패널을 제작 가능 합니다. 소스코드 다운받기 이렇게 만든 함수는 두가지 단점이 있습니다. tabMenu() 함수를 호출할 때마다 내부에 선언된 중첩 함수가 만들어 집니다. tabMenu 함수를 호출할 때마다 내부에 들어가는 함수들이 중복해서 만들어 집니다. 외부에서 내부 속성과 함수를 접근할 수 없습니다. javascript 탭을 눌러보시면 setSelectItemAt 함수를 tabMenu 함수 외부에서 호출할 수 없습니다. 함수단위 코딩2함수만을 이용한 함수단위 코딩으로도 함수 내부의 함수를 호출하는 방법이 있습니다. 소스코드 다운받기 먼저 함수 내부의 함수를 호출하기 위해 내부 함수를 객체로 포장해 리턴해 줍니다. tabMenu 함수를 호출할 때 변수로 한번 감싸줍니다. 이렇게 감싼 변수는 tabMenu 함수 내부에 객체 리터럴 방식으로 리턴해준 함수를 사용할 수 있습니다. 아마 갑자기 객체 리터널이 나와서 이해가 안가실 수 있습니다.그래서 아래 코드를 보시고 결과를 예측하시면 좋을듯 합니다. 1234567891011121314151617181920212223242526// 1.function a() &#123; // ..&#125;console.log(\"함수 a 는 어떻게 출력될까요? \" + a);console.log(\"함수 a 를 '실행'시키면 어떻 뭐가 출력 될까요? \" + a());console.log(\"함수 a 의 타입은? \" + (typeof a));console.log(\"함수 a 가 '실행'시키면 그 타입은? \" + (typeof a()));// 2.function b() &#123; var str = \"string\"&#125;console.log(\"함수 b 는 어떻게 출력될까요? \" + b);console.log(\"함수 b 를 '실행'시키면 어떻 뭐가 출력 될까요? \" + b());console.log(\"함수 b 의 타입은? \" + (typeof b));console.log(\"함수 b 가 '실행'시키면 그 타입은? \" + (typeof b()));// 3.function c() &#123; return \"string\";&#125;console.log(\"함수 c 는 어떻게 출력될까요? \" + c);console.log(\"함수 c 를 '실행'시키면 어떻 뭐가 출력 될까요? \" + c());console.log(\"함수 c 의 타입은? \" + (typeof c));console.log(\"함수 c 가 '실행'시키면 그 타입은? \" + (typeof c())); ..........결과 함수를 호출하면 리턴해온 반환값에 의해 타입이 바뀌게 되는걸 알 수 있습니다.그래서 마지막에 객체를 반환하게 될 경우 타입이 객체로 바뀌게 됩니다. 123456789function d() &#123; return &#123; str: \"string\" &#125;&#125;console.log(\"함수 d 는 어떻게 출력될까요? \" + d);console.log(\"함수 d 를 '실행'시키면 어떻 뭐가 출력 될까요? \" + d());console.log(\"함수 d 의 타입은? \" + (typeof d));console.log(\"함수 d 가 '실행'시키면 그 타입은? \" + (typeof d())); 결과 함수안에 객체(Object)를 리턴하게 되면 객체가 되므로 객체의 프로퍼티 또는 메서드를 사용할 수 있게 됩니다. 클래스 단위 코딩 소스코드 다운받기 클래스 단위 코딩은 함수 단위 코딩에서 가지고 있는 단점들을 해소할 수 있습니다. 클래스 단위 코딩에서 보이듯 프로토 타입 방식의 경우 여러개의 인스턴스에서 메서드를 공유해서 사용합니다. 함수단위 코딩과는 다르게 함수 외부에서 함수 내부로 접근할 수 있는 형태를 가지고 있습니다. 클래스정의 3가지 비교 함수 단위 코딩vs클래스 단위 코딩 인스턴스 프로퍼티와 메서드vs클래스 프로퍼티와 메서드 패키지","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-학습/"}],"tags":[]},{"title":"this (2) - 이벤트리스너,메서드,메서드 내부의 중첩 함수에서의 this","slug":"this-2","date":"2017-12-12T23:48:57.000Z","updated":"2017-12-13T15:16:46.873Z","comments":true,"path":"2017/12/13/this-2/","link":"","permalink":"https://recoveryman.github.io/2017/12/13/this-2/","excerpt":"","text":"자바스크립트 this (2)이벤트 리스너에서의 this예제 [다음 7,8,9 결과 예상해보기]1234567891011var num = 1;$(function() &#123; $('.btn').on('click', function() &#123; this.num = 2; num = 3; console.log(num); console.log(this.num); console.log(window.num); &#125;)&#125;) 예제 다운받기..........결과제이쿼리를 사용한 예제 입니다.클래스명이 btn 인 엘리먼트를 클릭하면 안의 내용을 실행 합니다.예제의 결과를 보시면 조금 헷갈리실 수 있습니다. 4번 라인의 this.num 은 $(‘.btn’) 이라는 객체의 속성(property) 로 들어게 됩니다. 변수와는 다릅니다.※ $(‘.btn’) 은 제이쿼리에 의해 객체(object) 가 됩니다. console.log(typeof $(‘.btn’)); 을 찍어서 확인하시면 $(‘.btn’) 의 데이터 타입이 나옵니다. 5번 라인의 num 은 $(‘.btn’) 의 익명함수 내부에서 지역변수 num을 찾습니다. 익명함수 내부에서 지역변수 num이 없기에 한단계 위인 $(function(){}) 에서 지역변수 num 을 찾습니다. 거기도 없기 때문에 window 전역객체에 선언된 전역변수 num을 찾아서 3이라는 값을 할당합니다. 7번 라인의 num 은 전역에 선언된 num 을 의미합니다. 8번 라인의 this.num은 함수를 호출한 시점이 되는 $(‘.btn’) 객체의 속성(property) 인 num 을 의미합니다. 9번 라인의 window.num 은 윈도우 객체에 선언된 num을 의미합니다. 7번과 9번의 num은 동일한 객체안에 있습니다. 메서드에서의 this예제 [다음 9,10,11 결과 예측해보기]123456789101112131415var num = 1;function MyClass() &#123; this.num = 2;&#125;MyClass.prototype.method1 = function() &#123; this.num = 3; num = 4; console.log(num); console.log(this.num); console.log(window.num);&#125;var my1 = new MyClass();my1.method1(); .............결과 3번 라인의 this.num 은 아직은 어떤 객체의 num 이될지 알 수 없는 상태 입니다. MyClass 라는 함수(클래스)를 어떻게 호출하냐에 따라 달라집니다. (클래스로 사용할 함수는 앞 글자를 대문자로 표시하는 규칙이 있습니다.) 6번 라인의 this.num 은 MyClass 를 호출한 객체의 속성(property)이 됩니다. 아직은 어떤 객체의 속성이 될지 모르는 상태 입니다. 7번 라인의 num 은 자세히 보시면 method1 이라는 함수 안의 변수처럼 보입니다. 다만 앞에 예약어인 var 가 없기 때문에 지역변수 num 을 찾다가 없으니깐 window 전역객체의 변수 num에 4라는 값이 할당되게 됩니다. 9번 라인의 num 은 15번 라인에서 my1.method1(); 을 호출할 때 안의 실행절차에 따라 전역변수 num 에 4라는 값이 할당됩니다. 10번 라인의 this.num은 method1 을 호출한 객체인 my1 의 속성(property) 로써 3이라는 값이 할당받게 됩니다. 11번 라인의 window.num 은 1번 라인의 num 입니다. 7번 라인의 동작에 따라 1번 라인의 num 은 4라는 값을 할당 받았습니다. 메서드 내부의 중첩 함수에서의 this[다음 10,11,12 결과 예측해보기]123456789101112131415161718var num = 1;function MyClass() &#123; this.num = 2;&#125;MyClass.prototype.method1 = function() &#123; function inner() &#123; this.num = 3; num = 4; console.log(num); console.log(this.num); console.log(window.num); &#125; inner();&#125;var my1 = new MyClass();my1.method1(); ...........결과아마 11 번 라인의 this.num 이 왜 4가 찍히는지 조금 의아할 수 있습니다.중첩함수 내부의 this 는 window 객체를 의미합니다. 메서드 안의 중첩함수도 예외는 아닙니다.앞선 포스팅에서 중첩함수 내부의 this 에 대해서 포스팅 한 적이 있습니다. 10번 라인의 num 은 inner 함수 내부에서 지역변수 num을 찾습니다. 근데 지역변수 num이 없으니 한단계 위인 MyClass 함수에서의 지역변수 num을 찾습니다. 그래도 없으니까 window 객체의 num 을 찾아 4 라는 값을 할당해주게 됩니다. 11번 라인의 this.num 은 중첩함수 inner 안에 있습니다. 중첩함수 내부의 this 는 window 객체 입니다. 따라서 7번 라인에 의해 전역변수 num 에 3 이라는 값을 대입했지만. 8번라인의 코드에 의해 num 이 4라는 값을 가지게 되므로 4를 출력합니다. 12번 라인은 전역변수 num을 의미합니다. 1번라인을 바라보고 있습니다. 8번 라인에 의해 4라는 값을 할당받게 되어서 4가 찍힙니다. this (1) - 일반함수,일반중첩함수 의 this this (2) - 이벤트리스너,메서드,메서드 내부의 중첩 함수에서의 this","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-학습/"}],"tags":[]},{"title":"this (1) - 일반함수,일반중첩함수 의 this","slug":"this-1","date":"2017-12-12T12:54:23.000Z","updated":"2017-12-13T15:18:28.102Z","comments":true,"path":"2017/12/12/this-1/","link":"","permalink":"https://recoveryman.github.io/2017/12/12/this-1/","excerpt":"","text":"자바스크립트 this (1)this는 일반적으로 메서드를 호출한 객체가 저장되어 있는 속성 콘솔 찍어보기 전까지 예상하기 어려운 녀석이네요.코딩을 하면서 조금씩 움찔움찔 합니다. 어… 이게 이걸 가르키나 하구요. 일반 함수에서의 this1234567891011var data = 10;function outer() &#123; this.data = 20; data = 30; console.log(\"1. data = \" + data); // 30 console.log(\"2. this.data = \" + this.data); // 30 console.log(\"3. window.data = \" + window.data); // 30&#125;outer(); outer 라는 함수를 호출하기 전에 this가 무엇인지 생각해 봅시다......예상하신게 이 다음 적을 결과와 같다면 아마 this를 이미 잘 아시는 분이실꺼 같습니다.저는 자바스크립트 에서의 this 는 많이 공부해야 하지만 얕게 알고있는 내용이라도 몇자 남겨 보겠습니다.자바스크립트의 this만 하더라도 책한권의 분량이 나온다고 하니 많이 공부가 필요할듯싶습니다.이 글에서 전달하고자 하는 부분이 잘못되어 있으면 지적 부탁드립니다.후에 명확한 내용을 전달할 수 있을때 다시 포스팅 하겠습니다....결과 일반 함수에서의 this 는 window 객체를 가르키고 있습니다. 3번 라인의 this.data = 20; 은 전역변수 data 에 20을 할당해 줍니다. 4번 라인의 data = 30; 은 지역변수 num을 일단 찾고 없으면 전역으로 올라가 전역변수 data 를 찾습니다. 그리고 그 전역변수 data 에 30을 다시 할당합니다. 그래서 모두 같은 30 이라는 값이 출력이 되고 있네요. 여기서 알 수 있는 사실은this는 무조건 ‘객체’ 입니다. 그리고 좀 더 명확하게 알기 위해서는 ‘함수를 호출한 시점’을 알아야 합니다.간단한 코드로 예를 보여드리겠습니다. 12345function a() &#123; console.log(this);&#125;a(); 이 코드를 콘솔로 찍어보면 window 객체가 찍힙니다. 이 윈도우 객체를 펼쳐보면 a 라는 함수가 보입니다. 이렇다는 건 다음의 코드로도 a함수를 호출할 수 있습니다.같은 결과가 나오고 있네요.두번째로 알 수 있는건 이렇게 호출한 시점의 ‘객체’ 가 this 가 됩니다. 그럼 예제의 3번 코드와 4번 코드 사이에지역변수 data 을 넣어보겠습니다. 예제2 123456789101112var data = 10;function outer() &#123; this.data = 20; var data = 50; data = 100; console.log(\"1. data = \" + data); // 100 console.log(\"2. this.data = \" + this.data); // 20 console.log(\"3. window.data = \" + window.data); // 20&#125;outer(); 3번 코드에 의해 전역변수 data 에 20 이 할당 4번 코드 에 의해 outer 함수 안에 지역변수 data 에 50 이라는 값을 가짐 5번 코드에 의해 outer 함수 안의 지역변수 data 에 100 이라는 값이 담김 7번 에서의 data 는 함수 내부의 지역변수를 data을 찾음 // 100 8번 에서의 this.data 은 a라는 함수를 호출한 window 객체의 data(전역변수) 을 찾음 // 20 9번 에서의 window.data 은 전역변수 data 을 가르킴. // 20 결과 일반 중첩 함수에서의 this[다음 7,8,9번 코드의 출력값 예상하기]123456789101112var data = 10;function outer() &#123; function inner() &#123; this.data = 20; data = 30; console.log(\"1. data = \" + data); console.log(\"2. this.data = \" + this.data); console.log(\"3. window.data = \" + window.data); &#125; inner();&#125; 이 예제도 this 가 무엇을 가르키는지 맞추셨다면 this 를 이미 잘 아시는 분이실듯 합니다. ...자바스크립트를 이제 막 접하신 분들이라면 위의 예제를 해보고 난 뒤 inner 함수가 호출되는 시점을 찾았을 것이라 생각됩니다.inner 함수는 outer 함수 안에서 실행이 되니깐 아마 예상하기론 outer 함수가 찍혀있지 않을까 예상실꺼 같다고 생각이 듭니다...............일단 inner 함수를 호출해 보기 위해 첫번째 시도를 하겠습니다.이 사진에서 보시다시피 inner 함수는 outer 라는 함수 내부에 있기 때문에 그냥 inner 함수를 호출 못시킴니다. 따라서 outer라는 함수를 호출해야지 outer 함수 내부의 동작을 수행하면서 inner 함수가 호출이 됩니다.그런데 잘 보시면 outer 함수가 콘솔로 찍혀 있을 줄 알았지만 예상과는 다르게 콘솔로 찍은 문제의 답이 찍혀져 있었네요. 4번 라인의 this.data 는 inner 함수 내부에 있습니다. inner 함수는 outer 함수 내부에 있는 함수 입니다. 일반 중첩 함수에서 this는 ‘window’ 가 됩니다. 5번 라인은 data 는 지역변수 data 를 먼저 찾고 없으면 전역으로 올라갑니다. 전역에 선언되어 있는 data 변수에 30 이라는 값을 할당 합니다. 7번 라인은 지역변수 data 를 찾고 없으니까 전역으로 올라가서 data 를 찾습니다. data 는 30이라는 값이 할당되어 있습니다. 8번 라인은 함수를 호출한 시점이 되는 객체의 data 변수를 의미합니다. data 변수는 window 객체에서의 변수로 정의되어 있습니다. 9번 라인은 윈도우 전역객체의 data 변수를 의미합니다. this (1) - 일반함수,일반중첩함수 의 this this (2) - 이벤트리스너,메서드,메서드 내부의 중첩 함수에서의 this","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-학습/"}],"tags":[]},{"title":"클래스정의 3가지 비교","slug":"클래스정의-3가지-비교","date":"2017-12-10T13:14:43.000Z","updated":"2017-12-28T04:24:42.328Z","comments":true,"path":"2017/12/10/클래스정의-3가지-비교/","link":"","permalink":"https://recoveryman.github.io/2017/12/10/클래스정의-3가지-비교/","excerpt":"","text":"특징 방식 특징 프로토타입방식 일반적인 클래스 제작 방법인스턴스마다 공통된 메서드를 공유해서 사용하는 장점이 있음jQuery도 prototype방식으로 만들어져 있음 함수 방식 간단한 클래스 제작 시 사용인스탄스마다 메서드가 독립적으로 만들어지는 단점이 있음 리터럴 방식 클래스 만드는 용도는 아니며 주로 여러개의 매개변수를 그룹으로 묶어 함수의 매개변수로 보낼 때 사용정의와 함께 인스턴스가 만들어지는 장점이 있음. 단! 인스턴스는 오직 하나만 만들 수 있음 클래스 정의 방법(포장) 비교리터럴방식 123456789var 인스턴스 = &#123; 프로퍼티1: 초깃값, 프로퍼티2: 초깃값, 메서드1: function() &#123; &#125;, 메서드2: function() &#123; &#125;&#125; 함수방식 123456789function 클래스이름() &#123; this.프로퍼티1 = 초깃값; this.프로퍼티2 = 초깃값; this.메서드1 = function() &#123; &#125; this.메서드2 = function() &#123; &#125;&#125; 프로토타입 방식 123456789function 클래스이름()&#123; this.프로퍼티1 = 초깃값; this.프로퍼티2 = 초깃값;&#125;클래스이름.prototype.메서드1 = function() &#123;&#125;클래스이름.prototype.메서드2 = function() &#123;&#125; 인스턴스 생성 방법 리터럴 방식 함수 방식 프로토타입 방식 var 인스턴스 = {}; var 인스턴스 = new 클래스이름(); var 인스턴스 = new 클래스이름(); 객체 외부에서 프로퍼티와 메서드 접근 방법리터럴 방식 123456789101112var 인스턴스 = &#123; 프로퍼티1: 초깃갑, 프로퍼티2: 초깃갑, 메서드1: function() &#123; &#125; 메서드2: function() &#123; &#125;&#125;인스턴스.프로퍼티1;인스턴스.메서드1(); 함수방식 123456789101112function 클래스이름() &#123; this.프로퍼티1 = 초깃값; this.프로퍼티2 = 초깃값; this.메서드1 = function() &#123; &#125; this.메서드2 = function() &#123; &#125;&#125;인스턴스.프로퍼티1;인스턴스.메서드1(); 프로토타입 방식 123456789101112function 클래스이름()&#123; this.프로퍼티1 = 초깃값; this.프로퍼티2 = 초깃값;&#125;클래스이름.prototype.메서드1 = function() &#123;&#125;클래스이름.prototype.메서드2 = function() &#123;&#125;인스턴스.프로퍼티1;인스턴스.메서드1(); 객체 내부에서 프로퍼티와 메서드 접근 방법리터럴 방식 1234567891011var 인스턴스 = &#123; 프로퍼티1: 초깃갑, 프로퍼티2: 초깃갑, 메서드1: function() &#123; alert(this.프로퍼티1); this.메서드2(); &#125; 메서드2: function() &#123; &#125;&#125; 함수방식 1234567891011function 클래스이름() &#123; this.프로퍼티1 = 초깃값; this.프로퍼티2 = 초깃값; this.메서드1 = function() &#123; alert(this.프로퍼티1); this.메서드2(); &#125; this.메서드2 = function() &#123; &#125;&#125; 프로토타입 방식 1234567891011function 클래스이름()&#123; this.프로퍼티1 = 초깃값; this.프로퍼티2 = 초깃값;&#125;클래스이름.prototype.메서드1 = function() &#123; alert(this.프로퍼티1); this.메서드2();&#125;클래스이름.prototype.메서드2 = function() &#123;&#125; 클래스정의 3가지 비교 함수 단위 코딩vs클래스 단위 코딩 인스턴스 프로퍼티와 메서드vs클래스 프로퍼티와 메서드 패키지","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-학습/"}],"tags":[]},{"title":"jQuery 마우스휠2","slug":"jQuery-마우스휠2","date":"2017-12-07T04:18:57.000Z","updated":"2017-12-07T04:51:30.312Z","comments":true,"path":"2017/12/07/jQuery-마우스휠2/","link":"","permalink":"https://recoveryman.github.io/2017/12/07/jQuery-마우스휠2/","excerpt":"","text":"앞에서 했던 이론이 이해가 되셨다면이제 UI를 만드는건 아주 쉽겟죠? 음수값(마우스를 내릴때)과 양수값(마우스를 올릴때)을 조건식으로 걸어주면 브라우저 이벤트객체 이슈를 고려한 UI 를 만들 수 있겠죠! 더해서 jQuery 플러그 인 중에 Scroll Lock 를 적절하게 응용한다면재밌는 UI를 만드리라 생각합니다! Scroll Lockdemo자 일단 이전글에 있던 마크업을 미리 복사해 줍니다. ㅋㅋ;; 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt;&lt;/style&gt; &lt;script src=\"http://code.jquery.com/jquery-1.11.3.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; $(\"html, body\").on('mousewheel DOMMouseScroll', function(e) &#123; var E = e.originalEvent; delta = 0; if (E.detail) &#123; delta = E.detail * -40; &#125;else&#123; delta = E.wheelDelta; &#125;; &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 이제 body 안에간단하게 ul, li 태그를 사용하여 몇가지 작성해 보도록 합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123;margin: 0;padding: 0;list-style-type: none;&#125; .clearfix&#123;*zoom: 1;&#125; .clearfix:after&#123;content: '';display: block;clear: both;&#125; div&#123;position: relative;width: 1000px;height: 200px;margin: 0 auto;overflow: hidden;&#125; ul&#123;position: absolute;left: 0;top: 0;width: 3000px;&#125; ul li&#123;width: 1000px;height: 200px;float: left;&#125; .box1&#123;background-color: #b3c4f8;&#125; .box2&#123;background-color: #f8bfb4;&#125; .box3&#123;background-color: #b4f8b6;&#125; &lt;/style&gt; &lt;script src=\"http://code.jquery.com/jquery-1.11.3.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; $(\"html, body\").on('mousewheel DOMMouseScroll', function(e) &#123; var E = e.originalEvent; delta = 0; if (E.detail) &#123; delta = E.detail * -40; &#125;else&#123; delta = E.wheelDelta; &#125;; &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;ul class=\"clearfix\"&gt; &lt;li class=\"box1\"&gt;&lt;/li&gt; &lt;li class=\"box2\"&gt;&lt;/li&gt; &lt;li class=\"box3\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 이런식으로??div 의 크기는 현재 보여줄 li 의 크기만큼ul 의 크기는 li 의 갯수 곱하기 li의 width 값 만큼.( 이 부분은 스크립트로 처리하는게 범용성이 뛰어나겠죠? ) 자.. 스크립트를 작성해 봅니다. 스크립트는 자꾸자꾸 스스로 시도해 보면서 시행착오를 겪어봅시다.시행 착오를 직접 겪는것과 안겪는것은 큰 차이가 있습니다!정말로요..이 예제는 별거 아니지만…ㅠㅠ;; 저는 헤맸어요..;;.................................. iframe 에 스크롤 이 생겨서 휠 이벤트 를 보여주기 힘드네요 ㅎㅎ; 소스코드 다운받기 이걸 참고 하셔서 UI 를 만들어 보셔요 위의것과 동일합니다. jQuery 마우스휠1 jQuery 마우스휠2","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"마크업부터 시작하는 UI","slug":"JS/마크업부터-시작하는-UI","permalink":"https://recoveryman.github.io/categories/JS/마크업부터-시작하는-UI/"}],"tags":[]},{"title":"jQuery 마우스휠1","slug":"jQuery-마우스휠1","date":"2017-12-07T00:26:43.000Z","updated":"2017-12-07T04:50:19.601Z","comments":true,"path":"2017/12/07/jQuery-마우스휠1/","link":"","permalink":"https://recoveryman.github.io/2017/12/07/jQuery-마우스휠1/","excerpt":"","text":"마우스 휠을 이용하여 이벤트를 만들어 봅시다.이 장에서는 마우스 휠에 대한 이론을 살펴 보도록 합시다. 예제용 UI를 찾아보려고 했는데 도통 간단한게 없어서 일단 예를 보여드리도록 하겠습니다. 마우스 휠을 아랫방향으로 했을 때에는 -120마우스 휠을 윗 방향으로 했을 때에는 120 이라는 숫자가 뜨죠? 이해를 돕기 위해 js 피들의 javascript 탭에 주석으로 달아 놓긴 했지만다시한번 글을 적어보도록 하겠습니다. 일단 제가 설치한 브라우저는크롬(Chrome), 익스(IE), 파이어폭스(Firefox) 기준으로 말씀드리겠습니다. 다른 브라우저는 테스트 해보진 않았지만 아마도(죄송합니다.. ㅠㅠ)익스, 크롬, 사파리, 오페라 의 경우엔mousewheel 이라는 이벤트를 사용할 수 있고 파이어폭스 의 경우엔DOMMouseScroll 이라는 이벤트를 사용할 수 있습니다. 즉… 파이어 폭스는 mousewheel 이라는 이벤트가 없기 때문에mousewheel 과 DOMMouseScroll 이벤트 두개를 동시에 걸어주는 메서드인 .on() 를 사용해야 합니다. Example123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt;&lt;/style&gt; &lt;script src=\"http://code.jquery.com/jquery-1.11.3.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; $(\"html, body\").on('mousewheel DOMMouseScroll', function(e) &#123; var E = e.originalEvent; delta = 0; console.log(E); if (E.detail) &#123; delta = E.detail * -40; $('body').text(delta); &#125;else&#123; delta = E.wheelDelta; $('body').text(delta); &#125;; &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 일단 저의 마크업은 이렇습니다.이 마크업을 보시면 13번 라인에 콘솔창으로 E 를 찍어보게 됩니다.크롬에서 E 에 담긴걸 찍어보도록 하겠습니다.여기서 function()의 괄호 안에 있는 e 는 mousewheel 입니다! WheelEvent {}이라는 게 뜨죠? 정확히 13번 라인입니다.이걸 펼쳐보면… wheelDelta 라는 속성이 있습니다. 저 값이마우스 휠을 ‘내리게’ 되면 -120 을 출력하고마우스 휠을 ‘올리게’ 되면 120 을 출력합니다. 익스도 마찬가지로 크롬과 동일하게e.originalEvent 의 속성으로 wheelDelta 속성을 사용합니다. 하지만 파이어폭스는e.originalEvent &lt;- 여기서의 e 는 DOMMouseScroll 이벤트 입니다. 파이어폭스 에서도 똑같이 위와같은 마크업의 13번째 라인이 콘솔창에 출력 되었습니다.저 DOMMouseScroll 을 클릭해 보면 detail 이라는 속성이 들어있습니다.저 detail 속성은 파이어폭스에서만 사용할수 있는e.originalEvent 의 속성 입니다. 하지만…크롬도 익스도 120을 출력하는데얘만 3 출력하게 놔둔다면조건문을 이용한 UI를 만들때 불편하겠죠??? 그래서 -40을 곱하기 해주는 겁니다.파이어 폭스는 마우스를 휠을 올릴경우 음수값을마우스 휠을 내릴경우 양수값을 출력합니다. jQuery 마우스휠1 jQuery 마우스휠2","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"마크업부터 시작하는 UI","slug":"JS/마크업부터-시작하는-UI","permalink":"https://recoveryman.github.io/categories/JS/마크업부터-시작하는-UI/"}],"tags":[]}]}
{"meta":{"title":"회복맨","subtitle":"Wellcome ..!","description":"회복맨 입니다.","author":"회복맨","url":"https://recoveryman.github.io"},"pages":[{"title":"About","date":"2017-12-03T16:14:50.000Z","updated":"2020-12-09T21:10:11.516Z","comments":true,"path":"about/index.html","permalink":"https://recoveryman.github.io/about/index.html","excerpt":"","text":"환영합니다.안녕하세요. UI개발자 회복맨 입니다.이곳에 방문해 주신분들과 유익한 소통을 하고싶어서 개설하게 되었습니다.부족한게 많은 글들이지만 점점 나아지는 모습을 기록하려합니다. 지금 적극적으로 실행되는 괜찮은 계획이 다음 주의 완벽한 계획보다 낫다. George S. Patton Skills HTML5 CSS &amp; SASS javascript jQuery Git &amp; SVN Webpack, Gulp, Grunt"},{"title":"Portfolio","date":"2017-12-03T16:26:51.000Z","updated":"2020-12-09T21:04:46.157Z","comments":true,"path":"portfolio/index.html","permalink":"https://recoveryman.github.io/portfolio/index.html","excerpt":"","text":"스마일게이트RPG2019~2020 한빛소프트2017~2018 (계약직)게임 티저 2차 - 10월게임 티저 1차 - 5월"}],"posts":[{"title":"[성능] 쓰로틀링과 디바운싱","slug":"성능-쓰로틀링과-디바운싱","date":"2018-08-20T07:34:07.000Z","updated":"2018-08-21T00:27:59.860Z","comments":true,"path":"2018/08/20/성능-쓰로틀링과-디바운싱/","link":"","permalink":"https://recoveryman.github.io/2018/08/20/%EC%84%B1%EB%8A%A5-%EC%93%B0%EB%A1%9C%ED%8B%80%EB%A7%81%EA%B3%BC-%EB%94%94%EB%B0%94%EC%9A%B4%EC%8B%B1/","excerpt":"","text":"먼저 이 글은 제로초 님의 블로그를 참고해서 작성했습니다. 간혹 면접에서 자바스크립트 성능을 위해 어떤것들을 해보았냐는 질문들을 받았던 적이 있습니다.이 질문이 꼭 웹UI콘텐츠(예: 슬라이더, 애니메이션… 등) 뿐만 아니라 좀 더 넓은 의미로 물어보았을 거라 생각 됩니다.저는 일단 웹UI콘텐츠를 제작하는 입장으로 쓰로틀링과 디바운싱에 대해 제로초님 블로그를 참고하여 글을 작성하겠습니다. 쓰로틀링(throttling): 마지막 함수가 호출된 후 일정 시간이 지나기 전에 다시 호출되지 않도록 하는것 디바운싱(debouncing): 연이어 호출되는 함수들 중 마지막 함수(또는 제일 처음)만 호출하도록 하는 것 디바운싱주로 ajax검색에 자주 사용.(예: 검색어 치자마자 엔터 없이도 결과를 즉시 보여줌. - 항상 input이벤트에 대기) 예제)실제 아작스 요청을 보내기 어려우니 콘솔로그로 대체.로그가 콘솔에 찍힐 때마다 ajax 요청이 실행된다고 예를 듬. 1&lt;input id=\"input\"&gt; 123document.querySelector('#input').addEventListener('input', function(e) &#123; console.log('여기에 ajax 요청', e.target.value);&#125;); 소스코드 다운받기 실행시 문제점) 한 글자 칠 때마자 ajax 요청이 실행. ‘ㅇ’, ‘아’, ‘안’, ‘안ㄴ’, ‘안녀’, ‘안녕’ 모두 요청이 실행됨. 한글같은 조합형 언어는 더 많은 이벤트가 발생할 수 있음. ‘ㅇ’ 또는 ‘롳’ 같은건 제대로 된 검색 결과가 나오지 않을것 같은 검색어. 이런 낭비는 유료 API 사용 시 큰 문제가 됨. (디바운싱은 비용적인 문제와도 관련이 있음.) 원하는것)마지막 키워드를(예: 안녕하세요) 다 쳤을 때 ajax 요청을 보내고자 하는 것. 구현방법)보통 사람들은 타자를 연달아 침. 따라서 입력이 다 끝난 후에 요청을 보내면 됨. 타자를 칠 때(input 이벤트 발생) 마다 타이머를 설정. 200ms동안 입력이 없으면 입력이 끝난 것으로 침. (시작은 적당히 설정) 200ms이전에 타자 입력이 발생하면 이전 타이머는 취소하고 새로운 타이머를 다시 설정. 123456789var timer;document.querySelector('#input').addEventListener('input', function(e) &#123; if(timer) &#123; clearTimeout(timer); &#125; timer = setTimeout(function() &#123; console.log('여기에 ajax 요청', e.target.value); &#125;, 200);&#125;); 소스코드 다운받기 ※ 한글 특성상 마지막에 두번 호출되는 경우도 있음. 쓰로틀링쓰로틀링은 보통 성능 문제 때문에 많이 사용. 특성 자체가 실행 횟수에 제한을 거는 것이기도 함. 문제점 스크롤을 올리거나 내릴 때 scroll이벤트가 매무 많이 발생. scroll이벤트가 발생할 때 뭔가 복잡한 작업을 하도록 설정했다면 매우 빈번하게 실행되기 때문에 렉이 걸림. [쓰로틀링 사용 전]1234567$(function() &#123; var $winHeight = 0; $(window).scroll(function() &#123; console.log($(this).scrollTop()); &#125;)&#125;) 소스코드 다운받기 해결법몇 초에 한 번,몇 밀리초에 한 번씩만 실행되게 제한을 둠. [쓰로틀링 사용 후 - underscore js 사용]123456var throttled = _.throttle(updatePosition, 200);function updatePosition() &#123; console.log($(window).scrollTop());&#125;$(window).scroll(throttled); 소스코드 다운받기 ※ underscore js 를 사용 한 이유 - 예외사항 처리 때문","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"마크업부터 시작하는 UI","slug":"JS/마크업부터-시작하는-UI","permalink":"https://recoveryman.github.io/categories/JS/%EB%A7%88%ED%81%AC%EC%97%85%EB%B6%80%ED%84%B0-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-UI/"}],"tags":[]},{"title":"클래스 상속 VS 합성","slug":"클래스-상속-VS-합성","date":"2018-03-30T00:50:49.000Z","updated":"2018-04-18T07:40:58.477Z","comments":true,"path":"2018/03/30/클래스-상속-VS-합성/","link":"","permalink":"https://recoveryman.github.io/2018/03/30/%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%83%81%EC%86%8D-VS-%ED%95%A9%EC%84%B1/","excerpt":"","text":"기능을 재사용 하는 면에서 생각해보면 클래스 상속과 합성은 많이 비슷해 보이지만 이 둘은 완전히 다른 기능입니다. 이번에는 앞에서 배운 클래스 상속과 합성에 대해 정리해보는 시간을 가져보겠습니다. 먼저 클래스 상속과 합성의 공통점부터 알아보죠. 공통점상속과 합성의 공통점은 특정 기능을 직접 구현하지 않고 사용할 수 있다는 점입니다. 예를 들어 DMB기능이 있는 기기를 만든다고 해보죠. 상속을 이용하는 경우상속을 이용하면 DMB기능을 쉽게 재사용할 수 있게 됩니다. 메모이번 예제는 언뜻 보면 상속을 제대로 사용한 것처럼 보이지만 상속을 잘못 사용한 경우입니다. 이유는 사용 용도에서 자세히 설명하겠습니다. 합성을 이용하는 경우합성 역시 다음과 같이 DMB 기능을 재사용할 수 있습니다. 사용 용도앞의 공통점에서 알아본 것처럼 클래스 상속과 합성을 이용하면 기능을 쉽게 재사용할 수 있습니다. 하지만 코드 재사용을 위해 무조건 이 둘을 사용해서는 안됩니다. 상황에 맞게 선택해서 사용해야 합니다. 먼저 클래스 상속의 사용 용도에 대해 알아보죠. 클래스 상속은 이럴 때 사용해요앞의 DMB 예제에서 상속을 사용했는데요. 아쉽게도 상속을 잘못 사용한 경우입니다. 왜냐면 스마트폰은 DMB 기능이 없는 스마트폰도 있기 때문에 “스마트폰은 DMB이다.” 라는 패밀리 관계가 성립되지 않습니다. 이처럼 특정 기능이 필요하다고 해서 무조건 클래스 상속을 사용해서는 안 되며 반드시 다음과 같은 경우일 때만 사용해야 합니다. 기능이 필요하다고 해서 무조건 상속을 사용하면 안 됩니다. 반드시 IS-A 관계인 패밀리 관계가 성립되어야 합니다. 상속은 기능을 재사용하기보다 부모 기능을 확장하기 위해 주로 사용합니다. 다음은 클래스 상속을 잘 활용한 예제입니다. 예제를 보면 패밀리 관계를 유지하면서 기능을 계속해서 확장해 가는 걸 확인할 수 있습니다. 바로 이럴 때 사용하는 기능이 클래스 상속 입니다. 합성은 이럴 때 사용해요앞의 DMB 예제의 경우 합성을 제대로 활용한 경우입니다. 왜냐면 DMB 모듈을 사용하는 기기들은 서로 패밀리 관계가 아닐 뿐더러 오직 DMB 기능만이 필요한 기기들이기 때문에 이런 경우 합성을 이용해야 합니다. 이처럼 합성은 다음과 같은 경우에 사용하면 됩니다. 패밀리 관계는 무시해도 됩니다. 합성은 이미 구현되어 있는 기능을 빌려 쓰듯 재사용하고 싶을 때 주로 사용합니다. 실무에서는 상속보다는 합성을 많이 사용합니다.그럼 실무에서는 상속과 합성 중 어떤 기능을 더 많이 사용할까요? 물론 상황에 따라 다르겠지만 상속보다는 합성을 더 많이 사용합니다. 이유는 지금까지 알아본 것처럼 합성은 상속이 흉내 내고 싶어도 흉내낼 수 없는 놀라운 기능 한 가지를 가지고 있기 때문입니다. 바로 합성은 실행 시점에 동작을 변경할 수 있는 동적 바인딩(dynamic binding) 기능을 가지고 있습니다. 동적 바인딩에 대한 이해를 돕기 위해 예를 들어 설명해 보겠습니다. 예제는 다형성 편 마지막에 풀어본 예제를 사용하겠습니다. 다음 실행화면을 우성 봐주세요. 생각 나시죠? 먼저 SimpleGallery 내부는 정렬기능이 전혀 구현되어 있지 않습니다. 이때 가로 정렬 버튼을 클릭하는 경우 가로 정렬 기능을 가진 객체가 SimpleGallery에 합성되어 비로소 사용됩니다. 다른 기능 역시 버튼을 누를 때 SimpleGallery에 합성되어 사용됩니다. 바로 이처럼 특정 기능을 직접 가지고 있는 게 아니라 실행한 후 기능을 갖게 되는 경우를 우리는 동적 바인딩이라고 부릅니다. 정리지금까지 다룬 상속과 합성의 특징을 정리하면 다음과 같습니다. 클래스 상속 객체 합성 반드시 패밀리 관계일 때만 사용해야 함재사용의 목적보다 객체를 확장하고 싶은 경우에 적합기능을 클래스 내부에 직접 구현 패밀리 관계와는 상관없이 특정 객체가 가진 기능을 재사용하고 싶은 경우동적 바인딩 기능 구현을 위해 사용.기능을 직접 구현하는 게 아니라 외부에 구현되어 있는 객체를 연결해서 사용 롤링 배너 ver 1.0: 클래스 단위 코딩이번 미션에서는 가장 단순한 형태인 클래스를 활용해 롤링 배너를 만들겠습니다. 롤링 배너를 만들면서 다시 한 번 클래스의 용도와 기능을 정리하게 됩니다. 소개 및 미리보기이번에 새롭게 만들 UI 요소는 롤링배너입니다. 주로 웹 페이지 사이드 부분에 위치하며 특정 시간마다 광고용 이미지를 보여주는 기능을 가지고 있습니다. 먼저 우리가 구현할 롤링배너가 어떻게 동작하는지 살펴보기 위해 아래의 모든 기능이 구현되어 있는 최종 결과물을 확인해 주세요 소스코드 다운받기 실행해보면 알겠지만 2초마다 아래에서 위로 이미지가 부드럽게 롤링되는 것을 볼 수 있습니다. 마우스를 롤링배너 위에 올리거나 다시 나가더라도 롤링 효과가 멈추거나 하는 기능은 없습니다. 요구사항지금부터 다음과 같이 동작하는 롤링배너를 만들어야 합니다. 특정 시간마다 아래에서 위로 이미지가 부드럽게 롤딩되며 변하게 만들어 주세요. 모든 작업은 prototype 방식으로 클래스로 만들어 주세요. 요구사항은 비교적 간단하죠? 다음으로 이번 미션의 핵심 내용 중 하나인 롤링 효과를 좀더 자세히 살펴보겠습니다. 출력 효과출력 효과를 좀더 자세히 살펴보면 현재 배너는 페이드아웃(fadeOut) 효과와 함께 현재 위치에서 위쪽으로 서서히 사라집니다. 다음 배너는 페이드인(fadeIn) 효과와 함께 아래쪽에서 0위치로 서서히 등장합니다. 모든 배너는 이 롤링 효과를 적용해 출력해야 합니다. 레이아웃 구성화면 레이아웃은 미리 다음과 같이 만들어 놨습니다. 자! 이렇게 해서 구현해야 할 롤링배너에 대해 자세히 알아봤습니다. 이제부터 할일은 자바스크립트와 jQuery를 활용해 요구사항에 맞게 롤링 배너를 만들면 됩니다. 만약 구현하기 어려운 분들은 지금부터 같이 풀이를 진행하면 됩니다. 그럼 구현을 시작해 보죠! 용어정리우선 원활한 진행을 위해 화면 요소에 이름을 붙여 내용을 설명할 때 사용하겠습니다. 출력 화면 영역: 배너가 출력되는 영역입니다. 현재 배너: 현재 활성화돼 있는 배너입니다. 다음 배너: 다음으로 출력 영역이 나타날 배너입니다. 구현하기이해를 돕기 휘해 구현은 다음과 같이 4단계로 나눠 진행하겠습니다. 클래스 생성 및 초기화 작업 첫 번째 배너 활성화 모션 없는 롤링 배너 구현 롤링 효과 적용 그럼 첫 번째 단계부터 진행해 보죠. 1. 클래스 생성 및 초기화 작업이번 단계에서는 롤링배너 기능을 구현할 클래스를 생성하는 작업과 롤링배너에서 사용하는 기본 요소를 초기화하는 작업을 진행합니다. 먼저 소스코드에 들어있는 파일을 연 후 소스 설명 순서를 따라 다음 내용을 하나씩 입력해 주세요. 12345678910111213141516$(function() &#123; // 인스턴스 생성 var rolling1 = new RollingBanner();&#125;)function RollingBanner() &#123; // 프로퍼티 생성 및 초기화 this._$banners = null; this._init();&#125;// 요소 초기화RollingBanner.prototype._init = function() &#123; this._$banners = $(\".banner1 li\");&#125; 설명 6번 라인: 가장 먼저 메서드와 프로퍼티를 담을 클래스를 만듭니다. 여기에서는 RollingBanner라는 이름으로 클래스를 만들어 줍니다. 8번 라인: 배너 목록을 담을 _$banners라는 프로퍼티를 만들어 줍니다. 객체 내부에서만 사용할 프로퍼티이기 때문에 private이라는 의미로 언더바(_)를 붙여 줍니다. 14번 라인: 롤링배너 내부에서 공용으로 사용할 요소들의 초기화를 전문으로 하는 _init() 메서드를 만든 후 배터를 찾아 _$banners에 넣어줍니다. _init() 메서드 역시 객체 내부에서만 사용할 메서드이기 때문에 private 메서드라는 의미로 언더바(_)를 붙여줍니다. 참고로 앞으로 등장하는 코드에서 언더바(_)가 붙은 경우는 객체 외부에서 접근이 불가능한 private 또는 protected 요소라고 생각하면 됩니다. 이와 달리 언더바가 붙어있지 않은 경우 객체 외부에서나 내부에서 모두 접근 가능한 public 요소라고 판단하면 됩니다. 언더바를 붙이는 표현법은 [객체지향 프로그래밍 특징] 캡슐화 소개, [객체지향 프로그래밍 특징] 자바스크립트에서의 캡슐화 의 내용을 참고하세요. 10번 라인: 롤링배너 객체가 생성될 때 _init() 메서드를 호출해 줍니다. 3번 라인: 클래스가 정상적으로 동작하는지 확인하기 위해 RollingBanner 클래스의 인스턴스를 생성해 줍니다. 소스코드 다운받기 2. 첫 번째 배너 활성화이번 단계에서 구현할 내용은 시작 시 첫 번째 배너만을 활성화(보이게)하고 나머지 배너들은 비활성화(보이지 않게) 하는 작업입니다. [javascript]123456789101112131415161718192021222324252627$(function() &#123; // 인스턴스 생성 var rolling1 = new RollingBanner();&#125;)function RollingBanner() &#123; // 프로퍼티 생성 및 초기화 this._$banners = null; this._currentIndex = 0; this._init(); this._initBannerPos();&#125;// 요소 초기화RollingBanner.prototype._init = function() &#123; this._$banners = $(\".banner1 li\");&#125;// 배너 위치 초기화RollingBanner.prototype._initBannerPos = function() &#123; // 배너 위치를 화면에서 보이지 않게 숨기기 this._$banners.css(\"top\", 200); // 0번째 배너 활성화 this._$banners.eq(this._currentIndex).css(\"top\", 0);&#125; [css]123456789101112131415.rolling_banner&#123; /* 테스트를 위해 주석 처리 overflow:hidden; */ position:absolute;top:50%;left:50%; margin:-100px 0 0 -200px; width:400px;height:200px; border:1px solid #000&#125;.rolling_banner li&#123; float:left; position:absolute;top:0;left:0; width:400px;height:200px; line-height:200px;text-align:center; /* 테스트를 위해 속성 추가 */ opacity:0.2&#125; 설명 javascript - 9번 라인: 활성화된 배너의 인덱스 정보를 담을 _currentIndex 라는 프로퍼티를 만들어 줍니다. javascript - 21번 라인: _initBannerPos() 라는 메서드를 신규로 만든 후 0번째 이미지를 활성화하고 나머지는 비활성화 처리하는 코드를 구현해 줍니다. javascript - 12번 라인: _initBannerPos() 메서드를 생성자에서 호출해 줍니다. css - 2번 라인: 테스트를 위해 마스크 기능을 하는 overflow 속성을 주석처리해 줍니다. css - 14번 라인: 이미지 투명값도 테스트를 위해 0.2로 넣어줍니다. css의 2, 14번 라인의 스타일 속성값은 구현 마지막 단계에서 주석 처리를 지워주고 투명 값은 삭제할 것입니다. 코드를 모두 입력했다면 실행해보겠습니다. 정상적으로 코드를 입력했다면 실행화면 처럼 0번째 배너가 활성화 된 것을 볼 수 있을 것입니다.소스코드 다운받기 3. 모션 없는 롤링배너 구현롤링배너의 핵심은 무한 루프를 돌며 특정 시간마다 배너를 순차적으로 변경해주는 로직입니다. 예를 들어 배너가 5개인 경우 다음과 같이 현재 배너 인덱스 값과 다음 배너 인덱스 값을 만들어 낼 줄 알아야 합니다. 현재 배너 인덱스 다음 배너 인덱스 0 1 1 2 2 3 3 4 4 0 1 2 2 3 3 4 4 0 … … 이렇게 인덱스 값을 구할 수 있다면 다음 작업은 아주 간단합니다. 인덱스에 맞는 배너를 접근해 현재 배너는 활성화에서 비활성화 상태로 변경하고 다음 배너는 비활성화에서 활성화 상태로 만들어 주기만 하면 됩니다. 지금까지 설명을 소스 코드로 표현하면 다음과 같습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071$(function() &#123; // 인스턴스 생성 var rolling1 = new RollingBanner();&#125;)function RollingBanner() &#123; // 프로퍼티 생성 및 초기화 this._$banners = null; this._currentIndex = 0; // step #03 this._timerID = -1; this._init(); this._initBannerPos(); // step #03 this.startAutoPlay();&#125;// 요소 초기화RollingBanner.prototype._init = function() &#123; this._$banners = $(\".banner1 li\");&#125;// 배너 위치 초기화RollingBanner.prototype._initBannerPos = function() &#123; // 배너 위치를 화면에서 보이지 않게 숨기기 this._$banners.css(\"top\", 200); // 0번째 배너 활성화 this._$banners.eq(this._currentIndex).css(\"top\", 0);&#125;// step #03RollingBanner.prototype.startAutoPlay = function() &#123; var objThis = this; // 타이머가 두번 이상 실행되지 않게 조건 처리 if(this._timerID == -1) &#123; this._timerID = setInterval(function() &#123; objThis.nextBanner(); &#125;, 2000) &#125;&#125;// 다음 배너 활성화RollingBanner.prototype.nextBanner = function() &#123; // 현재 index값 구하기 var outIndex = this._currentIndex; // 다음 배너 index값 구하기 this._currentIndex++; // 마지막 배너까지 롤링한 경우 0번째부터 롤링될 수 있게 인덱스 값을 0으로 설정 if(this._currentIndex &gt;= this._$banners.length) &#123; this._currentIndex = 0; &#125; // 현재 배너 구하기 var $outBanner = this._$banners.eq(outIndex); // 다음 배너 구하기 var $inBanner = this._$banners.eq(this._currentIndex); // 현재 배너 사라지게 하기 $outBanner.css(&#123; top: -200 &#125;); // 현재 배너 나타나게 하기 $inBanner.css(&#123; top: 0 &#125;);&#125; 47번 라인: 먼저 nextBanner() 메서드를 신규로 만든 후 다음 배너를 활성화하는 코드를 작성해 줍니다. 49번 라인: 좀더 자세히 설명하면 현재 배너와 다음 배너 인덱스 값을 구합니다. 58번 라인: 배너 목록에서 인덱스 값에 해당하는 현재 배너와 다음 배너를 구합니다. 63번 라인: 현재 배너는 화면에서 사라지게 만들어 줍니다. 68번 라인: 다음 배너는 나타나게 만들어 줍니다. 11번 라인: 타이머 아이디 값을 담을 변수를 만들어 줍니다. 초깃값은 -1로 설정해 줍니다. 35번 라인: 신규로 startAutoPlay() 메서드를 추가한 후 타이머를 이용해 2초에 한 번씩 nextBanner()메서드를 호출하는 코드를 작성해 줍니다. 17번 라인: 배너가 무한 롤링될 수 있게 startAutoPlay() 메서드를 생성자에서 호출해 줍니다. 코드를 모두 입력한 후 실행해 보세요. 정상적으로 코드를 입력했다면 다음 실행화면처럼 배너가 무한 롤링되는 화면을 볼 수 있을 것입니다.소스코드 다운받기 롤링 효과 적용드디어 마지막 작업이네요. 이번 단계에서 구현할 내용은 배너가 부드럽게 나타나고 사라지는 롤링 효과를 구현하는 작업입니다.롤링효과는 다음과 같은 순서로 구현됩니다.지금까지 설명을 코드로 표현하면 다음과 같습니다.[javascript]123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293$(function() &#123; var rolling1 = new RollingBanner();&#125;)function RollingBanner() &#123; // 프로퍼티 생성및 초기화 this._$banners = null; this._currentIndex = 0; // step #03 this._timerID = -1; this._init(); this._initBannerPos(); // step #03 this.startAutoPlay();&#125;// 요소 초기화.RollingBanner.prototype._init = function() &#123; this._$banners = $(\".banner1 li\");&#125;// 배너 위치 초기화RollingBanner.prototype._initBannerPos = function() &#123; // 배너 위치를 화면에서 보이지 않게 숨기기 this._$banners.css(\"top\", 200); // 0번째 배너 활성화 this._$banners.eq(this._currentIndex).css(\"top\", 0);&#125;// step #03RollingBanner.prototype.startAutoPlay = function() &#123; var objThis = this; // 타이머가 두번 이상 실행되지 않게 조건 처리 if (this._timerID == -1) &#123; this._timerID = setInterval(function() &#123; objThis.nextBanner(); &#125;, 2000) &#125;&#125;// step #03// 다음 배너 활성화RollingBanner.prototype.nextBanner = function() &#123; // 현재 index값 구하기 var outIndex = this._currentIndex; // 다음 배너 index값 구하기 this._currentIndex++; // 마지막 배너까지 롤링한 경우 다시 0번째부터 롤링될 수 있게 인덱스 값을 0으로 설정 if (this._currentIndex &gt;= this._$banners.length) &#123; this._currentIndex = 0; &#125; // 현재 배너 구하기 var $outBanner = this._$banners.eq(outIndex); // 다음 배너 구하기 var $inBanner = this._$banners.eq(this._currentIndex); /* // 현재 배너 사라지게 하기 $outBanner.css(&#123; top: -200 &#125;); // 현재 배너 나타나게 하기 $inBanner.css(&#123; top: 0 &#125;); */ // 롤링 준비-다음 배너 위치 초기화 $inBanner.css(&#123; top:200, opacity:0 &#125;) // 현재 배너 사라지게 하기 $outBanner.stop().animate(&#123; top:-200, opacity:0 &#125;,600); // 다음 배너 나타나게 하기 $inBanner.stop().animate(&#123; top:0, opacity:1 &#125;,600);&#125; [css]1234567891011121314.rolling_banner&#123; overflow:hidden; position:absolute;top:50%;left:50%; margin:-100px 0 0 -200px; width:400px;height:200px; border:1px solid #000&#125;.rolling_banner li&#123; float:left; position:absolute;top:0;left:0; width:400px;height:200px; line-height:200px;text-align:center; /* opacity 속성 삭제 */&#125; 설명 javascript - 76번 라인: 롤링 순서 첫 번째 단계인 롤링 준비에 해당하는 코드입니다. 다음에 등장할 배너 위치를 잡아줍니다. javascript - 82번 라인: 롤링을 시작합니다. 현재 배너는 화면에서 사라지는 효과를 내기 위해 top을 -200px 위치로 opacity 값을 0으로 설정해 jQuery에서 제공하는 animate() 메서드를 호출해 줍니다. javascript - 89번 라인: 다음 배너는 화면에 등장하는 효과를 내기 위해 top 값을 0px 위치로 opacity 값을 1로 설정해 animate() 메서드를 호출해 줍니다. javascript - 82,89번 라인 내용이 호출되면 배너가 롤링되기 시작합니다. css - 2번 라인: 테스트를 위해 주석처리 해놓은 overflow:hidden을 다시 활성화 시켜 줍니다. css - 13번 라인: 테스트를 위해 추가했던 opacity:0.2를 제거해 줍니다. 코드를 모두 입력했다면 정상적으로 롤링이 되는지 실행해 보세요. 멋지게 동작하는 롤링 배너를 볼 수 있을 것입니다.소스코드 다운받기 이렇게 해서 첫 번째 미션이자 첫 번째 버전인 롤링 배너를 클래스 단위 코딩으로 완성해 봤습니다. 지금까지 만든 롤링 배너를 UML로 요약하면 다음과 같습니다. 롤링 배너 ver 2.0: 여러 개의 롤링배너 만들기이번 미션에서는 하나의 클래스로 여러 개의 객체를 생서하기 위한 옵션값 처리 방법과 클래스 재사용 방법 등을 학습합니다. 소개 및 미리보기롤링 배너 ver 1.0 에서 만든 롤링 배너는 배너 선택자가 내부에 포함돼 있기 때문에 아쉽게도 오직 하나의 롤링 배너만을 만들 수 밖에 없었습니다.이와 더불어 배너 높이 값이 200으로 하드 코딩되어 있기 때문에 만약 배너 높이가 200이 아닌 경우 이 값도 수정해줘야 하는 번거로움이 있습니다. 이번 미션은 바로 클래스 하나로 여러 개의 롤링 배너를 만들 수 있게 코드를 수정하는 것입니다. 실제 구현에 앞서 이번 미션에서 구현해야 할 내용을 정확히 파악하기 위해 구현 완료된 예제를 확인해 보겠습니다. 자세히 보면 두 개의 롤링 배너가 전환되는 시간과 롤링 효과의 진행 시간이 다르다는 것을 알 수 있을 것 입니다. 바로 이 내용이 만들어야 할 미션입니다. 요구사항이번 미션의 요구사항을 정리하면 다음과 같습니다. RollingBanner 클래스 하나로 여러 개의 롤링 배너를 만들 수 있게 수정해 주세요. 배너 전환 시간을 설정할 수 있게 만들어 주세요. 롤링 효과 시간을 설정할 수 있게 만들어 주세요. 레이아웃 구성원활한 작업을 위해 마크업 및 CSS 스타일 속성은 다음과 같이 만들어 둔 상태입니다. [html]123456789101112131415161718192021&lt;div class=\"rolling_banner banner1\"&gt; &lt;img src=\"img/1.jpg\"&gt; &lt;img src=\"img/2.jpg\"&gt; &lt;img src=\"img/3.jpg\"&gt; &lt;img src=\"img/4.jpg\"&gt; &lt;img src=\"img/5.jpg\"&gt; &lt;img src=\"img/6.jpg\"&gt; &lt;img src=\"img/7.jpg\"&gt; &lt;img src=\"img/8.jpg\"&gt;&lt;/div&gt;&lt;div class=\"rolling_banner banner2\"&gt; &lt;img src=\"img/1.jpg\"&gt; &lt;img src=\"img/2.jpg\"&gt; &lt;img src=\"img/3.jpg\"&gt; &lt;img src=\"img/4.jpg\"&gt; &lt;img src=\"img/5.jpg\"&gt; &lt;img src=\"img/6.jpg\"&gt; &lt;img src=\"img/7.jpg\"&gt; &lt;img src=\"img/8.jpg\"&gt;&lt;/div&gt; [css]123456789101112131415161718192021222324.rolling_banner&#123; overflow:hidden; position:absolute; border:1px solid #000&#125;.rolling_banner img&#123; position:absolute; top:0;left:0; width:100%;height:100%;&#125;.banner1 &#123; top:30px; left:50px; width:100px; height:50px;&#125;.banner2 &#123; top:30px; left:160px; width:200px; height:100px;&#125; 소스코드 다운받기 이렇게 해서 이번 미션에서 구현할 내용을 모두 살펴봤습니다. 그림 지금부터 미션 풀이를 진행해 보겠습니다. 기능 구현하기기능 구현은 이해를 돕기 위해 다음과 같이 총 5단계로 나눠 진행하겠습니다. 여러 개의 롤링 배너를 만들 수 있게 수정 롤링 배너 위치 값 자동으로 설정하기 2.의 문제점 해결하기 1. 여러개의 롤링 배너를 만들 수 있게 수정앞에서 알아본 것처럼 현재 롤링 배너는 배너 정보가 고정돼 있기 때문에 여러 개의 롤링 배너를 만들 수 없습니다.이번 단계에서는 이 부분을 수정해 하나의 RollingBanner 클래스로 여러 개의 롤링 배너를 만들 수 있게 수정해보죠. 코드는 설명 순서대로 입력하면 됩니다. 1234567891011121314151617181920$(function() &#123; // 인스턴스 생성 var rolling1 = new RollingBanner(\".banner1\"); var rolling2 = new RollingBanner(\".banner2\");&#125;)function RollingBanner(selector) &#123; this._$banners = null; this._currentIndex = 0; this._timerID = -1; this._init(selector); this._initBannerPos(); this.startAutoPlay();&#125;// 요소 초기화RollingBanner.prototype._init = function(selector) &#123; this._$banners = $(selector).children(\"img\");&#125; 설명 18번 라인: 먼저 고정된 선택자 값을 매개변수 갑승로 받을 수 있게 selector라는 매개변수를 추가해 줍니다. 19번 라인: 여기서 주의해야 할 사항이 있습니다. 기존 코드에서는 &quot;.banner1 img와 같은 식으로 선택자를 만들어 사용했는데요. 여기에서는 이 방법 대신 배너 이미지 정보를 가지고 있는 노드만을 선택자(.banner1 또는 .banner2)로 받아 내부에서 배너 이미지 정보(img)를 찾는 구조로 변경했습니다. 이렇게 변경한 이유는 배너 이미지를 감싸고 있는 노드, 즉 selector에 해당하는 DOM 요소에 이벤트를 걸어야 하는 경우가 많기 때문입니다. 7번 라인: 배너 정보를 나타내는 선택자를 외부에서 설정할 수 있게 생성자에 selector라는 매개변수를 추가해 줍니다. 12번 라인: 객체가 생성될 때 공용 요소를 찾도록 만들기 위해 7번 라인에서 받은 선택자 값을 _init() 메서드의 매개변수 값으로 넘겨 줍니다. 3번 라인: 첫 번째 배너를 나타내는 선태자인 .banner1을 값으로 RollingBanner클래스의 인스턴스를 생성해 줍니다. 4번 라인: 추가로 두 번째 배너를 나타내는 선택자인 .banner2를 값으로 RollingBanner 클래스의 인스턴스를 생성해 줍니다. 지금까지 설명을 요약해보면 선택자 정보는 다음 같은 흐름을 타고 사용됩니다.코드를 모두 입력했다면 두 개의 롤링 배너가 정상적으로 동작하는지 실행해 보세요. 실행 화면처럼 동시에 배너가 롤링되는 것을 볼 수 있을 것입니다.실행화면소스코드 다운받기 2. 롤링 배너 위치 값 자동으로 설정하기1. 여러개의 롤링 배너를 만들 수 있게 수정 에서는 정상적으로 동작하는 것처럼 보이지만 자세히 살펴보면 둘 다 이상합니다. 왜냐면 롤링 배너 위치 값이 200으로 고정돼 있기 때문에 두 롤링 배너의 경우 높이가 각각 50과 100으로 첫번째는 시작 위치가 50만큼 두번째는 시작위치가 100만큼 이어야 하지만 고정된 값 때문에 200이 돼 버립니다. 현재 배너가의 사라지는 위치 역시 -200이 되어 깔끔하지 않게 롤링효과가 진행됩니다. 바로 이번 단계에서 구현할 내용은 배너에 따라 자동으로 다음 배너의 시작 위치 값과 현재 배너의 마지막 위치 값을 설정할 수 있게 만드는 작업입니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980$(function() &#123; var rolling1 = new RollingBanner(\".banner1\"); var rolling2 = new RollingBanner(\".banner2\");&#125;)function RollingBanner(selector) &#123; // 프로퍼티 생성및 초기화 this._$banners = null; this._currentIndex = 0; this._timerID = -1; this._bannerHeight = 0; this._init(selector); this._initBannerPos(); this.startAutoPlay();&#125;// 요소 초기화.RollingBanner.prototype._init = function(selector) &#123; this._$banners = $(selector).children(\"img\"); this._bannerHeight = this._$banners.eq(0).height();&#125;// 배너 위치 초기화RollingBanner.prototype._initBannerPos = function() &#123; // 배너 위치를 화면에서 보이지 않게 숨기기 this._$banners.css(\"top\", this._bannerHeight); // 0번째 배너 활성화 this._$banners.eq(this._currentIndex).css(\"top\", 0);&#125;RollingBanner.prototype.startAutoPlay = function() &#123; var objThis = this; // 타이머가 두번 이상 실행되지 않게 조건 처리 if (this._timerID == -1) &#123; this._timerID = setInterval(function() &#123; objThis.nextBanner(); &#125;, 2000) &#125;&#125;// 다음 배너 활성화RollingBanner.prototype.nextBanner = function() &#123; // 현재 index값 구하기 var outIndex = this._currentIndex; // 다음 배너 index값 구하기 this._currentIndex++; // 마지막 배너까지 롤링한 경우 다시 0번째부터 롤링될 수 있게 인덱스 값을 0으로 설정 if (this._currentIndex &gt;= this._$banners.length) &#123; this._currentIndex = 0; &#125; // 현재 배너 구하기 var $outBanner = this._$banners.eq(outIndex); // 다음 배너 구하기 var $inBanner = this._$banners.eq(this._currentIndex); // 롤링 준비-다음 배너 위치 초기화 $inBanner.css(&#123; top: this._bannerHeight, opacity:0 &#125;) // 현재 배너 사라지게 하기 $outBanner.stop().animate(&#123; top:-this._bannerHeight, opacity:0 &#125;,600); // 다음 배너 나타나게 하기 $inBanner.stop().animate(&#123; top:0, opacity:1 &#125;,600);&#125; 설명 11번 라인: 생성자에 배너 높이를 담을 프로퍼티를 _bannerHeight라는 이름으로 추가합니다. 21번 라인: 롤링 배너의 크기는 모두 동일하기 때문에 0번째 배너의 높이 값을 _bannerHeight에 대입해 줍니다. 27,64,70번 라인에 고정돼 있던 200과 -200대신 _bannerHeight 프로퍼티를 넣어 줍니다. 코드를 모두 입력했다면 정상적으로 동작하는지 실행해보죠. 하지만 아쉽게도 롤링배너가 제대로 동작하지 않을 것입니다. 이유는 시작부분에 해당하는 jQuery 의 ready()는 배너 이미지가 로딩 되기 전에 실행되기 때문에 ready()에서 배너 이미지의 높이를 구하는 경우 0이 돼버립니다. 문제 해결 방법에 대해서는 다음 단계에서 자세히 알아보겠습니다.※ $(document).ready(function() {}); = $(function() {}); 3. 문제점 해결하기2. 롤링 배너 위치 값 자동으로 설정하기 에서 발생한 문제점을 해결하는 방법은 두 가지 정도가 있습니다. 첫 번째 window.onload이벤트를 활용하는 방법 두 번째 이미지의 load이벤트를 활용하는 방법 먼저 첫 번째 방법부터 자세히 알아보죠. 첫 번째 window.onload 이벤트를 활용하는 방법자바스크립트 기본 객체인 window에서 발생하는 onload 이벤트는 웹브라우저가 웹페이지를 읽어 들인 후 파싱 단계를 거쳐 작성된 HTML 태그와 1:1 맵핑되는 DOM 객체를 만드는 작업부터 웹페이지 포함된 이미지와 같은 리소스까지 모두 읽어들인 후 사용할 준비가 되면 발생하는 이벤트 입니다. 이와 달리 현재 예제에서 사용한 jQuery의 ready() 메서드는 자바스크립트의 DOMContentLoaded라는 이벤트를 내부에서 사용하며 이 이벤트는 웹브라우저가 웹페이지를 읽어 들인 후 파생 단계를 거쳐 작성된 태그와 1:1 맵핑되는 DOM 객체로 만드는 작업을 완료한 후 발생하는 이벤트입니다. 간단한 예제를 만들어 이 두 이벤트의 차이점에 대해 알아보죠. [jQuery ready()]123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;DOMContentLoaded&lt;/title&gt; &lt;script src=\"https://code.jquery.com/jquery-1.12.4.min.js\"&gt;&lt;/script&gt;&lt;script&gt; $(function() &#123; var height = $(\".target\").height(); alert(\"height = \" + height);&#125;)&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=\"image/1.jpg\" class=\"target\"&gt;&lt;/body&gt;&lt;/html&gt; 소스코드 다운받기설명실행해 보면 이미지 높이가 0으로 나오는 것을 알 수 있습니다. 몇 번 실행하다 보면 높이가 400으로 나오는 경우도 있는데 이유는 웹브라우저에 캐쉬된 이미지가 사용되기 때문입니다. [onload]123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;onload&lt;/title&gt; &lt;script src=\"https://code.jquery.com/jquery-1.12.4.min.js\"&gt;&lt;/script&gt;&lt;script&gt;window.onload = function() &#123; var height = $(\".target\").height(); alert(\"height = \" + height);&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=\"image/1.jpg\" class=\"target\"&gt;&lt;/body&gt;&lt;/html&gt; 소스코드 다운받기설명이미지 크기가 정확하게 출력되는 것을 확인할 수 있습니다.이에 따라 실행 즉시 이미지 크기를 알아내려면 window 객체에서 발생하는 onload 이벤트를 사용해야 합니다. 즉 기존 롤링 배너 코드를 ready() 메서드 대신 onload 이벤트로 다음과 같이 변경만 하면 됩니다. 12345// 여기에 스크립트 코드를 작성해 주세요.window.onload = function() &#123; var rolling1 = new RollingBanner(\".banner1\"); var rolling2 = new RollingBanner(\".banner2\");&#125; 소스코드 다운받기 두 번째 이미지의 onload 이벤트를 활용하는 방법&lt;img&gt;태그와 1:1 맵핑되는 객체는 HTMLImageElement라는 객체입니다. 이 객체는 주로 img 태그의 src 속성에 해당하는 이미지를 읽어들여 화면에 보여주는 기능을 합니다. 이때 이미지를 모두 읽어들이면 onload라는 이벤트를 발생합니다.[jQuery load 이벤트]1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;title&gt;onload&lt;/title&gt; &lt;script src=\"https://code.jquery.com/jquery-1.12.4.min.js\"&gt;&lt;/script&gt;&lt;script&gt;$(function() &#123; $(\".target\").on('load', function() &#123; var height = $(\".target\").height(); alert(\"height = \" + height); &#125;)&#125;)&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;img src=\"image/1.jpg\" class=\"target\"&gt;&lt;/body&gt;&lt;/html&gt; 소스코드 다운받기 설명이미지의 높이가 정상적으로 출력되는 것을 확인할 수 있습니다. 롤링 배너에 이미지 onload 이벤트를 활용하려면 다음과 같이 변경해줘야 합니다. 설명 우선 이미지 높이 값을 구하기 전까지 롤링 효과가 실행되면 안 되기 때문에 _start()라는 메서드를 만든 후 생성자에 작성한 _initBannerPos() 메서드와 startAutoPlay() 메서드 호출 코드를 옮겨 줍니다. 다음으로 _initEvent()라는 메서드를 신규로 만들어 줍니다. 그리고 첫 번째 배너에 load 이벤트 리스너를 걸어 줍니다. 이때 이벤트는 한 번만 사용하고 지울 것이기 때문에 on() 메서드 대신 one() 메서드를 사용합니다. load 이벤트 리스너 내부 높이 너비를 구하는 코드를 작성해 줍니다. 여기까지 실행되면 롤링 배너를 시작할 준비가 모두 마무리 됩니다. 마지막으로 1.에서 만든 _start() 메서드를 호출 합니다. 지금까지 설명한 코드가 실행될 수 있게 생성자에 _initEvent()메서드를 호출해 줍니다. 코드를 모두 입력했다면 다시 한 번 실행해 보세요. 롤링 배너가 정상적으로 동작하는 것을 확인할 수 있습니다. 풀이는 앞으로 두 번째 방법인 이미지 로드 이벤트를 활용한 방법을 사용하겠습니다. 소스코드 다운받기 4. 배너 전환 시간 설정 기능 추가이번에는 롤링 배너마다 배너 전환 시간을 다르게 설정할 수 있는 기능을 추가해 보죠. 수정 방법은 1. 여러개의 롤링 배너를 만들 수 있게 수정과 동일 합니다. 고정된 값을 외부에서 설정할 수 있게 변경해 주는 것이죠. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104// 여기에 스크립트 코드를 작성해 주세요.$(function() &#123; // 인스턴스 생성 var rolling1 = new RollingBanner(\".banner1\", 3000); var rolling2 = new RollingBanner(\".banner2\", 1000);&#125;)function RollingBanner(selector, playSpeed) &#123; // 프로퍼티 생성및 초기화 this._$banners = null; this._currentIndex = 0; this._timerID = -1; // step #02 this._bannerHeight=0; this._playSpeed = playSpeed; this._init(selector); this._initEvent();&#125;// 요소 초기화.RollingBanner.prototype._init = function(selector) &#123; this._$banners = $(selector).children(\"img\");&#125;// 이벤트 처리RollingBanner.prototype._initEvent = function() &#123; var objThis = this; this._$banners.eq(0).one(\"load\",function()&#123; objThis._bannerHeight= $(this).height(); objThis._start(); &#125;)&#125;// 초기화및 롤링배너 시작RollingBanner.prototype._start = function() &#123; this._initBannerPos(); this.startAutoPlay();&#125;// 배너 위치 초기화RollingBanner.prototype._initBannerPos = function() &#123; // 배너 위치를 화면에서 보이지 않게 숨기기 // step #02 this._$banners.css(\"top\", this._bannerHeight); // 0번째 배너 활성화 this._$banners.eq(this._currentIndex).css(\"top\", 0);&#125;RollingBanner.prototype.startAutoPlay = function() &#123; var objThis = this; // 타이머가 두번 이상 실행되지 않게 조건 처리 if (this._timerID == -1) &#123; this._timerID = setInterval(function() &#123; objThis.nextBanner(); &#125;, this._playSpeed); &#125;&#125;// 다음 배너 활성화RollingBanner.prototype.nextBanner = function() &#123; // 현재 index값 구하기 var outIndex = this._currentIndex; // 다음 배너 index값 구하기 this._currentIndex++; // 마지막 배너까지 롤링한 경우 다시 0번째부터 롤링될 수 있게 인덱스 값을 0으로 설정 if (this._currentIndex &gt;= this._$banners.length) &#123; this._currentIndex = 0; &#125; // 현재 배너 구하기 var $outBanner = this._$banners.eq(outIndex); // 다음 배너 구하기 var $inBanner = this._$banners.eq(this._currentIndex); // 롤링 준비-다음 배너 위치 초기화 $inBanner.css(&#123; top:this._bannerHeight, opacity:0 &#125;) // 현재 배너 사라지게 하기 $outBanner.stop().animate(&#123; top:-this._bannerHeight, opacity:0 &#125;,600); // 다음 배너 나타나게 하기 $inBanner.stop().animate(&#123; top:0, opacity:1 &#125;,600);&#125; 설명 8번 라인: 외부에서 전환 시간을 설정할 수 있게 생성자에 playSpeed라는 매개변수를 추가해 줍니다. 17번 라인: _playSpeed라는 이름을 가진 신규 프로퍼티를 추가한 후 playSpeed 매개변수 값으로 초기화해 줍니다. 63번 라인: startAutoPlay에 고정된 2000 값 대신 _playSpeed 프로퍼티를 넣어 줍니다. 4번 라인: 첫 번째 롤링 배너는 3000(3초)으로 전환 시간을 설정해 줍니다. 5번 라인: 두 번째 롤링 배너는 1000(1초)으로 전환 시간을 설정해 줍니다. 코드를 모두 입력했다면 정상적으로 동작하는지 실행해 보죠. 각기 다르게 전환 효과가 동작하는 것을 확인할 수 있을 것입니다.소스코드 다운받기 5. 롤링 효과 시간 설정 기능 추가이번 기능 역시 앞에서 했던 단계와 동일한 방법으로 고정된 롤링 효과 시간 값을 외부에서 설정할 수 있게 만들면 됩니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104$(function() &#123; // 인스턴스 생성 var rolling1 = new RollingBanner(\".banner1\", 3000, 1000); var rolling2 = new RollingBanner(\".banner2\", 1000, 300);&#125;)function RollingBanner(selector, playSpeed, rollingSpeed) &#123; // 프로퍼티 생성및 초기화 this._$banners = null; this._currentIndex = 0; this._timerID = -1; // step #02 this._bannerHeight=0; this._playSpeed = playSpeed; this._rollingSpeed = rollingSpeed; this._init(selector); this._initEvent();&#125;// 초기화및 롤링배너 시작RollingBanner.prototype._start = function() &#123; this._initBannerPos(); this.startAutoPlay();&#125;// 요소 초기화.RollingBanner.prototype._init = function(selector) &#123; this._$banners = $(selector).children(\"img\");&#125;// 이벤트 처리RollingBanner.prototype._initEvent = function() &#123; var objThis = this; this._$banners.eq(0).one(\"load\",function()&#123; objThis._bannerHeight= $(this).height(); objThis._start(); &#125;)&#125;// 배너 위치 초기화RollingBanner.prototype._initBannerPos = function() &#123; // 배너 위치를 화면에서 보이지 않게 숨기기 // step #02 this._$banners.css(\"top\", this._bannerHeight); // 0번째 배너 활성화 this._$banners.eq(this._currentIndex).css(\"top\", 0);&#125;RollingBanner.prototype.startAutoPlay = function() &#123; var objThis = this; // 타이머가 두번 이상 실행되지 않게 조건 처리 if (this._timerID == -1) &#123; this._timerID = setInterval(function() &#123; objThis.nextBanner(); &#125;, this._playSpeed); &#125;&#125;// 다음 배너 활성화RollingBanner.prototype.nextBanner = function() &#123; // 현재 index값 구하기 var outIndex = this._currentIndex; // 다음 배너 index값 구하기 this._currentIndex++; // 마지막 배너까지 롤링한 경우 다시 0번째부터 롤링될 수 있게 인덱스 값을 0으로 설정 if (this._currentIndex &gt;= this._$banners.length) &#123; this._currentIndex = 0; &#125; // 현재 배너 구하기 var $outBanner = this._$banners.eq(outIndex); // 다음 배너 구하기 var $inBanner = this._$banners.eq(this._currentIndex); // 롤링 준비-다음 배너 위치 초기화 $inBanner.css(&#123; top:this._bannerHeight, opacity:0 &#125;) // 현재 배너 사라지게 하기 $outBanner.stop().animate(&#123; top:-this._bannerHeight, opacity:0 &#125;,this._rollingSpeed); // 다음 배너 나타나게 하기 $inBanner.stop().animate(&#123; top:0, opacity:1 &#125;,this._rollingSpeed);&#125; 설명 7번 라인: 외부에서 롤링 효과 시간을 설정할 수 있게 생성자에 rollingSpeed라는 매개변수를 추가해 줍니다. 17번 라인: _rollingSpeed라는 이름을 가진 신규 프로퍼티를 추가한 후 rollingSpeed 매개변수 값으로 초기화해 줍니다. 96,103번 라인: nextBanner()메서드에서 600(0.6초)으로 고정되어 있는 값 대신 _rollingSpeed를 넣어 줍니다. 3번 라인: 첫 번째 롤링 배너의 롤링 효과 시간을 1000(1초)으로 설정해 줍니다. 4번 라인: 두 번째 롤링 배너의 롤링 효과 시간을 300(0.3초)으로 설정해 줍니다. 3,4번 라인 에서 주의해야 할 사항이 있는데요. 롤링 효과 시간이 전환보다 커서는 안됩니다. 만약 크게 되는 경우 올린 효과가 진행 도중에 배너가 전환돼버립니다. 자! 그럼 코드를 모두 입력헀다면 실행해보죠. 설정한 롤링 효과 시간이 적용돼 첫 번째 롤링 배너가 두 번째 롤링배너보다 느리게 롤링 효과가 동작하는 것을 확인할 수 있을 것입니다.소스코드 다운받기 지금까지 작성한 코드를 UML로 요약하면 다음과 같습니다. 롤링 배너 ver 3.0: 상속 활용이번 미션에서는 클래스 상속을 활용해 기능을 확장하는 방법을 학습합니다. 클래스 상속의 기능을 다시한번 확인할 수 있는 좋은 예제가 될 것입니다. 미션 소개 및 미리보기일반적인 롤링 배너의 경우 배너 영역에 마우스가 들어오는 경우 롤링 효과가 멈추고 마우스가 배너 영역 밖으로 나가는 경우 다시 롤링되는 기능을 가지고 있습니다. 바로 이번 미션은 이 기능을 구현하는 것입니다. 이번 미션을 좀더 자세히 알아보기 위해 이미 완성된 모습을 보겠습니다. 실행하면 미션2 에서 만든 것과 동일하게 동작하는 롤링 배너를 볼 수 있을 것입니다. 여기서 왼쪽 롤링배너는 기존과 똑같은 일반 롤링배너입니다. 바로 두 번째 롤링 배너가 정지/재실행 기능이 구현된 롤링 배너입니다. 테스트를 한번 해보죠. 두 번째 롤링 배너에 마우스 포인터를 올려 보세요. 멈추죠? 다시 마우스 포인터를 롤링배너 밖으로 이동해 보세요. 그럼 다시 롤링되기 시작할 것입니다. 요구사항지금까지 살펴본 내용을 정리하면 다음 요구 사항에 맞게 기존 롤링 배너를 확장해 기능을 추가하는 미션입니다. 기존 롤링 배너를 확장해 롤링 배너에 마우스 커서가 들어오는 경우 멈추고 다시 밖으로 나가는 경우 다시 롤링되게 만들어 주세요. 단, 기존 RollingBanner 클래스를 절대 수정해서는 안 됩니다. 이 미션의 핵심은 바로 두 번째 내용 입니다. 기존에 만들어져 있는 RollingBanner 클래스를 절대 수정해서는 안 됩니다. 핵심 내용 및 해결책 찾기이번 미션의 핵심은 기존 RollingBanner 클래스를 수정하지 않고 기능을 추가하는 것입니다. 왠지 모순처럼 들리지만 이럴 때 사용하는 기능이 바로 클래스 상속이라는 것을 앞에서 배웠습니다. 맞습니다. 이번 미션은 과연 상속을 제대로 이해하고 있는지 테스트하기 위한 미션입니다. 구현하기이번 미션 풀이는 이해를 돕기 위해 다음과 같이 총 3단계로 나눠 진행하겠습니다. 자식 롤링 배너 클래스 만들기 요소 초기화 메서드 기능 확장 정지/재시작 기능 추가 그럼 첫 번째 단계부터 시작해보죠. 1. 자식 롤링 배너 클래스 만들기이번 단계에서는 기존 RollingBanner 클래스를 확장해 기능을 추가할 자식 클래스를 만드는 작업을 하겠습니다. 12345678910111213141516$(function() &#123; // 인스턴스 생성 var rolling1 = new RollingBanner(\".banner1\", 3000, 1000); var rolling2 = new ChildRollingBanner(\".banner2\",1000,300);&#125;)// ~~~~~ 중략 ~~~~~~// 자식 롤링 배너 클래스function ChildRollingBanner(selector, playSpeed, rollingSpeed) &#123; RollingBanner.call(this, selector, playSpeed, rollingSpeed);&#125;// RollingBanner 상속 받기ChildRollingBanner.prototype = new RollingBanner();ChildRollingBanner.prototype.constructor = ChildRollingBanner; 설명 10번 라인: 먼저 RollingBanner 클래스를 상속받아 기능을 추가할 자식 클래스를 ChildRollingBanner라는 이름으로 클래스를 만들어 줍니다.여기에서 주의해야 할 사항이 있는데요. 부모 생성자에 넘겨줘야 할 파라미터 값이 있는 경우 자식 클래스의 생성자에서 값을 넘겨줘야 합니다. 이를 위해서 자식클래스의 생성자에도 부모 클래스의 생성자와 똑같이 매개변수를 만들어 줍니다. 11번 라인: 자식에서 받은 매개변수 값을 그대로 부모에게 넘겨주기 위해 자식 객체 생성 시 넘겨 받은 매개변수 값을 call()메서드를 이용해 부모 생성자로 넘겨 줍니다.[객체지향 프로그래밍 특징] 자식 클래스와 부모 클래스 연동 처리참조 15번 라인: 부모 클래스인 RollingBanner를 자식 클래스인 ChildRollingBanner가 상속받을 수 있게 상속 관계를 만들어 줍니다. 15,16번 라인 이 실행되면 생성자 정보를 담고 있는 속성인 constructor에는 기존 부모 생성자가 담기게 됩니다. 그렇기 때문에 자식 클래스의 생성자를 대입해 줘야 합니다.[객체지향 프로그래밍 특징] constructor 프로퍼티 활용참조 4번 라인: 아직 두 기능을 모두 구현하지 않았지만 입력한 정보가 정상적으로 테스트 하기 위해 두 번째 롤링 배너를 ChildRollingBanner 클래스로 변경해 줍니다. 자! 코드를 모두 입력했다면 정상적으로 동작하는지 보겠습니다. 실행 결과는 기존과 동일하니 입력한 코드에서 에러가 없는지 확인만 하면 됩니다.소스코드 다운받기 요소 초기화 메서드 기능 확장마우스가 롤링 배너로 들어오는 경우 롤링 효과를 멈추고 나가는 경우 다시 롤링 효과가 동작되게 하려면 롤링 배너 자체에 이벤트를 걸어야 합니다. 이번 단계에서는 이벤트 리스너를 등록하기 위한 준비 작업을 해보겠습니다. 123456789101112131415// 자식 롤링 배너 클래스function ChildRollingBanner(selector, playSpeed, rollingSpeed) &#123; this._$rolling = null; RollingBanner.call(this, selector, playSpeed, rollingSpeed);&#125;// RollingBanner 상속 받기ChildRollingBanner.prototype = new RollingBanner();ChildRollingBanner.prototype.constructor = ChildRollingBanner;// 요소 초기화ChildRollingBanner.prototype._init = function(selector) &#123; this._$rolling = $(selector); RollingBanner.prototype._init.call(this, selector);&#125; 설명 3번 라인: 먼저 이벤트를 걸기 위해 필요한 롤링 배너를 담을 _$rolling프로퍼티를 생성자에 추가해 줍니다. 12번 라인: 요소 초기화 기능을 확장하기 위해 _init() 메서드를 오버라이드(override)해 줍니다. 13번 라인: selector 정보에 해당하는 요소를 찾아 _$rolling 프로퍼티에 저장합니다. 14번 라인: 롤링할 배너들을 찾는 기능은 부모 클래스의 _init()메서드에 이미 구현돼 있기 때문에 부모 클래스의 _init() 메서드를 호출해 줍니다. 코드를 입력했다면 정상적으로 동작하는지 실행해보겠습니다. 이번 단계 역시 실행 화면은 동일합니다. 여기서 주의해서 봐야할 부분은 _init()메서드입니다.소스코드 다운받기 ChildRollingBanner 클래스의 인스턴스가 생성되면 _init() 메서드는 다음과 같은 순서로 실행됩니다. 순서1ChildRollingBanner 클래스의 인스턴스가 생성되면 먼저 자식 클래스의 생성자가 실행됩니다. 순서2RollingBanner.call() 메서드에 의해 부모 클래스의 생성자가 실행되며 프로퍼티가 생성됩니다. 순서3부모생성자의 내부에 this._init() 메서드가 호출되면 부모 클래스의 _init() 메서드가 호출되는 것이 아니라 자식 클래스의 _init() 메서드가 호출됩니다. 순서4RollingBanner.prototype._init.call() 메서드에 의해서 부모 클래스의 _init() 메서드가 호출됩니다. 3. 정지/재시작 기능 추가이번에는 이번 미션의 핵심 기능인 롤링 배너 위에 마우스가 들어올 때 롤링 효과가 멈추고 나가는 경우 다시 롤링 효과가 동작하게 만드는 기능을 구현해 보겠습니다. 12345678910111213141516171819202122// 메서드 overrideChildRollingBanner.prototype._initEvent=function() &#123; RollingBanner.prototype._initEvent.call(this); var objThis = this; // 마우스가 롤링 배너에 들어오는 경우 롤링 효과 정지 this._$rolling.mouseenter(function () &#123; objThis.stopAutoPlay(); &#125;); // 마우스가 롤링 배너 밖으로 나가는 경우 롤링 효과 재시작 this._$rolling.mouseleave(function () &#123; objThis.startAutoPlay(); &#125;);&#125;// 롤링 효과 정지ChildRollingBanner.prototype.stopAutoPlay=function() &#123; if (this._timerID != -1) &#123; clearInterval(this._timerID); this._timerID = -1; &#125;&#125; 설명 17번 라인: 신규로 stopAutoPlay() 메서드를 추가한 후 타이머를 멈추는 코드를 작성합니다. 2번 라인: 신규로 이벤트를 등록하기 위해 _initEvent() 메서드를 오버라이드 합니다. 3번 라인: 부모의 _initEvent() 메서드를 호출해 줍니다. 6번 라인: 마우스가 롤링 배너 안으로 들어오는 경우 롤링 배너를 멈추기 위해 _$rolling 요소에 mouseenter 이벤트를 추가한 후 stopAutoPlay() 메서드를 호출해 줍니다. 11번 라인: 마우스가 롤링 배너 밖으로 나가는 경우 멈춰있는 롤링 배너를 다시 동작할 수 있게 _$rolling 요소에 mouseleave 이벤트를 추가한 후 startAutoPlay() 메서드를 호출해 줍니다. 코드를 모두 입력했다면 정상적으로 동작하는지 실행해 보겠습니다. 실행한 후 마우스 커서를 두 번째 롤링 배너 위치에 올려 롤링 배너가 멈추는지 확인해 보세요.소스코드 다운받기 어떤가요? 정상적으로 동작하죠!? 이처럼 클래스 상속을 활용하면 기능을 재사용할 수 있을 뿐만 아니라 확장할 수도 있습니다. 지금까지 만든 내용을 UML로 요약하면 다음과 같이 표현할 수 있습니다. 롤링 배너 ver 4.0: 다형성과 합성 활용이번 미션에서는 객체지향 프로그래밍의 가장 핵심적인 기능인 다형성과 합성을 활용한 기능 확장 방법을 학습합니다. 다형성과 합성의 기능을 다시 한 번 확인할 수 있는 좋은 예제가 될 것입니다. 미션 소개 및 미리보기이번 미션은 실행화면처럼 기존 롤링 배너에 3개의 롤링효과를 추가한 후 원하는 효과를 선택해서 사용할 수 있게 하는 미션입니다. 이번 미션을 정확하게 이해하기 위해 이미 구현이 돼 있는 파일을 보여드리겠습니다. 실행화면을 살펴보면 첫 번째 롤링 배너는 기존 롤링 효과를 가지고 있습니다. 두 번째는 위에서 아래로 롤링됩니다. 그리고 다음 줄의 첫 번째 롤링 배너는 오른쪽에서 왼쪽으로 롤링됩니다. 마지막 롤링 배너는 왼쪽에서 오른쪽으로 롤링됩니다. 요구사항요구사항을 정리하면 다음과 같습니다. 배너가 아래에서 위로 롤링되게 만들어 주세요. 배너가 위에서 아래로 롤링되게 만들어 주세요. 배너가 왼쪽에서 오른쪽으로 롤링되게 만들어 주세요. 배너가 오른쪽에서 왼쪽으로 롤링되게 만들어 주세요. 네 개의 롤링 효과를 선택해서 사용할 수 있게 만들어 주세요. 단, 롤링 효과는 다형성을 활용해 만들어 주세요. 레이아웃풀이 전 코드는 다음과 같습니다.소스코드 다운받기 핵심 내용 및 해결 방법 찾기미션을 풀기 위해서는 우선 요구사항을 철저하게 분석해야 합니다. 그리고 어떻게 해결할 것인지 해결 방법까지 찾아 내야 합니다. 특히 객체지향 프로그래밍을 하는 경우 객체와 객체 간의 관계까지 설계해야 합니다. 자, 그럼 지금부터 직접 여러 개의 롤링 효과를 어떻게 구현하고 어떻게 사용할 것인지 설계를 해보죠. 힌트를 살짝 드리자면 앞에서 다룬 다형성과 합성을 이용하면 됩니다. 그리고 선언 부분과 구현 부분을 나눠 설계하세요. … 그럼 설계한 내용과 이 포스팅 에서 설계한 내용을 비교해가면서 다음 내용을 봐주세요. 우선 설계에 앞서 구조가 앞의 다형성에서 풀었던 심플 갤러리 구조와 많이 닮아 있는 것을 확인할 수 있습니다. 심플 갤러리는 롤링 배너이고 4개의 정렬 기능은 4개의 롤링 효과와 동일합니다. 물론 구현 내용은 다르지만 구조는 완전히 닮아 있습니다. 그렇다면 설계도는 다음과 같은 구조가 될 것입니다. 이 설계도는 그저 추측으로만 그린 것이며 아직 검증되지 않은 상태임을 알려드립니다. 구조는 크게 롤링효과를 구현한 부분과 이 효과를 사용하는 부분으로 구성되어 있으며 이 둘은 전형적인 합성 관계로 연결 됩니다. 또한 네 개의 롤링 효과를 구현하고 있는 클래스는 롤링 효과 인터페이스로 만들어진 선언부분의 기능을 구현하고 있는 전형적인 다형성을 적용한 구조로 만들어져 있습니다. 풀이전 소스 다운받기 자! 그럼! 여기서 가상으로 잡은 설계도가 실제 구현 가능한지 기존 코드를 가지고 테스트해보죠. 테스트 하는 방법은 간단합니다. 기존 롤링 배너 클래스에 구현돼 있는 아래에서 위로 롤링되는 효과를 독립적인 객체로 만든 후 롤링 배너에서는 다시 이 롤링 효과를 합성해서 사용해보는 것이죠. 지금까지 내용을 구현 코드로 표현하면 다음과 같습니다. 설명 롤링 효과를 독립적인 클래스로 구현먼저 합성관계를 적용하기 위해 RollingBanner 클래스에 구현돼 있는 아래에서 위로 롤링되는 효과를 분리해서 신규 클래스에 구현해 줍니다. 클래스에 대한 인스턴스는 여러 개 생성하지 않을 것이기 때문에 프로토타입(prototype)을 활용한 클래스보다는 오브젝트 리터럴 방식으로 만드는 것이 더 효과적입니다. 롤링배너에서 롤링 효과를 합성해서 사용하기롤링 효과는 이제 독립적으로 구현된 상태이기 때문에 nextBanner() 메서드에서 기존 롤링 효과 코드를 모두 지워 줍니다. 그리고 그 자리에서 롤링 효과를 합성해서 사용합니다. 코드를 모두 입력했다면 롤링 효과가 정상적으로 동작하는지 실행해 보세요.풀이후 소스 다운받기 좋습니다. 상상했던 설계도가 실현가능한 설계도라고 판단이 됐기 때문에 이제 남은 작업은 설계도에 맞게 구현하는 작업만 남은 것 같군요. 구현하기지금부터 설계도에 맞게 구현을 시작해볼 텐데요. 구현은 이해를 돕기 위해 다음과 같이 몇 개로 나눠 진행해 보겠습니다. 롤링 효과 선언부분 만들기 롤링 효과 구현부분 만들기 롤링 배너에 롤링 효과 연결(합성)해서 사용하기 우선 롤링 효과 구현 부분을 먼저 만들 후 롤링 효과를 사용하는 부분을 만드는 순서로 진행하겠습니다. 1. 롤링 효과 선언부분 만들기다형성을 적용한 롤링 효과를 구현하기 위해서는 먼저 롤링 효과들이 공통적으로 가지고 있어야 하는 기능을 선언부분으로 만드는 작업입니다. 롤링 효과의 경우 효과를 처리하는 기능 하나만 선언부분으로 만들어 주면 됩니다. 메서드 이름은 effect로 정하겠습니다. 다음으로 메서드의 매개변수를 만들어 보죠. 앞의 핵심 내용에서 알아본 것처럼 네 가지 롤링 효과 모두 공통적으로 필요한 데이터는 현재 출력된 배너와 다음에 등장할 배너 그리고 롤링 속도 값입니다. 추가로 위에서 아래로 롤링되는 효과와 아래에서 위로 롤링되는 효과는 배너의 높이 값이 필요하고, 왼쪽에서 오른쪽으로 롤링되는 효과와 오른쪽에서 왼쪽으로 롤링되는 효과는 배너의 너비 값이 필요합니다. 매개변수가 많기 때문에 여러 개의 매개변수를 나누는 것보다 하나의 리터럴로 묶어 사용하는 것이 더 낫습니다. 정리하면 선언 부분은 다음과 같이 만들 수 있습니다. 12function effect(info) &#123;&#125; info 매개변수에는 다음과 같이 총 5개의 정보가 담긴 리터럴 오브젝트가 롤링 배너 객체에서 롤링 효과객체쪽으로 넘어오게 됩니다. 프로퍼티 설명 $inBanner 나타날 배너 $outBanner 사라질 배너 bannerWidth 배너 너비 bannerHeight 배너 높이 rollingSpeed 롤링 속도 아쉽게도 자바스크립트의 경우 다형성의 선언부분을 정의하는 문법인 인터페이스나 추상 클래스를 제공하지 않기 때문에 만들었다는 가정을 한다고 했습니다. 선언부분 소스코드 다운받기 2. 롤링 효과 구현부분 만들기이번에는 롤링 효과 선언부분에 맞게 실제 동작하는 코드를 구현하는 단계입니다. 구현해야 할 롤링 효과가 총 4개이니 오브젝트 리터럴 방식으로 다음과 같이 만들어 줍니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899// 아래에서 위로 롤링되는 효과BTRollingEffect = &#123; effect:function(info)&#123; // 다음 배너 위치 초기화 info.$inBanner.css(&#123; top:info.bannerHeight, opacity:0 &#125;) // 현재 배너 사라지게 하기 info.$outBanner.stop().animate(&#123; top:-info.bannerHeight, opacity:0 &#125;,info.speed); // 다음 배너 나타나게 하기 info.$inBanner.stop().animate(&#123; top:0, opacity:1 &#125;,info.speed); &#125;&#125;// 위에서 아래로 롤링되는 효과TBRollingEffect = &#123; effect:function(info)&#123; // 다음 배너 위치 초기화 info.$inBanner.css(&#123; top:-info.bannerHeight, opacity:0 &#125;) // 현재 배너 사라지게 하기 info.$outBanner.stop().animate(&#123; top:info.bannerHeight, opacity:0 &#125;,info.speed); // 다음 배너 나타나게 하기 info.$inBanner.stop().animate(&#123; top:0, opacity:1 &#125;,info.speed); &#125;&#125;// 왼쪽에서 오른쪽으로 롤링되는 효과LRRollingEffect = &#123; effect:function(info)&#123; // 다음 배너 위치 초기화 info.$inBanner.css(&#123; left:-info.bannerWidth, top:0, opacity:0 &#125;) // 현재 배너 사라지게 하기 info.$outBanner.stop().animate(&#123; left:info.bannerWidth, top:0, opacity:0 &#125;,info.speed); // 다음 배너 나타나게 하기 info.$inBanner.stop().animate(&#123; left:0, top:0, opacity:1 &#125;,info.speed); console.log(\"info - \",info); &#125;&#125;// 오른쪽에서 왼쪽으로 롤링되는 효과RLRollingEffect = &#123; effect:function(info)&#123; // 다음 배너 위치 초기화 info.$inBanner.css(&#123; left:info.bannerWidth, top:0, opacity:0 &#125;) // 현재 배너 사라지게 하기 info.$outBanner.stop().animate(&#123; left:-info.bannerWidth, top:0, opacity:0 &#125;,info.speed); // 다음 배너 나타나게 하기 info.$inBanner.stop().animate(&#123; left:0, top:0, opacity:1 &#125;,info.speed); &#125;&#125; 설명 2번 라인: 리터럴 오브젝트 방식으로 아래에서 위로 롤링되는 효과를 구현합니다. 25번 라인: 리터럴 오브젝트 방식으로 위에서 아래로 롤링되는 효과를 구현합니다. 48번 라인: 리터럴 오브젝트 방식으로 왼쪽에서 오른쪽으로 롤링되는 효과를 구현합니다. 75번 라인: 리터럴 오브젝트 방식으로 오른쪽에서 왼쪽으로 롤링되는 효과를 구현합니다. 3. 롤링 배너에 롤링 효과 연결(합성)해서 사용하기이번 단계에서는 롤링 배너 객체에 롤링 효과를 합성해 사용할 수 있게 만드는 작업을 구현해 보겠습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234$(function() &#123; // 인스턴스 생성 var rolling1 = new RollingBanner(\".banner1\", 2000,600, BTRollingEffect); var rolling2 = new RollingBanner(\".banner2\", 2000,600, TBRollingEffect); var rolling3 = new RollingBanner(\".banner3\", 2000,600, RLRollingEffect); var rolling4 = new RollingBanner(\".banner4\", 2000,600, LRRollingEffect);&#125;)function RollingBanner(selector, playSpeed, rollingSpeed, effect) &#123; // 프로퍼티 생성및 초기화 this._$banners = null; this._currentIndex = 0; this._timerID = -1; // step #02 this._bannerHeight=0; this._playSpeed = playSpeed; this._rollingSpeed = rollingSpeed; // 롤링효과 인스턴스를 저장할 변수 this._effect =effect; this._bannerWidth = 0; this._init(selector); this._initEvent();&#125;// 초기화및 롤링배너 시작RollingBanner.prototype._start = function() &#123; this._initBannerPos(); this.startAutoPlay();&#125;// 요소 초기화.RollingBanner.prototype._init = function(selector) &#123; this._$banners = $(selector).children(\"img\");&#125;// 이벤트 처리RollingBanner.prototype._initEvent = function() &#123; var objThis = this; this._$banners.eq(0).one(\"load\",function()&#123; objThis._bannerHeight= $(this).height(); // 배너 너비 구하기 objThis._bannerWidth = $(this).width(); objThis._start(); &#125;)&#125;// 배너 위치 초기화RollingBanner.prototype._initBannerPos = function() &#123; // 배너 위치를 화면에서 보이지 않게 숨기기 // step #02 this._$banners.css(\"top\", this._bannerHeight); // 0번째 배너 활성화 this._$banners.eq(this._currentIndex).css(\"top\", 0);&#125;RollingBanner.prototype.startAutoPlay = function() &#123; var objThis = this; // 타이머가 두번 이상 실행되지 않게 조건 처리 if (this._timerID == -1) &#123; this._timerID = setInterval(function() &#123; objThis.nextBanner(); &#125;, this._playSpeed); &#125;&#125;// 다음 배너 활성화RollingBanner.prototype.nextBanner = function() &#123; // 현재 index값 구하기 var outIndex = this._currentIndex; // 다음 배너 index값 구하기 this._currentIndex++; // 마지막 배너까지 롤링한 경우 다시 0번째부터 롤링될 수 있게 인덱스 값을 0으로 설정 if (this._currentIndex &gt;= this._$banners.length) &#123; this._currentIndex = 0; &#125; // 현재 배너 구하기 var $outBanner = this._$banners.eq(outIndex); // 다음 배너 구하기 var $inBanner = this._$banners.eq(this._currentIndex); console.log('___________', outIndex, this._currentIndex); /* // 롤링 준비-다음 배너 위치 초기화 $inBanner.css(&#123; top:this._bannerHeight, opacity:0 &#125;) // 현재 배너 사라지게 하기 $outBanner.stop().animate(&#123; top:-this._bannerHeight, opacity:0 &#125;,this._rollingSpeed); // 다음 배너 나타나게 하기 $inBanner.stop().animate(&#123; top:0, opacity:1 &#125;,this._rollingSpeed); */ if(this._effect)&#123; // 롤링 효과로 넘길 데이터 만들기 var info = &#123; \"$inBanner\":$inBanner, \"$outBanner\":$outBanner, bannerWidth:this._bannerWidth, bannerHeight:this._bannerHeight, speed:this._rollingSpeed &#125; // 롤링 효과 호출 this._effect.effect(info); &#125;else&#123; console.log(\"아직 롤링 효과가 연결되지 않았습니다.\"); &#125;&#125;// 아래에서 위로 롤링되는 효과BTRollingEffect = &#123; effect:function(info)&#123; // 다음 배너 위치 초기화 info.$inBanner.css(&#123; top:info.bannerHeight, opacity:0 &#125;) // 현재 배너 사라지게 하기 info.$outBanner.stop().animate(&#123; top:-info.bannerHeight, opacity:0 &#125;,info.speed); // 다음 배너 나타나게 하기 info.$inBanner.stop().animate(&#123; top:0, opacity:1 &#125;,info.speed); &#125;&#125;// 위에서 아래로 롤링되는 효과TBRollingEffect = &#123; effect:function(info)&#123; // 다음 배너 위치 초기화 info.$inBanner.css(&#123; top:-info.bannerHeight, opacity:0 &#125;) // 현재 배너 사라지게 하기 info.$outBanner.stop().animate(&#123; top:info.bannerHeight, opacity:0 &#125;,info.speed); // 다음 배너 나타나게 하기 info.$inBanner.stop().animate(&#123; top:0, opacity:1 &#125;,info.speed); &#125;&#125;// 왼쪽에서 오른쪽으로 롤링되는 효과LRRollingEffect = &#123; effect:function(info)&#123; // 다음 배너 위치 초기화 info.$inBanner.css(&#123; left:-info.bannerWidth, top:0, opacity:0 &#125;) // 현재 배너 사라지게 하기 info.$outBanner.stop().animate(&#123; left:info.bannerWidth, top:0, opacity:0 &#125;,info.speed); // 다음 배너 나타나게 하기 info.$inBanner.stop().animate(&#123; left:0, top:0, opacity:1 &#125;,info.speed); console.log(\"info - \",info); &#125;&#125;// 오른쪽에서 왼쪽으로 롤링되는 효과RLRollingEffect = &#123; effect:function(info)&#123; // 다음 배너 위치 초기화 info.$inBanner.css(&#123; left:info.bannerWidth, top:0, opacity:0 &#125;) // 현재 배너 사라지게 하기 info.$outBanner.stop().animate(&#123; left:-info.bannerWidth, top:0, opacity:0 &#125;,info.speed); // 다음 배너 나타나게 하기 info.$inBanner.stop().animate(&#123; left:0, top:0, opacity:1 &#125;,info.speed); &#125;&#125; [객체지향 프로그래밍 기초] 절차지향 프로그래밍 VS 객체지향 프로그래밍 [객체지향 프로그래밍 기초] 객체지향 프로그래밍의 특징 [객체지향 프로그래밍 기초] 객체지향 프로그래밍 언어에서 제공하는 기본 기능 [객체지향 프로그래밍 특징] 추상화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서 추상화 [객체지향 프로그래밍 특징] 캡슐화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서의 캡슐화 [객체지향 프로그래밍 특징] 클래스 상속 소개 [객체지향 프로그래밍 특징] 클래스 상속 기능 [객체지향 프로그래밍 특징] 자바스크립트에서 클래스 상속 [객체지향 프로그래밍 특징] 자식 클래스와 부모 클래스 연동 처리 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버라이드 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버로딩 [객체지향 프로그래밍 특징] constructor 프로퍼티 활용 [객체지향 프로그래밍 특징] 클래스 상속 규칙 [객체지향 프로그래밍 특징] 다형성 소개 [객체지향 프로그래밍 특징] 다형성과 데이터 타입과의 관계 [객체지향 프로그래밍 특징] 자바스크립트에서 다형성 합성 소개 클래스 상속 VS 합성","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"},{"name":"객체지향 프로그래밍","slug":"JS/js-학습/객체지향-프로그래밍","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"}],"tags":[]},{"title":"합성 소개","slug":"합성-소개","date":"2018-03-27T23:51:24.000Z","updated":"2018-03-30T00:53:06.255Z","comments":true,"path":"2018/03/28/합성-소개/","link":"","permalink":"https://recoveryman.github.io/2018/03/28/%ED%95%A9%EC%84%B1-%EC%86%8C%EA%B0%9C/","excerpt":"","text":"합성이란?합성(Composition)이란 단어에서도 짐작할 수 있는 것처럼 필요한 기능을 직접 구현하는 것이 아니라 필요한 기능을 구현하고 있는 객체와 연결(합성)해서 기능을 사용하는 것을 의미합니다. 이때 기능을 구현하고 있는 객체와 기능을 사용하는 객체 간의 관계를 합성관계라고 부릅니다. 이해를 돕기 위해 예제를 가지고 설명해 보겠습니다. 예제예를 들어 이미지를 가로로 정렬하는 기능만을 가진 아주 심플한 갤러리를 만든다고 해보죠.여러 가지 풀이 방법이 있겠지만 여기에서는 합성을 사용하지 않은 풀이법과 합성을 사용한 방법으로 풀어보겠습니다. 합성을 사용하지 않은 풀이 합성을 사용한 풀이두 번째 방법은 이미지를 가로로 정렬하는 기능을 SimpleGallery 내부에 구현하는 것이 아니라 독립적인 객체(HAlignable)로 구현한 후 연결(합성)해서 사용하는 것입니다. 코드로 표현하면 다음과 같습니다. 바로 이처럼 특정 기능을 직접 구현하지 않고 기능을 빌렷거 사용하는 방식을 합성이라고 합니다. 참고로 풀이 내용을 UML로 표현하면 다음과 같습니다. [객체지향 프로그래밍 기초] 절차지향 프로그래밍 VS 객체지향 프로그래밍 [객체지향 프로그래밍 기초] 객체지향 프로그래밍의 특징 [객체지향 프로그래밍 기초] 객체지향 프로그래밍 언어에서 제공하는 기본 기능 [객체지향 프로그래밍 특징] 추상화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서 추상화 [객체지향 프로그래밍 특징] 캡슐화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서의 캡슐화 [객체지향 프로그래밍 특징] 클래스 상속 소개 [객체지향 프로그래밍 특징] 클래스 상속 기능 [객체지향 프로그래밍 특징] 자바스크립트에서 클래스 상속 [객체지향 프로그래밍 특징] 자식 클래스와 부모 클래스 연동 처리 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버라이드 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버로딩 [객체지향 프로그래밍 특징] constructor 프로퍼티 활용 [객체지향 프로그래밍 특징] 클래스 상속 규칙 [객체지향 프로그래밍 특징] 다형성 소개 [객체지향 프로그래밍 특징] 다형성과 데이터 타입과의 관계 [객체지향 프로그래밍 특징] 자바스크립트에서 다형성 합성 소개 클래스 상속 VS 합성","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"},{"name":"객체지향 프로그래밍","slug":"JS/js-학습/객체지향-프로그래밍","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"}],"tags":[]},{"title":"[객체지향 프로그래밍 특징] 자바스크립트에서 다형성","slug":"객체지향-프로그래밍-특징-자바스크립트에서-다형성","date":"2018-03-19T15:00:58.000Z","updated":"2018-03-30T00:53:10.914Z","comments":true,"path":"2018/03/20/객체지향-프로그래밍-특징-자바스크립트에서-다형성/","link":"","permalink":"https://recoveryman.github.io/2018/03/20/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-%EB%8B%A4%ED%98%95%EC%84%B1/","excerpt":"","text":"먼저 일반 객체지향 프로그래밍 언어에서 다형성을 구현하는 방법을 살펴본 후 자바스크립트에서 다형성을 구현하는 방법을 살펴보겠습니다. 일반 객체지향 프로그래밍의 다형성 관련 문법일반적으로 다형성은 선언부분과 구현부분으로 나눠 구성되며 객체지향 프로그래밍 문법 3가지는 다음과 같이 사용됩니다. 다형성 선언부분 다형성 구현부분 인터페이스(interface)와 추상클래스(abstract class) 클래스(class) 마지막으로 자바와 PHP 프로그래밍 언어에서는 어떤 식으로 다형성을 구현하는지 살짝 구경해보죠. 방금 알아본 것처럼 일반 객체지향 프로그래밍에서는 다형성을 선언부분과 구현부분을 완전히 분리해서 구현할 수 있다는 것을 알 수 있습니다. 자! 그럼 이어서 자바스크립트에서는 과연 어떻게 다형성을 구현하는지 알아보죠. 자바스크립트에서 다형성자바스크립트에서 다형성 지원 유무앞에서 확인한 것처럼 아쉽게도 자바스크립트는 인터페이스와 추상 클래스 그리고 엄격한 데이터 타입체크 등의 다형성과 관련된 문법은 전혀 지원하지 않습니다. 그렇기 때문에 그저 자바스크립트에는 다형성을 지원한다는 가정하에 다형성스럽게 코드를 만드는 것이죠. 그렇다고 너무 실망하지 마세요. 문법만 제공하지 않을 뿐 다형성 개념을 사용해 코드를 만들게 되면 지금까지 겪어보지 못한 진정한 프로그래밍의 참맛을 느끼게 될 것입니다. 좀 더 자랑해 보자면 프로그래밍 실력은 다형성을 사용하기 전과 후로 나눠진다고 해도 과언이 아닐 정도로 아주 놀라운 기능입니다. 문법계속해서 언급한 것처럼 자바스크립트는 문법적으로 다형성과 관련된 기능을 전혀 제공하지 않습니다. 그냥 다형성을 지원한다 생각하고 사용하는 거죠. 자바스크립트에서 다형성은 일반적으로 다음과 같은 구조를 갖게 됩니다. 심플 아이템 갤러리 만들기아래에 등장하는 풀이 전 코드는 가로로 정렬하는 기능만 가지고 있는 심플 갤러리 입니다. 이 코드를 수정해 다음 요구사항에 맞게 동작하도록 만들어 주세요. 요구사항 가로정렬 버튼 클릭 시 아이템을 가로로 정렬해 주세요. 세로정렬 버튼 클릭 시 아이템을 세로로 정렬해 주세요. 랜덤정렬 버튼 클릭 시 아이템을 랜덤하게 정렬해 주세요. 바둑판정렬 버튼 클릭 시 아이템을 3개씩 정렬해 주세요. 단, 풀이는 다형성을 사용한 경우와 그렇지 않은 경우 두 가지로 나눠 구현해 주세요. 화면 구성 풀이 전 코드 1234567891011121314151617181920212223242526272829303132333435$(function() &#123; // 아이템 찾기. var item1 = new SimpleGallery(\".item_wrap li\"); // 버튼 클릭 이벤트 실행. $(\".btnHorizontal\").click(function() &#123; item1.show(); &#125;);&#125;)// 심플갤러리 클래스function SimpleGallery(selector)&#123; this.$items = null; this.init(selector);&#125;// 요소 초기화SimpleGallery.prototype.init=function(selector)&#123; this.$items = $(selector);&#125;// 아이템을 가로로 정렬SimpleGallery.prototype.show=function()&#123; // 아이템 개수 구하기. var length = this.$items.length; // 아이템 배열하기. for (var i = 0; i &lt; length; i++) &#123; var x = i * 200; this.$items.eq(i).css(&#123; left : x &#125;); &#125;&#125; 소스코드 다운받기 요구사항에 맞게 구현해 보겠습니다. 구현하기지금부터 구현을 해볼 텐데요. 다형설의 장점을 확인하기 위해 다형성을 적용하지 않은 경우와 다형성을 적용한 경우로 나눠 구현해 보겠습니다. 다형성을 적용하지 않은 풀이전체적인 풀이 내용을 간단하게 요약하자면 다형성을 적용하지 않은 풀이는 모든 기능을 하나의 클래스에 구현하는 구조입니다. 즉, 클래스 단위 프로그래밍 이라고 생각하면 됩니다. 풀이는 다음과 같이 3단계로 나눠 진행하겠습니다. 정렬 기능 구현 정렬 기능 호출 정리 정렬 기능 구현먼저 구현해야 할 4가지 기능을 각각의 메서드를 만들어 구현하는 작업을 진행하겠습니다. 풀이 순서에 맞게 다음 소스 코드를 입력해 주세요. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106$(function() &#123; // 아이템 찾기. var item1 = new SimpleGallery(\".item_wrap li\"); // 버튼 클릭 이벤트 실행. $(\".btnHorizontal\").click(function() &#123; item1.show(); &#125;);&#125;)// 심플갤러리 클래스function SimpleGallery(selector)&#123; this.$items = null; this.init(selector);&#125;// 요소 초기화SimpleGallery.prototype.init=function(selector)&#123; this.$items = $(selector);&#125;// 아이템을 가로로 정렬SimpleGallery.prototype.show = function(type) &#123; switch(type) &#123; case \"horizontal\": this.alignHorizontal(); break; case \"vertical\": this.alignVertical(); break; case \"random\": this.alignRandom(); break; case \"grid\": this.alignGrid(); break; default: this.alignHorizontal(); &#125;&#125;// 가로 정렬 처리SimpleGallery.prototype.alignHorizontal = function() &#123; // 아이템 개수 구하기 var length = this.$items.length; // 아이템 배열하기 for(var i=0; i&lt;length; i++) &#123; var x = i * 200; this.$items.eq(i).css(&#123; left: x, top: 0 &#125;); &#125;&#125;// 세로 정렬 처리SimpleGallery.prototype.alignVertical = function() &#123; // 아이템 개수 구하기 var length = this.$items.length; // 아이템 배열하기 for(var i=0; i&lt;length; i++) &#123; var y = i * 200; this.$items.eq(i).css(&#123; left: 0, top: y &#125;); &#125;&#125;// 랜덤 정렬 처리SimpleGallery.prototype.alignRandom = function() &#123; // 아이템 개수 구하기 var length = this.$items.length; // 아이템 배열하기 for(var i=0; i&lt;length; i++) &#123; var x = 400 * Math.random(); var y = 400 * Math.random(); this.$items.eq(i).css(&#123; left: x, top: y &#125;); &#125;&#125;// 바둑판식 정렬 처리SimpleGallery.prototype.alignGrid = function() &#123; // 아이템 개수 구하기 var length = this.$items.length; var count = 3; // 아이템 배열하기 for(var i=0; i&lt;length; i++) &#123; var x = (i % count) * 200; var y = parseInt(i / count) * 200; this.$items.eq(i).css(&#123; left: x, top: y &#125;); &#125;&#125; 설명 43번 라인: 먼저 show() 메서드에 구현돼 있던 가로정렬 기능을 alignHorizontal()이라는 메서드를 신규로 만들어 포장해 줍니다. 59, 75, 91번 라인: 세로정렬 기능과 랜덤정렬 기능 그리고 바둑판식정렬 기능을 신규 메서드로 추가해 구현해 줍니다. 23번 라인: 매개변수 값에 따라 정렬기능이 호출될 수 있게 show() 메서드에 매개변수를 추가한 후 switch 조건문을 활용해 매개변수 값에 따라 정렬 기능을 호출해 줍니다. 소스코드 다운받기 코드를 모두 입력했다면 정상적으로 동작하는지 실행해보죠. 아직 각각의 정렬버튼에 기능을 연결시키지 않았기 때문에 실행결과는 기존과 동일하게 실행될 것입니다. 지금까지 내용을 UML로 표현하면 다음과 같습니다. 정렬 기능 호출이번 단계에서는 정렬 버튼 클릭 시 해당 정렬 기능을 실행될 수 있게 만들어 주겠습니다. 123456789101112131415161718192021$(function() &#123; // 아이템 찾기. var item1 = new SimpleGallery(\".item_wrap li\"); // 버튼 클릭 이벤트 실행. $(\".btnHorizontal\").click(function() &#123; item1.show(\"horizontal\"); &#125;); $(\".btnVertical\").click(function() &#123; item1.show(\"vertical\"); &#125;); $(\".btnRandom\").click(function() &#123; item1.show(\"random\"); &#125;); $(\".btnGrid\").click(function() &#123; item1.show(\"grid\"); &#125;);&#125;) 설명각각의 버튼에 click 이벤트 리스너를 등록한 후 각 버튼에 맞게 앞 단계에서 작성한 메서드를 호출해 줍니다. 모든 코드를 입력했다면 요구사항에 맞게 정상적으로 동작하는지 실행해 보겠습니다. 이렇게 다형성을 적용하지 않은 방식으로 예제를 진행했습니다.소스코드 다운받기 정리마지막으로 지금까지 작성한 코드를 정리해보는 시간을 가져보겠습니다. 먼저 지금까지 작성한 코드를 요약해서 표현하면 다음과 같습니다. 위의 코드를 보고 “어! 이게 문제라는 건가요? 괜찮은 코드 아닌가요?”라는 생각을 할 수도 있을 것 같네요. 네! 물론 좋은 코드입니다. 하지만 코드를 자세히 살펴보면 가장 큰 특징은 네 개의 아이템 정렬기능이 모두 SimpleGallery 클래스 내부에 구현되어 있다는 점입니다. 이로써 다음과 같은 문제점을 발견할 수 있습니다. 사용하지 않는 코드가 많다.세로, 가로, 바둑판식, 랜덤 아이템 정렬까지 네 개의 아이템 정렬 기능이 모두 SimpleGallery 클래스에 구현되어 있기 때문에 기능 하나를 선택하면 나머지 세 개의 기능은 사용하고 있지 않게 되어 불필요한 코드가 됩니다. 코드 재사용성이 떨어진다SimpleGallery 내부에 아이템 정렬 기능이 모두 구현되어 있기 때문에 만약 아이템 정렬 기능을 독립적으로 사용하고 싶어도 사용할 수가 없습니다. 원하는 정렬기능을 사용하려면 반드시 SimpleGallery 클래스의 인스턴스를 만들어야 합니다. 유지보수가 어렵다네 가지 정렬 기능 이외에 새로운 아이템 정렬 기능을 추가해야 하는 경우 SimpleGallery 클래스에 추가해서 구현해야 하기 때문에 클래스 기능이 점점 거대해져 유지보수가 어려워집니다. 이렇게 해서 지금까지 다형성을 적용하지 않은 경우에 대해 자세히 알아봤습니다. 자! 그럼 이어서 다형성을 적용해 코드를 만들어보죠. 참고로 미리 언급하자면 일반적으로 다형성 적용 전 풀이와 같이 switch를 활용해 여러 조건을 처리하는 코드는 다형성으로 바꿀 수 있는 전형적인 경우입니다. 다형성을 적용한 경우이번 풀이 경우에도 이해를 돕기 위해 다음과 같이 5단계로 나눠 진행하겠습니다. 다형성 선언부분 만들기 다형성 구현부분 만들기(정렬 기능 구현) 다형성과 합성을 활용한 정렬 기능 연결 정렬 기능 호출 독립적으로 정렬 기능을 사용할 수 있는지 확인하기 정리 다형성 선언부분 만들기다형성을 만드는 첫 번째 작업은 구현부분에 공통적으로 구현해야 하는 기능을 선별해 선언부분으로 만드는 작업입니다. 심플 아이템 갤러리의 경우 정렬기능을 선언부분으로 만들어 주면 되겠죠?! 123function align($items) &#123; // 이곳에 정렬 기능을 구현해주면 됩니다.&#125; 정리하자면 선언부분은 앞에서 알아본 것처럼 반드시 지켜야할 약속으로써 구현부분에서는 반드시 선언부분에 정의되어 있는 메서드의 이름과 매개변수 개수까지 동일하게 메서드를 정의해서 구현해야 합니다. 또한 자바스크립트의 경우 다형성의 선언부분을 정의하는 문법을 제공하지 않기 때문에 만들었다는 가정을 한다고 했습니다. 다형성 구현부분 만들기이번에는 선언부분에 맞게 코드를 구현하는 단계입니다. 아래 코드와 같이 네 개의 정렬 기능 클래스를 생성한 후 선언부분에 작성되 메서드와 동일하게 메서드를 추가해 정렬 기능을 구현해 줍니다. 인스턴스는 여러 개 생성할 필요 없이 하나만 생성하면 되니 프로토타입 방식보다 리터럴 방식을 이용해 클래스를 만들었습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 가로 정렬 기능var horizontalAlignable = &#123; align : function($items) &#123; // 아이템 개수 구하기. var length = $items.length; // 아이템 배열하기. for (var i = 0; i &lt; length; i++) &#123; var x = i * 200; $items.eq(i).css(&#123; left : x, top : 0 &#125;); &#125; &#125;&#125;// 세로 정렬 기능var verticalAlignable = &#123; align : function($items) &#123; // 아이템 개수 구하기. var length = $items.length; // 아이템 배열하기. for (var i = 0; i &lt; length; i++) &#123; var y = i * 200; $items.eq(i).css(&#123; left : 0, top : y &#125;); &#125; &#125;&#125;// 랜덤 정렬 기능var randomAlignable = &#123; align : function($items) &#123; // 아이템 개수 구하기. var length = $items.length; // 아이템 배열하기. for (var i = 0; i &lt; length; i++) &#123; var x = 400 * Math.random(); var y = 400 * Math.random(); $items.eq(i).css(&#123; left : x, top : y &#125;); &#125; &#125;&#125;// 바둑판식 정렬 기능var gridAlignable = &#123; align : function($items) &#123; // 아이템 개수 구하기. var length = $items.length; var count = 3; // 아이템 배열하기. for (var i = 0; i &lt; length; i++) &#123; var x = (i % count) * 200; var y = parseInt(i / count) * 200; $items.eq(i).css(&#123; left : x, top : y &#125;); &#125; &#125;&#125; 소스코드 다운받기 다형성과 합성을 활용한 정렬 기능 연결이제 SimpleGallery 클래스의 show() 메서드에 다형성을 적용해 주기 위해 정렬기능을 구현한 클래스의 인스턴스를 받을 수 있는 매개변수를 추가해 줍니다. 1234// 아이템 정렬 기능 실행SimpleGallery.prototype.show = function(alignable) &#123; alignable.align(this.$items);&#125; 정렬 기능 버튼이 눌릴 때 선택한 정렬 기능이 alignable 매개변수로 넘어와 사용될 것입니다. 즉 합성을 사용해 정렬 기능을 빌려 사용하게 되죠. 소스코드 다운받기 정렬 기능 호출정렬 버튼 클릭 시 버튼에 맞는 아이템 정렬 기능의 인스턴스를 매개변수 값으로 show() 메서드를 호출해 줍니다. 123456789101112131415161718192021$(function() &#123; // 아이템 찾기. var item1 = new SimpleGallery(\".item_wrap li\"); // 버튼 클릭 이벤트 실행. $(\".btnHorizontal\").click(function() &#123; item1.show(horizontalAlignable); &#125;); $(\".btnVertical\").click(function() &#123; item1.show(verticalAlignable); &#125;); $(\".btnRandom\").click(function() &#123; item1.show(randomAlignable); &#125;); $(\".btnGrid\").click(function() &#123; item1.show(gridAlignable); &#125;);&#125;) 자! 드디어 모든 코드가 완성되었습니다. 코드를 모두 입력했다면 정상적으로 동작하는지 실행해 보세요. 다형성이 적용되어 깔끔하기 그지없는 코드가 멋지게 동작하는 것을 볼 수 있을 것입니다.소스코드 다운받기 독립적으로 정렬 기능을 사용 할 수 있는지 확인하기마지막으로 테스트 하나를 더 해보죠. 정렬 기능이 SimpleGallery 내부에 구현돼 있지 않고 외부에 독립적으로 구현되어 있기 때문에 랜덤 정렬기능을 다음과 같이 독립적으로 사용할 수 있습니다. 1234$(function() &#123; // 독립적으로 랜덤 정렬 기능 사용 randomAlignable.align($('.item_wrap li'));&#125;) 소스코드 다운받기 정리가장 큰 특징은 아이템 정렬 기능이 SimpleGallery 클래스 내부에 구현돼 있지 않고 각각 독립적인 클래스로 구현되어 있다는 점입니다. 이로써 다형성을 적용해 구현한 심플 갤러리는 다음과 같은 장점이 있습니다. 가벼워진 코드SimpleGallery 클래스 내부에 아이템 정렬 기능을 직접 구현하지 않고 모두 외부에 구현되어 있기 때문에 엄청 가벼워집니다. 이와 동시에 코드를 간결하게 만들 수 있습니다. 코드 재사용성이 높아진다아이템 정렬 기능이 각각 독립적으로 구현되어 있어서 SimpleGallery의 도움 없이 아이템 정렬 기능을 사용할 수 있습니다. 예를 들어 세로 아이템 정렬기능을 사용하고 싶은 경우 다음과 같이 해주면 됩니다.12var vAlign = new 세로 아이템 정렬하기 클래스();vAlign.아이템정렬(아이템목록); 유지보수가 쉬워짐새로운 아이템 정렬 기능을 추가해야 하는 경우 아이템 정렬 기능 인터페이스에 맞게 클래스를 만들어 SimpleGallery에 연결해서 사용하면 됩니다. SimpleGallery 클래스를 전혀 수정하지 않고 말이지요. 이처럼 다형성을 이용하면 유지보수와 확장성이 엄청 좋은 코드를 만들 수 있습니다. [객체지향 프로그래밍 기초] 절차지향 프로그래밍 VS 객체지향 프로그래밍 [객체지향 프로그래밍 기초] 객체지향 프로그래밍의 특징 [객체지향 프로그래밍 기초] 객체지향 프로그래밍 언어에서 제공하는 기본 기능 [객체지향 프로그래밍 특징] 추상화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서 추상화 [객체지향 프로그래밍 특징] 캡슐화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서의 캡슐화 [객체지향 프로그래밍 특징] 클래스 상속 소개 [객체지향 프로그래밍 특징] 클래스 상속 기능 [객체지향 프로그래밍 특징] 자바스크립트에서 클래스 상속 [객체지향 프로그래밍 특징] 자식 클래스와 부모 클래스 연동 처리 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버라이드 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버로딩 [객체지향 프로그래밍 특징] constructor 프로퍼티 활용 [객체지향 프로그래밍 특징] 클래스 상속 규칙 [객체지향 프로그래밍 특징] 다형성 소개 [객체지향 프로그래밍 특징] 다형성과 데이터 타입과의 관계 [객체지향 프로그래밍 특징] 자바스크립트에서 다형성 합성 소개 클래스 상속 VS 합성","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"},{"name":"객체지향 프로그래밍","slug":"JS/js-학습/객체지향-프로그래밍","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"}],"tags":[]},{"title":"[객체지향 프로그래밍 특징] 다형성과 데이터 타입과의 관계","slug":"객체지향-프로그래밍-특징-다형성과-데이터-타입과의-관계","date":"2018-03-18T14:16:24.000Z","updated":"2018-03-30T00:53:14.261Z","comments":true,"path":"2018/03/18/객체지향-프로그래밍-특징-다형성과-데이터-타입과의-관계/","link":"","permalink":"https://recoveryman.github.io/2018/03/18/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95-%EB%8B%A4%ED%98%95%EC%84%B1%EA%B3%BC-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85%EA%B3%BC%EC%9D%98-%EA%B4%80%EA%B3%84/","excerpt":"","text":"일반 객체지향 프로그래밍에서 데이터 타입의 의미자바스크립트에서는 데이터 타입이 중요하게 사용되진 않지만 일반 프로그래밍에서 데이터 타입은 정말 중요합니다. 먼저 자바스크립트에서 변수를 선언할 때 데이터 타입을 작성하진 않지만 일반 프로그래밍 에서는 대부분 변수에 저장할 데이터 타입을 작성합니다. 예를 들어 자바 언어에서 문자열 데이터를 저장할 변수를 만든다면 다음과 같이 만들 수 있습니다. 이때 자바스크립트와 다른 점은 자바에서는 문자열 변수를 만들었다면 해당 변수에는 반드시 문자열 데이터를 넣어야 합니다. 만약 숫자 데이터를 넣는 경우 에러가 발생합니다. 이와 같은 개념은 함수와 메서드에서도 그대로 사용됩니다. 만약 함수를 만든 후 매개변수에 문자열 타입으로 선언하는 경우에도 문자열 데이터 값으로 메서드를 호출해야 하지 다른 값으로 하는 경우 에러가 발생합니다. 이처럼 일반 프로그래밍에서의 데이터 타입은 일종의 반드시 지켜야 할 규약처럼 사용됩니다. 일반 객체지향 프로그래밍에서 다형성의 의미객체지향 프로그래밍에서는 데이터 타입의 규약을 활용해 다형성을 구현합니다. 예를 들어 앞에서 구현한 심플 이미지 갤러리를 자바 객체지향 프로그래밍으로 구현하면 다음과 같이 표현할 수 있습니다. 이때 정렬기능 메서드의 매개변수의 데이터 타입으로 IAlignable 인터페이스가 선언되었기 때문에 매개 변수로 넘길 수 있는 값은 오직 IAlignable 인터페이스를 구현하고 있는 클래스의 인스턴스여야 합니다. 만약 숫자 값이나 문자열 또는 다른 클래스의 인스턴스를 값으로 넘기는 경우 에러가 발생합니다. 이와 같은 규칙은 상속의 부모클래스와 자식 클래스에서도 적용됩니다. 만약 다음과 같이 특정 클래스 타입으로 변수나 매개변수가 만들어져 있는 경우 데이터 값으로 넘길 수 있는 값은 특정 클래스와 특정 클래스를 상속받은 자식 클래스의 인스턴스뿐입니다. 그럼 다음과 같이 자식 클래스가 매개변수 데이터 타입으로 선언된 경우 부모 클래스의 인스턴스를 넘기는 경우 어떻게 될까요? 부모 클래스는 자식 클래스가 아니기 때문에 바로 에러가 발생합니다. 정리지금까지의 내용을 정리해보면 일반 객체지향 프로그래밍에서 데이터 타입은 다음과 같은 규칙을 가지고 있습니다. 변수 및 매개변수 선언 시 특정 인터페이스 타입인 경우 반드시 특정 인터페이스를 구현한 클래스의 인스턴스만을 저장하거나 매개변수 값으로 넘길 수 있습니다. 변수 및 매개변수 선언 시 특정 클래스 타입인 경우 반드시 특정 클래스 또는 특정 클래스를 상속받은 자식 클래스의 인스턴스만을 저장하거나 매개변수 값으로 넘길 수 있습니다. [객체지향 프로그래밍 기초] 절차지향 프로그래밍 VS 객체지향 프로그래밍 [객체지향 프로그래밍 기초] 객체지향 프로그래밍의 특징 [객체지향 프로그래밍 기초] 객체지향 프로그래밍 언어에서 제공하는 기본 기능 [객체지향 프로그래밍 특징] 추상화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서 추상화 [객체지향 프로그래밍 특징] 캡슐화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서의 캡슐화 [객체지향 프로그래밍 특징] 클래스 상속 소개 [객체지향 프로그래밍 특징] 클래스 상속 기능 [객체지향 프로그래밍 특징] 자바스크립트에서 클래스 상속 [객체지향 프로그래밍 특징] 자식 클래스와 부모 클래스 연동 처리 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버라이드 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버로딩 [객체지향 프로그래밍 특징] constructor 프로퍼티 활용 [객체지향 프로그래밍 특징] 클래스 상속 규칙 [객체지향 프로그래밍 특징] 다형성 소개 [객체지향 프로그래밍 특징] 다형성과 데이터 타입과의 관계 [객체지향 프로그래밍 특징] 자바스크립트에서 다형성 합성 소개 클래스 상속 VS 합성","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"},{"name":"객체지향 프로그래밍","slug":"JS/js-학습/객체지향-프로그래밍","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"}],"tags":[]},{"title":"[객체지향 프로그래밍 특징] 다형성 소개","slug":"객체지향-프로그래밍-특징-다형성-소개","date":"2018-03-17T11:26:45.000Z","updated":"2018-03-30T00:53:20.802Z","comments":true,"path":"2018/03/17/객체지향-프로그래밍-특징-다형성-소개/","link":"","permalink":"https://recoveryman.github.io/2018/03/17/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95-%EB%8B%A4%ED%98%95%EC%84%B1-%EC%86%8C%EA%B0%9C/","excerpt":"","text":"다형성 이란?다형성은 특정 기능을 선언(설계)부분과 구현(동작)부분으로 분리한 후 구현부분을 다양한 방법으로 만들어 선택해서 사용할 수 있게 하는 기능입니다. 여기서 선언부분은 인터페이스라고도 합니다. 좀더 자세히 설명하면 선언 부분은 구현코드가 전혀 없는 텅 빈 상태이며 일종의 지켜야 할 약속(규약)으로 가득 찬 일종의 규약 문서입니다. 개발자는 문제를 해결하는 구현 코드를 선언부분에 맞게 구현하기만 하면 됩니다. 즉 선언부분과 구현부분은 1:N의 다형성 관계가 형성됩니다. 그럼 이해를 돕기 위해 다형성에 대한 예제를 몆 개 들어 보겠습니다. 예제멀티탭과 전원 케이블다형성의 예는 현실에서도 쉽게 볼 수 있습니다. 우선 다음 그림을 봐주세요. 이 그림은 볼 수 있는 멀티 탭입니다. 여기서 선언부분은 구멍이 두 개 뚫린 부분입니다. 구현 부분은 멀티탭에 연결되는 전원 케이블입니다. 이 멀티탭에 연결하려면 전원 케이블은 반드시 연결 부분이 두 개 튀어 나와 있어야 합니다. 튀어 나와 있는 부분이 한개거나 세개 여서는 절대 안됩니다. 그리고 튀어 나온 부분이 사각형 이어도 안 되고 반드시 둥그런 원형이어야 합니다. 참고로 선언부분은 실제 코드를 만들 때 객체지향 프로그래밍의 기본 기능인 인터페이스(interface)와 추상 클래스가 사용되며 구현부분은 일반 클래스 추상 클래스가 사용됩니다. USB와 USB기기들다형성은 많은 사람들이 즐겨 사용하는 USB 기기에서도 찾을 수 있습니다. 모든 USB 기기는 USB 규격에 맞춰 만들어져 있습니다. 또한 USB를 연결해서 사용하는 컴퓨터 역시 USB 규격에 맞춰 만들어져 있습니다. USB 규격에 맞춰 만들어져 있는 기기라면 그 어떤 기기라도 연결해서 사용할 수 있습니다. 심지어 아직 출시되지 않은 USB 제품들까지 말이지요. 여기서 USB 규격은 설계 부분인 인터페이스에 해당하며 USB기기들은 구현 부분을 담당하게 됩니다. 심플 이미지 갤러이와 정렬 기능마지막으로 앞에서 살펴본 심플 이미지 갤러리를 다시 한 번 살펴보겠습니다. 다형성이 어떤 의미인지 배웠으니 그 전에 이해하지 못했던 구조가 아마도 눈에 들어 올 것입니다. 위의 이미지에서 선언부분인 “정렬기능 인터페이스”를 보면 정렬기능($images) 메서드가 들어 있습니다. 이 뜻은 구현 부분에서는 반드시 “정렬기능 인터페이스”에 정의되어 있는 메서드와 동일하게 메서드를 만들어야 한다는 뜻입니다. 메서드 이름뿐 아니라 매개변수 개수까지 모두 동일해야 합니다. 위의 이미지에서 구현부분을 담당하는 “가로 정렬하기 클래스” 등을 살펴보면 선언 규칙에 맞게 메서드가 만들어져 있는 것을 확인할 수 있습니다. 즉 다형성을 적용해 구현한 구조입니다. 앞서 다룬 USB로 비교하자면 정렬 기능 인터페이스는 USB 규약과 동일하며 정렬 기능을 구현한 클래스들은 USB 기기와 동일합니다. 이렇게 만들어진 구현부분은 심플 이미지 갤러리 클래스에 연결되어 사용됩니다. 이때 주의깊게 살펴볼 부분이 있는데요. 바로 “심플 이미지 갤러리 클래스”의 정렬 기능연결() 메서드 입니다. 다음 그림에서 알 수 있는 것처럼 정렬기능연결() 메서드의 매개변수가 “정렬기능 인스턴스”라고 적혀 있습니다. 이 뜻은 이 매개변수 값으로 넘겨 줄 수 있는 값의 타입 반드시 정렬기능 인터페이스를 구현한 객체 여야 한다는 뜻을 가지고 있습니다. 만약 정렬 기능 인터페이스를 구현하지 않은 객체를 넘기게 되면 에러가 나게 되는 것이죠. 즉 반드시 USB 규격에 맞춘 기기만이 컴퓨터의 USB잭에 연결할 수 있다는 의미와도 같습니다. 앞에서 알아봤던 일반 객체지향 프로그래밍의 인스턴스 문법과 추상 클래스 문법 등이 있는 이유가 바로 이런 규격을 만드는 도구로 사용되기 때문입니다. 하지만 아쉽게도 자바스크립트는 이런 문법을 지원하지 않기 때문에 이런 멋진 프로그래밍을 할 순 없습이다. 그저 그냥 지원한다는 생각으로 구현하는 것 이죠. [객체지향 프로그래밍 기초] 절차지향 프로그래밍 VS 객체지향 프로그래밍 [객체지향 프로그래밍 기초] 객체지향 프로그래밍의 특징 [객체지향 프로그래밍 기초] 객체지향 프로그래밍 언어에서 제공하는 기본 기능 [객체지향 프로그래밍 특징] 추상화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서 추상화 [객체지향 프로그래밍 특징] 캡슐화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서의 캡슐화 [객체지향 프로그래밍 특징] 클래스 상속 소개 [객체지향 프로그래밍 특징] 클래스 상속 기능 [객체지향 프로그래밍 특징] 자바스크립트에서 클래스 상속 [객체지향 프로그래밍 특징] 자식 클래스와 부모 클래스 연동 처리 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버라이드 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버로딩 [객체지향 프로그래밍 특징] constructor 프로퍼티 활용 [객체지향 프로그래밍 특징] 클래스 상속 규칙 [객체지향 프로그래밍 특징] 다형성 소개 [객체지향 프로그래밍 특징] 다형성과 데이터 타입과의 관계 [객체지향 프로그래밍 특징] 자바스크립트에서 다형성 합성 소개 클래스 상속 VS 합성","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"},{"name":"객체지향 프로그래밍","slug":"JS/js-학습/객체지향-프로그래밍","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"}],"tags":[]},{"title":"[객체지향 프로그래밍 특징] 클래스 상속 규칙","slug":"객체지향-프로그래밍-특징-클래스-상속-규칙","date":"2018-03-17T09:48:16.000Z","updated":"2018-03-30T00:53:17.462Z","comments":true,"path":"2018/03/17/객체지향-프로그래밍-특징-클래스-상속-규칙/","link":"","permalink":"https://recoveryman.github.io/2018/03/17/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%83%81%EC%86%8D-%EA%B7%9C%EC%B9%99/","excerpt":"","text":"앞에서 알아본 것처럼 상속을 활용하면 부모의 기능을 재사용할 수 있을 뿐 아니라 기능을 재정의해서 확장할 수도 있습니다. 하지만 상속을 아무때나 사용해서는 안 됩니다. 반드시 상속관계가 성립될 때만 사용해야 합니다. 이번에는 반드시 지켜야 할 클래스 상속 규칙에 대해 알아보겠습니다. 클래스 상속은 이럴때 사용하면 안 되요.클래스 상속은 다음과 같은 여우에만 사용해야 합니다. 하나: 코드 재사용만을 위해 클래스 상속을 사용하면 안 됩니다. 둘: 중복 코드 제거만을 위해 클래스 상속을 사용해서도 안 됩니다. 셋: 클래스 상속은 패밀리 관계(IS A)를 유지하면서 기능을 확장할 때만 사용해야 합니다. 패밀리 관계를 체크하는 방법은 간단합니다. 만약 철수가 사람이란 클래스를 상속받은 경우라면 철수는 사람의 한 종류이기 때문에 패밀리 관계가 성립됩니다. 그럼 상속 규칙에 대한 이해를 돕기 위해 예제를 가지고 설명해 보겠습니다. 예제아래에 등장하는 클래스들의 상속 관계가 맞는지 아닌지 고민해보겠습니다. 사람(부모 클래스)과 슈퍼맨(자식 클래스)프로그래밍 언어로 슈퍼맨을 추상화 한다고 해보죠. 그럼 먼저 사람이 기본으로 가지고 있는 기능이 담긴 사람이라는 클래스를 만든 후 이 클래스를 상속받아 슈퍼맨 클래스를 만들면 아주 쉽게 만들 수 있습니다. 평소에는 일반인처럼 살다가 위험이 닥치면 슈퍼맨으로 변신하는 거죠. 추가로 스파이더맨 역시 사람을 상속받아 만들면 아주 쉽게 만들 수 있습니다. 즉 “슈퍼맨도 사람이다.” 라는(IS A) 공식이 성립해 정상적인 상속 관계가 성립되는 것을 확인할 수 있습니다. 사람(부모 클래스)과 강아지(자식 클래스)이번에도 프로그래밍 언어로 사람 말을 하는 강아지를 만든다고 해보죠. 먼저 사람 기능을 가진 사람이란 클래스를 만든 후 이 클래스를 상속받아 강아지를 만들면 다음과 같이 아주 쉽게 만들 수 있습니다. 언뜻 보면 괜찮은 것처럼 보이지만 사람 말을 하다는 강아지는 말하는 기능만 있으면 되는데 필요하지도 않은 사람 클래스의 모든 기능을 물려 받게 되는 치명적인 문제점을 갖게 됩니다. 또한 IS A 공식에 넣어 보면 “강아지는 사람이다.”가 되어 공식에 맞지 않게 됩니다. 즉, 특정 기능이 필요하다고 해서 무작정 상속을 이용해서는 안 된다는 의미입니다. 반드시 상속 규칙에 맞을 때만 상속을 사용하길 바랍니다. [객체지향 프로그래밍 기초] 절차지향 프로그래밍 VS 객체지향 프로그래밍 [객체지향 프로그래밍 기초] 객체지향 프로그래밍의 특징 [객체지향 프로그래밍 기초] 객체지향 프로그래밍 언어에서 제공하는 기본 기능 [객체지향 프로그래밍 특징] 추상화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서 추상화 [객체지향 프로그래밍 특징] 캡슐화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서의 캡슐화 [객체지향 프로그래밍 특징] 클래스 상속 소개 [객체지향 프로그래밍 특징] 클래스 상속 기능 [객체지향 프로그래밍 특징] 자바스크립트에서 클래스 상속 [객체지향 프로그래밍 특징] 자식 클래스와 부모 클래스 연동 처리 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버라이드 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버로딩 [객체지향 프로그래밍 특징] constructor 프로퍼티 활용 [객체지향 프로그래밍 특징] 클래스 상속 규칙 [객체지향 프로그래밍 특징] 다형성 소개 [객체지향 프로그래밍 특징] 다형성과 데이터 타입과의 관계 [객체지향 프로그래밍 특징] 자바스크립트에서 다형성 합성 소개 클래스 상속 VS 합성","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"},{"name":"객체지향 프로그래밍","slug":"JS/js-학습/객체지향-프로그래밍","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"}],"tags":[]},{"title":"[객체지향 프로그래밍 특징] constructor 프로퍼티 활용","slug":"객체지향-프로그래밍-특징-constructor-프로퍼티-활용","date":"2018-03-15T17:06:29.000Z","updated":"2018-03-30T00:53:24.169Z","comments":true,"path":"2018/03/16/객체지향-프로그래밍-특징-constructor-프로퍼티-활용/","link":"","permalink":"https://recoveryman.github.io/2018/03/16/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95-constructor-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%ED%99%9C%EC%9A%A9/","excerpt":"","text":"construcotr 프로퍼티 소개일반적으로 클래스를 만들면 자동적으로 prototype의 constructor라는 프로퍼티가 만들어 집니다. 이 프로퍼티에는 해당 클래스의 생성자 정보가 기본값으로 담기게 됩니다. 달리 말하면 constructor 프로퍼티를 이용해 사용하는 객체(인스턴스)가 어떤 클래스의 인스턴스인지 알아낼 수 있습니다. 하지만 상속관계를 맺는 경우 자식 클래스의 constructor 프로퍼티에는 기본적으로 부모클래스의 생성자가 담기게 되어 constructor 프로퍼티를 가지고는 해당 객체의 클래스를 알아낼 수가 없습니다. 예제를 이용해 좀 더 자세히 설명해 보겠습니다. 예제다음 코드는 사용하는 인스턴스가 특정 클래스의 인스턴스인지 확인하는 예제입니다. 다음 코드를 실행해 주세요. 1234567891011121314151617181920212223242526function MyParent() &#123; this.prototype1 = \"value1\";&#125;MyParent.prototype.method1 = function() &#123; console.log(\"property1 = \", this.property1);&#125;function MyChild() &#123;&#125;MyChild.prototype = new MyParent();var parent1 = new MyParent();var child1 = new MyChild();// 부모 클래스의 인스턴스인지 확인if(parent1.constructor == MyParent) &#123; console.log(\"1. parent1는 MyParent의 인스턴스입니다.\");&#125;// 자식 클래스의 인스턴스인지 확인if(child1.constructor == MyChild) &#123; console.log(\"2. child1 MyChild의 인스턴스입니다.\");&#125; 실행결과 설명parent1 인스턴스의 constructor 프로퍼티에는 클래스 생성자인 MyParent가 저장돼 있기 때문에 19번 라인의 조건문이 참이되어 조건문 내부 내용이 실행됩니다. 하지만 실행결과에서 알 수 있는 것처럼 예상과는 달리 24번 라인의 조건문은 거짓이 되어 실행되지 않게 됩니다. 이유는 앞에서 설명한 것처럼 자식 객체의 경우 constructor 프로퍼티에는 부모의 생성자가 기본값으로 담기기 때문입니다. 그럼 어떻게 해결해야 할까요? 방법은 아주 간단합니다. 다음과 같이 constructor에 생성자를 설정해 주면 됩니다. [해결책]1234//.....var parent1 = new MyParent();var child1 = new MyChild();//..... [construcotor 생성자 설정]123456789101112131415161718192021222324252627function MyParent() &#123; this.prototype1 = \"value1\";&#125;MyParent.prototype.method1 = function() &#123; console.log(\"property1 = \", this.property1);&#125;function MyChild() &#123;&#125;MyChild.prototype = new MyParent();MyChild.prototype.constructor = MyChild;var parent1 = new MyParent();var child1 = new MyChild();// 부모 클래스의 인스턴스인지 확인if(parent1.constructor == MyParent) &#123; console.log(\"1. parent1는 MyParent의 인스턴스입니다.\");&#125;// 자식 클래스의 인스턴스인지 확인if(child1.constructor == MyChild) &#123; console.log(\"2. child1 MyChild의 인스턴스입니다.\");&#125; 기존 코드를 변경한 후 실행해 보세요. 25번 라인(이전의 24번 라인)의 조건문이 참이 되어 조건문 내부 내용이 동작하는 것을 확인할 수 있을 것입니다. 실무에서 constructor를 가지고 어떤 클래스의 인스턴스인지 비교하는 일은 그렇게 많지 않을 것입니다. 하지만 라이브러리를 만들 때 유용하게 사용되는 속성이니 꼭 알아두길 바랍니다. [객체지향 프로그래밍 기초] 절차지향 프로그래밍 VS 객체지향 프로그래밍 [객체지향 프로그래밍 기초] 객체지향 프로그래밍의 특징 [객체지향 프로그래밍 기초] 객체지향 프로그래밍 언어에서 제공하는 기본 기능 [객체지향 프로그래밍 특징] 추상화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서 추상화 [객체지향 프로그래밍 특징] 캡슐화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서의 캡슐화 [객체지향 프로그래밍 특징] 클래스 상속 소개 [객체지향 프로그래밍 특징] 클래스 상속 기능 [객체지향 프로그래밍 특징] 자바스크립트에서 클래스 상속 [객체지향 프로그래밍 특징] 자식 클래스와 부모 클래스 연동 처리 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버라이드 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버로딩 [객체지향 프로그래밍 특징] constructor 프로퍼티 활용 [객체지향 프로그래밍 특징] 클래스 상속 규칙 [객체지향 프로그래밍 특징] 다형성 소개 [객체지향 프로그래밍 특징] 다형성과 데이터 타입과의 관계 [객체지향 프로그래밍 특징] 자바스크립트에서 다형성 합성 소개 클래스 상속 VS 합성","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"},{"name":"객체지향 프로그래밍","slug":"JS/js-학습/객체지향-프로그래밍","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"}],"tags":[]},{"title":"[객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버로딩","slug":"객체지향-프로그래밍-특징-자바스크립트에서-메서드-오버로딩","date":"2018-03-12T02:22:23.000Z","updated":"2018-03-30T00:53:28.100Z","comments":true,"path":"2018/03/12/객체지향-프로그래밍-특징-자바스크립트에서-메서드-오버로딩/","link":"","permalink":"https://recoveryman.github.io/2018/03/12/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%98%A4%EB%B2%84%EB%A1%9C%EB%94%A9/","excerpt":"","text":"자바스크립트에서 메서드 오버로딩메서드 오버로딩(overloading)은 동일한 이름을 가진 여러 개의 메서드를 만든 후 매개변수 타입과 개수에 맞는 메서드가 자동으로 호출되는 기능을 뜻합니다. 하지만 아쉽게도 자바스크립트는 문법적으로 오버로딩을 제공하지 않습니다. 대신 오버로딩을 흉내 낼 수는 있습니다. 문법123function 함수 또는 메서드 이름() &#123; arguments 객체 활용&#125; 자바스크립트에서는 매개변수 정보를 담고 있는 arguments를 이용해 오버로딩을 흉내 냅니다. 오버로딩은 함수와 메서드에서 동일하게 사용할 수 있습니다. [여러 개의 숫자 값을 더하는 함수]12345678910111213// 더하기 함수function sum() &#123; var result = 0; for(var i=0; i&lt;arguments.length; i++) &#123; result+=arguments[i]; &#125; return result;&#125;// 함수 호출console.log(sum(10, 20));console.log(sum(10, 20, 30));console.log(sum(10, 20, 30, 40)); 실행 결과 설명arguments 객체에 담긴 매개변수 값을 매개변수 개수만큼 반복해서 더해 줍니다. 오버로딩은 특히 본인만의 라이브러리를 만들 때 유용하게 사용할 수 있습니다. [객체지향 프로그래밍 기초] 절차지향 프로그래밍 VS 객체지향 프로그래밍 [객체지향 프로그래밍 기초] 객체지향 프로그래밍의 특징 [객체지향 프로그래밍 기초] 객체지향 프로그래밍 언어에서 제공하는 기본 기능 [객체지향 프로그래밍 특징] 추상화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서 추상화 [객체지향 프로그래밍 특징] 캡슐화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서의 캡슐화 [객체지향 프로그래밍 특징] 클래스 상속 소개 [객체지향 프로그래밍 특징] 클래스 상속 기능 [객체지향 프로그래밍 특징] 자바스크립트에서 클래스 상속 [객체지향 프로그래밍 특징] 자식 클래스와 부모 클래스 연동 처리 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버라이드 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버로딩 [객체지향 프로그래밍 특징] constructor 프로퍼티 활용 [객체지향 프로그래밍 특징] 클래스 상속 규칙 [객체지향 프로그래밍 특징] 다형성 소개 [객체지향 프로그래밍 특징] 다형성과 데이터 타입과의 관계 [객체지향 프로그래밍 특징] 자바스크립트에서 다형성 합성 소개 클래스 상속 VS 합성","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"},{"name":"객체지향 프로그래밍","slug":"JS/js-학습/객체지향-프로그래밍","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"}],"tags":[]},{"title":"[객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버라이드","slug":"객체지향-프로그래밍-특징-자바스크립트에서-메서드-오버라이드","date":"2018-03-11T16:09:13.000Z","updated":"2018-03-30T00:53:31.540Z","comments":true,"path":"2018/03/12/객체지향-프로그래밍-특징-자바스크립트에서-메서드-오버라이드/","link":"","permalink":"https://recoveryman.github.io/2018/03/12/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%93%9C/","excerpt":"","text":"메서드 오버라이드클래스 상속을 사용하다 보면 종종 물려받는 부모의 기능을 그대로 사용하지 않고 재정의해야 할 경우가 발생합니다. 이 경우를 메서드 오버라이드라고 합니다. 메서드 오버라이드란?메서드 오버라이드(override)는 자식 클래스에서 부모 클래스의 기능(method)를 재정의 할 때 사용하는 기능입니다. 오버라이드는 다음과 같은 경우에 주로 사용합니다. 경우 1: 부모 클래스의 기능을 사용하지 않고 자식 클래스에서 구현한 기능을 사용하고 싶은 경우 경우 2: 부모 클래스의 기능을 자식 클래스에서 확장하고 싶은 경우 부모 클래스의 기능을 자식 클래스에서 정의문법 12MyParent.prototype.부모메서드 = function()&#123;&#125;MyChild.prototype.부모메서드 = function()&#123;&#125; 부모 클래스의 기능을 자식 클래스에서 재정의(모버라이드)하는 것은 간단합니다. 위의 문법처럼 부모 클래스의 기능 중 재정의(오버라이드)하고자 하는 기능을 자식 클래스에서 똑같은 이름으로 만들어 주면 됩니다. 예제 풀이 전 코드를 수정하지 않고 부모 클래스(MyParent)의 method1()을 실행하는 경우 다음과 같이 출력되게 만들어 주세요.프로퍼티1은 data 입니다 [풀이 전]123456789101112131415161718192021222324// 부모 클래스function MyParent()&#123; this.property1= \"data1\"; console.log(\"MyParent()\")&#125;MyParent.prototype.method1=function()&#123; console.log(\"property1 = \"+this.property1);&#125;// 자식 클래스function MyChild()&#123; console.log(\"MyChild()\");&#125;// 부모 클래스 상속MyChild.prototype = new MyParent();// 생성자 설정MyChild.prototype.constructor= MyChild;// 자식 인스턴스 생성var child1 = new MyChild();// 메서드 호출child1.method1(); [풀이 후]12345678910111213141516171819202122232425262728293031// 부모 클래스function MyParent()&#123; this.property1= \"data1\"; console.log(\"MyParent()\")&#125;MyParent.prototype.method1=function()&#123; console.log(\"property1 = \"+this.property1);&#125;// 자식 클래스function MyChild()&#123; console.log(\"MyChild()\");&#125;// 부모 클래스 상속MyChild.prototype = new MyParent();// 생성자 설정MyChild.prototype.constructor= MyChild;// 메서드 overrideMyChild.prototype.method1=function()&#123; console.log(\"프로퍼티1은 \"+this.property1+\" 입니다.\");&#125;// 자식 인스턴스 생성var child1 = new MyChild();// 메서드 호출child1.method1(); 설명 23번 라인: 부모 클래스의 method1() 메서드를 자식 클래스(MyChild)에서 재정의(오버라이드)해 줍니다. 코드를 입력한 후 실행해 보세요. 이제 더 이상 부모 클래스의 method1() 메서드가 동작하지 않고 잣긱 클래스에서 작성한 method1() 메서드가 동작하는 것을 확인할 수 있을 것입니다. 이처럼 부모의 기능을 직접 수정하지 않고 부모의 기능을 재정의할 때 메서드 오버라이드를 사용합니다. 부모 클래스의 기능을 자식 클래스에서 확장실무를 진행하다 보면 부모의 기능을 완전히 새롭게 재정의 하는 것이 아니라 부모의 기능을 그대로 사용하면서 동시에 기능을 약간 추가하고 싶은 경우가 있습니다. 이럴 때도 메서드 오버라이드를 활용합니다. 문법 1234MyChild.prototype.부모메서드 = function([param1, param2, ...]) &#123; 부모클래스.prototype.부모메서드.call(this[,param1, param2, ...]); // 추가 확장 구문&#125; 기본은 오버라이드하고자 하는 부모 클래스의 기능(메서드)을 자식 클래스에서 동일한 이름으로 만들어 주는 것입니다. 이후 메서드 내부에는 오버함수객체(Function)에서 제공하는 call() 메서드를 활용해 부모의 기능을 호출해 줍니다. 다음으로 추가하고자 하는 구문을 작성해주는 것이지요. 예제 [오버라이드를 활용한 기능 확장]풀이 전 코드를 수정하지 않고 메서드 오버라이드를 이용해 child1.info()을 호출하면 실행결과와 같이 출력되게 만들어 주세요. -실행결과-property1 = data1property2 = data2 [풀이 전]12345678910111213141516171819202122232425// 부모 클래스function MyParent()&#123; this.property1= \"data1\"; console.log(\"MyParent()\")&#125;MyParent.prototype.info=function()&#123; console.log(\"property1 = \"+this.property1);&#125;// 자식 클래스function MyChild()&#123; console.log(\"MyChild()\"); this.property2 =\"data2\";&#125;// 부모 클래스 상속MyChild.prototype = new MyParent();// 생성자 설정MyChild.prototype.constructor= MyChild;// 자식 인스턴스 생성var child1 = new MyChild();// 자식 정보 출력child1.info(); [풀이 후]12345678910111213141516171819202122232425262728293031// 부모 클래스function MyParent()&#123; this.property1= \"data1\"; console.log(\"MyParent()\")&#125;MyParent.prototype.info=function()&#123; console.log(\"property1 = \"+this.property1);&#125;// 자식 클래스function MyChild()&#123; console.log(\"MyChild()\"); this.property2 =\"data2\";&#125;// 부모 클래스 상속MyChild.prototype = new MyParent();// 생성자 설정MyChild.prototype.constructor= MyChild;// 메서드 오버라이드를 활용한 기능 확장MyChild.prototype.info=function()&#123; MyParent.prototype.info.call(this); console.log(\"property2 = \"+this.property2);&#125;// 자식 인스턴스 생성var child1 = new MyChild();// 자식 정보 출력child1.info(); 설명 23번 라인: 확장할 기능인 info() 메서드를 자식 클래스에서 오버라이드해 줍니다. 24번 라인: 부모 클래스 info() 메서드를 그대로 재사용하기 위해 함수객체(Function)의 call()메서드를 활용해 부모 클래스의 info() 메서드를 호출해 줍니다. 25번 라인: 마지막으로 확장하고자 하는 기능을 추가해 줍니다. 결과 코드를 모두 작성했다면 실행해 보세요. 결과가 실행결과처럼 출력되는 것을 확인할 수 있을 것입니다. 이해를 돕기 위해 31번라인의 child.info() 메서드가 실행되는 순서를 그림으로 표현하면 다음과 같습니다. 이처럼 메서드 오버라이드를 활용하면 부모의 기능을 확장할 수 있습니다. [객체지향 프로그래밍 기초] 절차지향 프로그래밍 VS 객체지향 프로그래밍 [객체지향 프로그래밍 기초] 객체지향 프로그래밍의 특징 [객체지향 프로그래밍 기초] 객체지향 프로그래밍 언어에서 제공하는 기본 기능 [객체지향 프로그래밍 특징] 추상화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서 추상화 [객체지향 프로그래밍 특징] 캡슐화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서의 캡슐화 [객체지향 프로그래밍 특징] 클래스 상속 소개 [객체지향 프로그래밍 특징] 클래스 상속 기능 [객체지향 프로그래밍 특징] 자바스크립트에서 클래스 상속 [객체지향 프로그래밍 특징] 자식 클래스와 부모 클래스 연동 처리 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버라이드 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버로딩 [객체지향 프로그래밍 특징] constructor 프로퍼티 활용 [객체지향 프로그래밍 특징] 클래스 상속 규칙 [객체지향 프로그래밍 특징] 다형성 소개 [객체지향 프로그래밍 특징] 다형성과 데이터 타입과의 관계 [객체지향 프로그래밍 특징] 자바스크립트에서 다형성 합성 소개 클래스 상속 VS 합성","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"},{"name":"객체지향 프로그래밍","slug":"JS/js-학습/객체지향-프로그래밍","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"}],"tags":[]},{"title":"[객체지향 프로그래밍 특징] 자식 클래스와 부모 클래스 연동 처리","slug":"객체지향-프로그래밍-특징-자식-클래스와-부모-클래스-연동-처리","date":"2018-03-05T00:35:38.000Z","updated":"2018-03-30T00:53:34.919Z","comments":true,"path":"2018/03/05/객체지향-프로그래밍-특징-자식-클래스와-부모-클래스-연동-처리/","link":"","permalink":"https://recoveryman.github.io/2018/03/05/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95-%EC%9E%90%EC%8B%9D-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EB%B6%80%EB%AA%A8-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%97%B0%EB%8F%99-%EC%B2%98%EB%A6%AC/","excerpt":"","text":"클래스 상속을 사용하다 보면 자식 클래스에서 부모 클래스의 생성자를 호출해야 하는 경우가 발생합니다. 자바스크립트 최상위 부모 Object 클래스앞에서 설명은 안했지만, 사실 부모가 없는 클래스의 경우 눈에 보이진 않지만 기본으로 자바스크립트에서 제공하는 Object라는 클래스를 상속받게 됩니다. Object 클래스에서는 프로퍼티 값 하나와 여러 개의 메서드를 제공하는데 이 중에서 메서드는 많이 사용하지 않아 몰라도 되지만 constructor라는 속성은 중요하기 때문에 알고 있어야 합니다. 자바스크립트에서 부모 생성자 호출하기상속 구현 시 부모 클래스의 생성자에 매개변수가 있는 경우 자식 클래스에서 부모 클래스의 생성자를 호출해 매개변수 값을 전달해야 합니다. 문법 123function 자식클래스([param1, param2, ...]) &#123; 부모클래스.call(this[, param1, param2, ...]);&#125; 부모 클래스의 생성자를 호출할 때 함수객체에서 제공하는 call()메서드를 이용해 첫 번째 매개변수에 자식 인스턴스를 전달하고, 두 번째 매개변수 이후부터는 부모의 생성자로 전달할 데이터를 전달해 줍니다. 예제다음 예제처럼 상속을 사용하는 경우 자식클래스의 인스턴스 생성 시 부모의 속성값을 설정해야 하는 경우가 자주 있습니다. 이번에 다룬 문법대로 사용하면 됩니다. 1234567891011121314151617181920212223// 부모 클래스function MyParent(param1)&#123; // 프로퍼티 생성 this.property1=param1;&#125;// 메서드 생성MyParent.prototype.method1=function()&#123; console.log(\"MyParent.method1() \"+this.property1);&#125;// 자식 클래스function MyChild(param1)&#123; MyParent.call(this, param1);&#125;// 상속MyChild.prototype = new MyParent();// 인스턴스 생성var child1 = new MyChild(\"data1\");// 부모의 프로퍼티와 메서드 호출console.log(\"child1.property1 = \"+ child1.property1);child1.method1(); 결과 만약 3번의 구문을 호출해 주지 않으면 부모에 값이 전달되지 않아 method1()메서드를 호출하는 경우 정상적으로 원하는 값이 출력되지 않게 됩니다. [객체지향 프로그래밍 기초] 절차지향 프로그래밍 VS 객체지향 프로그래밍 [객체지향 프로그래밍 기초] 객체지향 프로그래밍의 특징 [객체지향 프로그래밍 기초] 객체지향 프로그래밍 언어에서 제공하는 기본 기능 [객체지향 프로그래밍 특징] 추상화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서 추상화 [객체지향 프로그래밍 특징] 캡슐화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서의 캡슐화 [객체지향 프로그래밍 특징] 클래스 상속 소개 [객체지향 프로그래밍 특징] 클래스 상속 기능 [객체지향 프로그래밍 특징] 자바스크립트에서 클래스 상속 [객체지향 프로그래밍 특징] 자식 클래스와 부모 클래스 연동 처리 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버라이드 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버로딩 [객체지향 프로그래밍 특징] constructor 프로퍼티 활용 [객체지향 프로그래밍 특징] 클래스 상속 규칙 [객체지향 프로그래밍 특징] 다형성 소개 [객체지향 프로그래밍 특징] 다형성과 데이터 타입과의 관계 [객체지향 프로그래밍 특징] 자바스크립트에서 다형성 합성 소개 클래스 상속 VS 합성","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"},{"name":"객체지향 프로그래밍","slug":"JS/js-학습/객체지향-프로그래밍","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"}],"tags":[]},{"title":"[객체지향 프로그래밍 특징] 자바스크립트에서 클래스 상속","slug":"객체지향-프로그래밍-특징-자바스크립트에서-클래스-상속","date":"2018-02-27T17:10:09.000Z","updated":"2018-03-30T00:53:38.063Z","comments":true,"path":"2018/02/28/객체지향-프로그래밍-특징-자바스크립트에서-클래스-상속/","link":"","permalink":"https://recoveryman.github.io/2018/02/28/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%83%81%EC%86%8D/","excerpt":"","text":"일반 OOP에서 클래스 상속문법 1234class MyParent &#123;&#125;class MyChild extends MyParent &#123;&#125; 일반 객체지향 프로그래밍에서는 위의 문법과 같이 extends라는 클래스 상속 전용 명령을 이용해 클래스 상속을 구현합니다. 예제그럼 위의 상속 관련 기능 중에서 클래스 상속(extends)을 자바 프로그래밍 언어에서는 어떤 식으로 구현하는지 알아보겠습니다. [자바]1234567891011class MyParent &#123; public int property=10; public method1() &#123; &#125;&#125;class MyChild extends MyParent &#123; public method1() &#123; &#125;&#125;MyChild child = new MyChild();child.method1(); 이처럼 일반 객체지향 프로그래밍에서는 확장의 의미를 가진 extends라는 명령어를 이용해 상속을 구현합니다. 추가로 상속 역시 UML에서 표기법을 지원하며 다음과 같이 속이 하얗게 채워진 삼각형으로 상속을 표현합니다. 여기서 주의해야 할 점은 화살표 방향이 자식 클래스에서 부모 클래스를 가리키는 방향으로 되어 있어야 합니다. 반대가 아니라는 점을 꼭 숙지하세요. 자바스크립트에서 클래스 상속자바스크립트에서는 객체지향 프로그래밍 특징 네 가지 중 유일하게 클래스 상속을 지원합니다. 자바스크립트에서는 프로토타입을 이용해 상속을 구현합니다. 문법 12345678910function 부모클래스() &#123; this.프로퍼티 = 값;&#125;부모클래스.prototype.메서드 = function() &#123; //...&#125;function 자식클래스() &#123;&#125;자식클래스.prototype = new 부모클래스(); 자바스크립트에서 상속은 자식클래스의 prototype 속성에 부모 클래스의 인스턴스를 대입하는 방식으로 이뤄집니다. 이렇게 하면 부모 객체의 모든 기능이 자식 객체의 프로토타입에 연결되어 자식객체에서 부모의 기능을 사용할 수 있게 됩니다. 예제 1234567891011121314151617181920// 부모 클래스function MyParent() &#123; this.property1 = \"값\";&#125;MyParent.prototype.method1 = function() &#123; console.log(this.property1)&#125;// 자식 클래스function MyChild() &#123;&#125;// 상속MyChild.prototype = new MyParent();// 자식 클래스 인스턴스 생성var myChild = new MyChild();// 자식객체에서 부모의 메서드 호출myChild.method1(); 결과 설명위의 코드에서 확인할 수 있는 것처럼 MyChild클래스에서 method1() 메서드를 구현하지 않았음에도 불구하고 MyChild클래스는 MyParent의 속성(프로퍼티)과 기능(메서드)을 상속받은 자식 클래스이기 때문에 method1() 메서드를 사용할 수 있는 것을 확인할 수 있습니다. 클래스 상속을 활용한 기능 확장다음 예제의 갤러리의 경우 배열 버튼을 누르면 아무런 효과 없이 즉시 아이템이 자신의 위치로 이동하는 것을 확인할 수 있습니다. 아래의 예제를 이용해서 클래스 상속을 활용해서 애니메션이 들어간 갤러리로 만들어 보겠습니다. [클래스 상속 활용 전]1234567891011121314151617181920212223242526272829303132333435363738394041424344$(function() &#123; // 인스턴스 생성 var gallery1 = new SimpleGallery(); gallery1.init(\"#container1 li\"); $(\"#btnStart\").click(function()&#123; // 아이템 정렬 gallery1.show(3,150,150); &#125;);&#125;);function SimpleGallery() &#123; // 프로퍼티 생성 this.$itemList = null;&#125;// 요소 초기화SimpleGallery.prototype.init = function(selector) &#123; this.$itemList = $(selector);&#125;// 아이템 출력 메서드 추가SimpleGallery.prototype.show = function(count, listWidth, listHeight) &#123; // 아이템 개수 구하기. var length = this.$itemList.length; // 아이템 배열하기. for(var i=0;i&lt;length;i++) &#123; // n번째 아이템 구하기 var $thisItem = this.$itemList.eq(i); // 위치 값 구하기 var x = 100+((i%count)*listWidth); var y = 100+(parseInt(i/count)*listHeight); // 위치 설정 $thisItem.css(&#123; left:x, top:y &#125;); &#125;&#125; 소스코드 다운받기 결과 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475$(function() &#123; // 인스턴스 생성 // var gallery1 = new SimpleGallery(); var gallery1 = new SimpleAniGallery(); gallery1.init(\"#container1 li\"); $(\"#btnStart\").click(function()&#123; // 아이템 정렬 // gallery1.show(3,150,150); gallery1.showAni(3,150,150); &#125;);&#125;);function SimpleGallery() &#123; // 프로퍼티 생성 this.$itemList = null;&#125;// 요소 초기화SimpleGallery.prototype.init = function(selector) &#123; this.$itemList = $(selector);&#125;// 아이템 출력 메서드 추가SimpleGallery.prototype.show = function(count, listWidth, listHeight) &#123; // 아이템 개수 구하기. var length = this.$itemList.length; // 아이템 배열하기. for(var i=0;i&lt;length;i++) &#123; // n번째 아이템 구하기 var $thisItem = this.$itemList.eq(i); // 위치 값 구하기 var x = 100+((i%count)*listWidth); var y = 100+(parseInt(i/count)*listHeight); // 위치 설정 $thisItem.css(&#123; left:x, top:y &#125;); &#125;&#125;// 심플 애니 갤러리function SimpleAniGallery() &#123;&#125;// 기존 심플 갤러리 상속SimpleAniGallery.prototype = new SimpleGallery();// 애니메이션 기능이 있는 아이템 출력 메서드 추가SimpleAniGallery.prototype.showAni = function(count, listWidth, listHeight) &#123; // 아이템 개수 구하기 var length = this.$itemList.length; // 아이템 배열하기 for(var i=0;i&lt;length;i++) &#123; // n번째 아이템 구하기 var $thisItem = this.$itemList.eq(i); // 위치 값 구하기 var x = 100+((i%count)*listWidth); var y = 100+(parseInt(i/count)*listHeight); // 위치 설정 $thisItem.animate(&#123; left:x, top:y &#125;, 1000) &#125;&#125; 소스코드 다운받기 설명 49번 라인: 먼저 심플갤러리를 상속받을 클래스를 생성해 줍니다. 여기에서는 클래스 이름을 SimpleAniGallery로 만들어 줍니다. 53번 라인: 상속 문법을 활용해 부모 클래스인 SimpleGallery를 자식 클래스인 SimpleAniGallery에서 상속받습니다. 이렇게 함으로써 SimpleAniGallery는 부모 클래스의 기능을 모두 사용할 수 있게 됩니다. 56번 라인: 아이템을 부드럽게 정렬하는 기능을 담당할 메서드를 추가해 줍니다. 그리고 SimpleGallery의 show() 메서드 코드를 그대로 복사해 줍니다. 70번 라인: 기존 코드 내용 중 $thisItem.css({}) 대신 $thisItem.animate({}) 를 사용해서 아이템이 부드럽게 움직일 수 있게 만들어 줍니다. 3번 라인: 코드를 모두 입력했다면 SimpleGallery()대신 SimpleAniGallery 클래스의 인스턴스를 생성해 줍니다. 9번 라인: 마지막으로 버튼 클릭 시 show() 메서드 대신 showAni() 메서드를 호출해 줍니다. 물론 show() 메서드를 호출해도 정상적으로 동작할 것입니다. 이처럼 상속을 활용하면 코드를 복사할 필요 없이 특정 클래스의 기능을 재사용할 수 있을 뿐 아니라 기능을 확장해서 사용할 수 있습니다. 지금까지 작성한 코드를 UML로 정리하면 다음과 같습니다. 전체 소스코드12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273$(function() &#123; // 인스턴스 생성 var gallery1 = new SimpleAniGallery(); gallery1.init(\"#container1 li\"); $(\"#btnStart\").click(function()&#123; // 아이템 정렬 gallery1.showAni(3,150,150); &#125;);&#125;);function SimpleGallery() &#123; // 프로퍼티 생성 this.$itemList = null;&#125;// 요소 초기화SimpleGallery.prototype.init = function(selector) &#123; this.$itemList = $(selector);&#125;// 아이템 출력 메서드 추가SimpleGallery.prototype.show = function(count, listWidth, listHeight) &#123; // 아이템 개수 구하기. var length = this.$itemList.length; // 아이템 배열하기. for(var i=0;i&lt;length;i++) &#123; // n번째 아이템 구하기 var $thisItem = this.$itemList.eq(i); // 위치 값 구하기 var x = 100+((i%count)*listWidth); var y = 100+(parseInt(i/count)*listHeight); // 위치 설정 $thisItem.css(&#123; left:x, top:y &#125;); &#125;&#125;// 심플 애니 갤러리function SimpleAniGallery() &#123;&#125;// 기존 심플 갤러리 상속SimpleAniGallery.prototype = new SimpleGallery();// 애니메이션 기능이 있는 아이템 출력 메서드 추가SimpleAniGallery.prototype.showAni = function(count, listWidth, listHeight) &#123; // 아이템 개수 구하기 var length = this.$itemList.length; // 아이템 배열하기 for(var i=0;i&lt;length;i++) &#123; // n번째 아이템 구하기 var $thisItem = this.$itemList.eq(i); // 위치 값 구하기 var x = 100+((i%count)*listWidth); var y = 100+(parseInt(i/count)*listHeight); // 위치 설정 $thisItem.animate(&#123; left:x, top:y &#125;, 1000) &#125;&#125; 이처럼 상속을 활용하면 특정 클래스의 기능을 재사용할 수 있을 뿐만 아니라 확장까지 가능합니다. [객체지향 프로그래밍 기초] 절차지향 프로그래밍 VS 객체지향 프로그래밍 [객체지향 프로그래밍 기초] 객체지향 프로그래밍의 특징 [객체지향 프로그래밍 기초] 객체지향 프로그래밍 언어에서 제공하는 기본 기능 [객체지향 프로그래밍 특징] 추상화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서 추상화 [객체지향 프로그래밍 특징] 캡슐화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서의 캡슐화 [객체지향 프로그래밍 특징] 클래스 상속 소개 [객체지향 프로그래밍 특징] 클래스 상속 기능 [객체지향 프로그래밍 특징] 자바스크립트에서 클래스 상속 [객체지향 프로그래밍 특징] 자식 클래스와 부모 클래스 연동 처리 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버라이드 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버로딩 [객체지향 프로그래밍 특징] constructor 프로퍼티 활용 [객체지향 프로그래밍 특징] 클래스 상속 규칙 [객체지향 프로그래밍 특징] 다형성 소개 [객체지향 프로그래밍 특징] 다형성과 데이터 타입과의 관계 [객체지향 프로그래밍 특징] 자바스크립트에서 다형성 합성 소개 클래스 상속 VS 합성","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"},{"name":"객체지향 프로그래밍","slug":"JS/js-학습/객체지향-프로그래밍","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"}],"tags":[]},{"title":"[객체지향 프로그래밍 특징] 클래스 상속 기능","slug":"객체지향-프로그래밍-특징-클래스-상속-기능","date":"2018-02-25T11:47:32.000Z","updated":"2018-03-30T00:53:41.647Z","comments":true,"path":"2018/02/25/객체지향-프로그래밍-특징-클래스-상속-기능/","link":"","permalink":"https://recoveryman.github.io/2018/02/25/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%83%81%EC%86%8D-%EA%B8%B0%EB%8A%A5/","excerpt":"","text":"상속은 다음과 같이 세 가지 기능을 가지고 있습니다. 코드 재사용 중복코드 제거 확장 코드 재사용먼저 상속을 사용하는 가장 큰 이유는 재사용하기 위함입니다. 예를 들어 다음과 같이 자식 클래스(MyChild)가 부모 클래스(MyParent)를 상속했다고 보죠.코드로 표현하면 다음과 같습니다. [클래스 상속 기능 1:코드 재사용]123456789101112131415161718192021// 부모 클래스function MyParent() &#123; this.property1 = \"value1\";&#125;MyParent.prototype.method1 = function() &#123; console.log(\"MyParent.method1() \" + this.property1);&#125;// 자식 클래스function MyChild() &#123; //..&#125;// 상속MyChild.prototype = new MyParent();// 인스턴스 생성var child1 = new MyChild();// 부모의 프로퍼티와 메서드 호출console.log(\"child1.property1 = \" + child1.property1);child1.method1(); 실행결과 위의 코드에서 확인할 수 있는 것처럼 상속을 사용하면 코드 복사 없이 MyChild 클래스에서 MyParent클래스 요소인 property1과 method1()을 사용하는 것을 확인할 수 있습니다. 바로 이런 경우를 코드 재사용이라고 합니다. 중복 코드 제거클래스 상속은 중복 코드 제거 기능을 가지고 있습니다. 예제를 이용해 좀 더 자세히 알아보겠습니다. 먼저 다음과 같은 코드가 있다고 보죠. [클래스 상속 기능2: 중복 코드 제거]12345678910111213141516171819202122232425262728293031323334353637// 첫 번째 - MyClassAfunction MyClassA() &#123; this.property1 = 10;&#125;MyClassA.prototype.method1 = function() &#123; console.log(\"this.property1 = \" + this.property1);&#125;MyClassA.prototype.method2 = function() &#123; console.log(\"이 기능은 MyClassA에 있는 기능입니다.\");&#125;// 두 번재 - MyClassBfunction MyClassB() &#123; this.property1 = 10;&#125;MyClassB.prototype.method1 = function() &#123; console.log(\"this.property1 = \"+ this.property1);&#125;MyClassB.prototype.method2 = function() &#123; console.log(\"이 기능은 MyClassB에 있는 기능입니다.\");&#125;// 인스턴스 생성 classAvar classA = new MyClassA();// 프로퍼티와 메서드 접근console.log(\"classA.property1 = \" + classA.property1);classA.method1();classA.method2();// 인스턴스 생성 classB var classB = new MyClassB();//프로퍼티와 메서드 접근console.log(\"classB.property1 = \" + classB.property1);classB.method1();classB.method2(); 결과코드를 살펴보면 다음과 같이 두 개의 클래스에 중복 코드가 있는 것을 확인할 수 있습니다. 클래스 상속을 활용하면 중복 코드가 없는 깔끔한 코드를 만들 수 있습니다. 상속을 활용해 중복 코드를 없애는 방법은 간단합니다. 중복 코드를 담을 부모 클래스 생성먼저 다음과 같이 신규 클래스(MyParent)를 만든 후 MyClassA와 MyClassB 클래스의 중복 코드를 신규 클래스에 담아줍니다. 1234567891011121314151617181920212223242526272829// 중복 코드를 담을 클래스function MyParent() &#123; this.property1 = 10;&#125;MyParent.prototype.method1 = function() &#123; console.log(\"this.property1 = \" + this.property1);&#125;// 첫 번째 - MyClassAfunction MyClassA() &#123; this.property1 = 10;&#125;MyClassA.prototype.method1 = function() &#123; console.log(\"this.property1 = \" + this.property1);&#125;MyClassA.prototype.method2 = function() &#123; console.log(\"이 기능은 MyClassA에 있는 기능입니다.\");&#125;// 두 번째 - MyClassBfunction MyClassB() &#123; this.property1 = 10;&#125;MyClassB.prototype.method1 = function() &#123; console.log(\"this.property1 = \" + this.property1);&#125;MyClassB.prototype.method2 = function() &#123; console.log(\"이 기능은 MyClassA에 있는 기능입니다.\");&#125; 중복 코드 제거중복 코드를 MyParent 클래스에 담았다면 MyClassA와 MyClassB 클래스 에서 중복 코드를 제거해 줍니다. 1234567891011121314151617181920212223242526272829// 중복 코드를 담을 클래스function MyParent() &#123; this.property1 = 10;&#125;MyParent.prototype.method1 = function() &#123; console.log(\"this.property1 = \" + this.property1);&#125;// 첫 번째 - MyClassAfunction MyClassA() &#123; // this.property1 = 10;&#125;/* MyClassA.prototype.method1 = function() &#123; console.log(\"this.property1 = \" + this.property1);&#125; */MyClassA.prototype.method2 = function() &#123; console.log(\"이 기능은 MyClassA에 있는 기능입니다.\");&#125;// 두 번째 - MyClassBfunction MyClassB() &#123; // this.property1 = 10;&#125;/* MyClassB.prototype.method1 = function() &#123; console.log(\"this.property1 = \" + this.property1);&#125; */MyClassB.prototype.method2 = function() &#123; console.log(\"이 기능은 MyClassA에 있는 기능입니다.\");&#125; 상속 관계 만들기다음으로 UML로 표현한 그림과 같이 MyClassA와 MyClassB에 MyParent를 상속으로 연결해 줍니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243// 중복 코드를 담을 클래스function MyParent() &#123; this.property1 = 10;&#125;MyParent.prototype.method1 = function() &#123; console.log(\"this.property1 = \" + this.property1);&#125;// 첫 번째 - MyClassAfunction MyClassA() &#123; &#125;// 상속MyClassA.prototype = new MyParent();MyClassA.prototype.method2 = function() &#123; console.log(\"이 기능은 MyClassA에 있는 기능입니다.\");&#125;// 두 번째 - MyClassBfunction MyClassB() &#123; &#125;// 상속MyClassB.prototype = new MyParent();MyClassB.prototype.method2 = function() &#123; console.log(\"이 기능은 MyClassB에 있는 기능입니다.\");&#125;// 인스턴스 생성var classA = new MyClassA();// 프로퍼티와 메서드 접근console.log(\"classA.prototype1 = \" + classA.property1);classA.method1();classA.method2();var classB = new MyClassB();// 프로퍼티와 메서드 접근console.log(\"classB.prototype1 = \" + classB.property1);classB.method1();classB.method2(); 결과위의 코드에서 확인할 수 있는 것처럼 클래스 상속을 활용하면 중복 코드를 없앨 수 있을 뿐 아니라 코드를 재사용할 수 있습니다. 확장클래스 상속을 활용하면 코드를 아주 쉽게 확장할 수 있습니다. 예를 들어 설명해 보겠습니다. 몇 달 전 A프로젝트를 진행하며 MyClassA라는 클래스를 만들었다고 해보죠. 이 클래스에는 두 개의 메서드가 있습니다.이번에는 B 프로젝트를 진행하게 되었는데 자세히 살펴보니 A 프로젝트에서 만든 MyClassA에 method3() 메서드와 method4() 메서드를 추가해 기능을 구현하면 해결된다는 걸 알았습니다.그럼 지금부터 B프로젝트에서 필요한 클래스를 만들어 볼 텐데요. 처리 방법은 상속을 사용하지 않은 경우와 상속을 사용하는 경우 두 가지로 구현해 보겠습니다. 상속을 사용하지 않은 경우클래스 상속을 사용하지 않고 처리하는 방법은 다시 다음과 같이 두 가지 방법으로 구현해 보겠습니다. 첫 번째: MyClassA를 직접 수정하는 경우 두 번째: 신규 클래스를 만들어 해결하는 경우 그럼 첫 번째 방법부터 살펴 보겠습니다. 첫 번째: MyClassA를 직접 수정하는 경우가장 쉬운 방법은 MyClassA에 method3(), method4() 메서드를 직접 추가해 주는 거죠. 문제점:이 방법은 아쉽게도 A프로젝트와 B프로젝트의 경우 기존에 만든 클래스를 공유해서 사용하기 때문에 기존 A 프로젝트에서는 method3(), method4()를 필요하지도 않고 사용하지도 않는 기능을 계속해서 가지고 있어야 합니다. 또한 기능을 추가하다가 코드를 잘못 입력해 잘 동작하고 있는 A프로젝트가 동작하지 않을 수 있습니다. 두 번째: 신규 클래스를 만들어 해결하는 경우MyClassA를 그대로 복사한 후 클래스이름을 MyClassB로 변경해 줍니다. 그리고 method3(), method4()를 추가해 줍니다. 문제점신규로 클래스를 제작해 처리하기 때문에 기존 프로젝트에는 영향을 주지 않는 장점은 있지만 코드 중복의 문제점이 발생합니다. 상속을 사용하는 경우클래스 상속을 활용하면 좀 더 깔끔하게 문제점을 해결할 수 있습니다. MyClassA를 부모로 하는 MyClassB라는 클래스를 만들어 줍니다. 그리고 MyClassB 클래스에 method3(), method4()를 추가해 줍니다. 지금까지 내용을 UML로 표현하면 다음과 같습니다. 이처럼 클래스 상속을 활용하면 MyClassA를 수정할 필요 없이 기능을 확장할 수 있습니다. [객체지향 프로그래밍 기초] 절차지향 프로그래밍 VS 객체지향 프로그래밍 [객체지향 프로그래밍 기초] 객체지향 프로그래밍의 특징 [객체지향 프로그래밍 기초] 객체지향 프로그래밍 언어에서 제공하는 기본 기능 [객체지향 프로그래밍 특징] 추상화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서 추상화 [객체지향 프로그래밍 특징] 캡슐화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서의 캡슐화 [객체지향 프로그래밍 특징] 클래스 상속 소개 [객체지향 프로그래밍 특징] 클래스 상속 기능 [객체지향 프로그래밍 특징] 자바스크립트에서 클래스 상속 [객체지향 프로그래밍 특징] 자식 클래스와 부모 클래스 연동 처리 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버라이드 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버로딩 [객체지향 프로그래밍 특징] constructor 프로퍼티 활용 [객체지향 프로그래밍 특징] 클래스 상속 규칙 [객체지향 프로그래밍 특징] 다형성 소개 [객체지향 프로그래밍 특징] 다형성과 데이터 타입과의 관계 [객체지향 프로그래밍 특징] 자바스크립트에서 다형성 합성 소개 클래스 상속 VS 합성","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"},{"name":"객체지향 프로그래밍","slug":"JS/js-학습/객체지향-프로그래밍","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"}],"tags":[]},{"title":"[객체지향 프로그래밍 특징] 클래스 상속 소개","slug":"객체지향-프로그래밍-특징-클래스-상속-소개","date":"2018-02-17T07:03:08.000Z","updated":"2018-03-30T00:53:47.671Z","comments":true,"path":"2018/02/17/객체지향-프로그래밍-특징-클래스-상속-소개/","link":"","permalink":"https://recoveryman.github.io/2018/02/17/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%83%81%EC%86%8D-%EC%86%8C%EA%B0%9C/","excerpt":"","text":"클래스 상속클래스 상속을 사용하면 기존 코드를 변경하지 않고도 기능을 추가하거나 수정할 수 있습니다. 클래스 상속 이란?객체지향 프로그래밍에서 상속의 개념은 현실에서 사용하는 상속이란 단어의 뜻과 비슷합니다. 예를 들어 다음과 같이 부모로부터 유산을 상속받았다면 자식은 상속받은 재산을 사용할 수 있게 됩니다. 프로그래밍에서 상속은 확장이라고도 부르며 특정 클래스(부모 클래스)의 속성과 메서드를 하위(자식)클래스가 물려받는 것을 의미합니다. 상속을 받는 자식 클래스에서는 부모의 소스코드를 복사할 필요 없이 부모 클래스의 기능과 속성을 모두 사용할 수 있을 뿐 아니라 필요한 기능을 추가해 확장할 수도 있습니다. 간단한 클래스 상속 MyChild에는 method1()이라는 메서드를 만들지 않았지만 MyChild는 MyParent를 상속받았기 때문에 MyParent의 기능인 method1()를 사용할 수 있습니다. 바로 이런 기능이 상속 입니다. 상속은 이럴 때 사용해요정수기와 얼음 정수기얼음 정수기를 만드는 경우 처음부터 만드는 게 아니라 차가운 물과 뜨거운 물이 나오는 일반 정수기를 그대로 상속받아 얼음이 나오는 기능을 추가해 만드는 거죠. 일반 계산기와 공학 계산기공학 계산기를 만들 때에도 일반 계산기를 상속받아 만들면 일반 계산기 기능을 만들 필요 없이 재사용할 수 있습니다. 탭메뉴와 탭패널탭패널을 만들 때에도 이미 만들어 놓은 탭메뉴를 상속한 후 패널처리 기능만 추가해서 만들면 아주 쉽게 탭패널을 만들 수 있습니다.UML로 표현하면 다음과 같습니다. [객체지향 프로그래밍 기초] 절차지향 프로그래밍 VS 객체지향 프로그래밍 [객체지향 프로그래밍 기초] 객체지향 프로그래밍의 특징 [객체지향 프로그래밍 기초] 객체지향 프로그래밍 언어에서 제공하는 기본 기능 [객체지향 프로그래밍 특징] 추상화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서 추상화 [객체지향 프로그래밍 특징] 캡슐화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서의 캡슐화 [객체지향 프로그래밍 특징] 클래스 상속 소개 [객체지향 프로그래밍 특징] 클래스 상속 기능 [객체지향 프로그래밍 특징] 자바스크립트에서 클래스 상속 [객체지향 프로그래밍 특징] 자식 클래스와 부모 클래스 연동 처리 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버라이드 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버로딩 [객체지향 프로그래밍 특징] constructor 프로퍼티 활용 [객체지향 프로그래밍 특징] 클래스 상속 규칙 [객체지향 프로그래밍 특징] 다형성 소개 [객체지향 프로그래밍 특징] 다형성과 데이터 타입과의 관계 [객체지향 프로그래밍 특징] 자바스크립트에서 다형성 합성 소개 클래스 상속 VS 합성","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"},{"name":"객체지향 프로그래밍","slug":"JS/js-학습/객체지향-프로그래밍","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"}],"tags":[]},{"title":"[객체지향 프로그래밍 특징] 자바스크립트에서의 캡슐화","slug":"객체지향-프로그래밍-특징-자바스크립트에서의-캡슐화","date":"2018-02-16T07:11:40.000Z","updated":"2018-03-30T00:53:59.493Z","comments":true,"path":"2018/02/16/객체지향-프로그래밍-특징-자바스크립트에서의-캡슐화/","link":"","permalink":"https://recoveryman.github.io/2018/02/16/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C%EC%9D%98-%EC%BA%A1%EC%8A%90%ED%99%94/","excerpt":"","text":"일반 OOP에서 지원하는 캡슐화 관련 기능접근 지정자일반적으로 객체 내부에 들어 있는 프로퍼티와 메서드는 객체 외부, 객체 내부, 자식 객체에서 접근해 사용합니다. 일반 객체지향 프로그래밍에서는 캡슐화를 위해 접근 지정자라는 문법을 제공합니다. 이 접근 지정자를 이용하면 개발자가 원하는 곳에서만 프로퍼티와 메서드가 접근할 수 있게 만들 수 있습니다. 접근 지정자는 다음과 같이 세 가지가 있습니다. public protected private public 접근 지정자public 접근 지정자를 적용하는 경우 객체 외부와 객체 내부 그리고 자식 객체에서 모두 접근 가능한 프로퍼티와 메서드를 만들 수 있습니다. protected 접근 지정자protected 접근 지정자를 적용하는 경우 객체 외부에서는 접근이 불가능 하고 객체 내부와 자식 객체에서만 접근 가능한 프로퍼티와 메서드를 만들 수 있습니다. private 접근 지정자private 접근 지정자를 적용하는 경우 오직 객체 자기 자신에서만 접근할 수 있는 프로퍼티와 메서드를 만들 수 있습니다. 지금까지 다룬 접근 지정자를 정리하면 다음과 같습니다. 접근지정자 객체 외부 접근 객체 내부 접근 자식객체 접근 public O O O protected X O O private X O X 예제일반적인 객체지향 프로그래밍에서는 모두 접근 지정자 문법을 제공합니다. 자바 언어를 가지고 간단한 접근 지정자 예제를 보여드리겠습니다. 이처럼 일반 객체지향 프로그래밍에서는 접근 지정자 문법을 제공하기 때문에 좀 더 멋진 캡슐화를 활용해 객체를 만들 수 있습니다. UML로 접근 지정자 표현하기UML에서 접근 지정자는 다음과 같이 표현합니다. 접근 지정자 UML 접근 지정자 표현법 public + protected # private - 자바스크립트에서 캡슐화아쉽게도 자바스크립트는 접근 지정자 문법을 지원하지 않습니다. 문법적으로 지원한다는 의미는 객체밖에서(인스턴스 이름으로 접근하는 경우) public을 제외한 protected, private으로 선언한 프로퍼티와 메서드는 아예 접근조차 할 수 없을 뿐만 아니라 접근하는 구문을 작성하는 즉시 에러가 되어 실행조차 할 수가 없게 됩니다. 바로 자바스크립트에서는 문법적으로 이런 기능을 제공하지 않는다는 뜻입니다. 대신 자바스크립트에서는 다음과 같은 방식으로 접근 지정자를 흉내 내어 사용합니다. 1234567891011121314151617function MyClass() &#123; // public 프로퍼티 this.프로퍼티이름 = 값; // private/protected 프로퍼티 this._프로퍼티이름 = 값;&#125;// public 메서드MyClass.prototype.메서드이름 = function() &#123; //...&#125;// private/protected 메서드MyClass.prototype._메서드이름 = function() &#123; //...&#125; 설명정리하면 접근 지정자 대신 사용하는 자바스크립트 캡슐화 문법은 다음과 같습니다. 접근 지정자 자바스크립트 자바스크립트 표현 방법 public 지원(기본) 프로퍼티메서드 protected 미지원 _프로퍼티_메서드 private 미지원 _프로퍼티_메서드 자바스크립트에서는 객체 외부에서 접근하지 못하게 하는 접근 지정자 private와 protected 대신 요소 이름 앞에 “_”를 붙여 만들어 사용합니다. 여기서 주의해야 할 점은 앞에서 언급한 것처럼 이렇게 한다고 해도 자바스크립트는 문법적으로 접근 지정자 기능을 지원하지 않기 때문에 객체 외부에서 얼마든지 접근할 수 있습니다. 하지만 일종의 무언의 약속처럼 “음…private 이기 때문에 클래스 밖에서 접근해서 사용하면 안되겠군” 하는 식으로 사용하는 거죠. 캡슐화를 적용해 탭메뉴 만들기12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455$(function() &#123; // 첫 번째 탭메뉴 인스턴스 생성 var tab1 = new TabMenu(\".tab1\"); tab1.setSelectItemAt(1); // 두 번째 탭메뉴 인스턴스 생성 var tab2 = new TabMenu(\".tab2\"); tab2.setSelectItemAt(2);&#125;)// 탭메뉴 클래스function TabMenu(selector) &#123; this._$tabMenu = null; this._$menuItems = null; this._$selectMenuItem = null; // 요소 초기화 및 이벤트 등록 호출하기 this._init(selector); this._initEvent();&#125;// 요소 초기화TabMenu.prototype._init = function(selector) &#123; this._$tabMenu = $(selector); this._$menuItems = this._$tabMenu.find('li');&#125;// 이벤트 등록TabMenu.prototype._initEvent = function() &#123; var objThis = this; this._$menuItems.on('click', function(e) &#123; e.preventDefault(); objThis.setSelectItem($(this)); &#125;);&#125;// $menuItem에 해당하는 메뉴 아이템 선택하기TabMenu.prototype.setSelectItem = function($menuItem) &#123; // 기존 선택메뉴 아이템을 비활성화 처리하기 if(this._$selectMenuItem) &#123; this._$selectMenuItem.removeClass('on'); &#125; // 신규 아이템 활성화 처리하기 this._$selectMenuItem = $menuItem; this._$selectMenuItem.addClass('on');&#125;// index에 해당하는 메뉴 아이템 선택하기TabMenu.prototype.setSelectItemAt = function(index) &#123; var $menuItem = this._$menuItems.eq(index); // 기존 메서드 재사용 this.setSelectItem($menuItem);&#125; 소스코드 다운받기 설명클래스 내부에서만 사용하는 프로퍼티와 메서드를 찾아 객체 외부에서 접근할 수 없다는 의미로 “_”를 붙혀 줍니다. 한눈에 확인할 수 있게 표로 정리해보죠. 요소 접근가능(public) 접근불가(prevate) 프로퍼티 _$menuItems_$selectMenuItem_$tabMenu 메서드 setSelectMenuItem($menuItem)setSelectMenuItemAt(index) _init(selector)_initEvent() 처음에는 이 방식이 뭔가 좀 어색할 수 있지만 이 규칙에 익숙해져야 합니다. 지금 유용하게 사용하는 외부 라이브러리 소스 내부를 들여다 보면 “_”가 붙어있는 프로퍼티와 메서드를 쉽게 볼 수 있을 것입니다. 참고로 풀이를 UML로 표현하면 다음과 같습니다. 앞으로 다룰 내용 중 클래스 내부에서만 사용해야 하는 프로퍼티와 메서드에는 가급적 언더바(_)를 붙여 코드를 작성하겠습니다. [객체지향 프로그래밍 기초] 절차지향 프로그래밍 VS 객체지향 프로그래밍 [객체지향 프로그래밍 기초] 객체지향 프로그래밍의 특징 [객체지향 프로그래밍 기초] 객체지향 프로그래밍 언어에서 제공하는 기본 기능 [객체지향 프로그래밍 특징] 추상화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서 추상화 [객체지향 프로그래밍 특징] 캡슐화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서의 캡슐화 [객체지향 프로그래밍 특징] 클래스 상속 소개 [객체지향 프로그래밍 특징] 클래스 상속 기능 [객체지향 프로그래밍 특징] 자바스크립트에서 클래스 상속 [객체지향 프로그래밍 특징] 자식 클래스와 부모 클래스 연동 처리 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버라이드 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버로딩 [객체지향 프로그래밍 특징] constructor 프로퍼티 활용 [객체지향 프로그래밍 특징] 클래스 상속 규칙 [객체지향 프로그래밍 특징] 다형성 소개 [객체지향 프로그래밍 특징] 다형성과 데이터 타입과의 관계 [객체지향 프로그래밍 특징] 자바스크립트에서 다형성 합성 소개 클래스 상속 VS 합성","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"},{"name":"객체지향 프로그래밍","slug":"JS/js-학습/객체지향-프로그래밍","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"}],"tags":[]},{"title":"[객체지향 프로그래밍 특징] 캡슐화 소개","slug":"객체지향-프로그래밍-특징-캡슐화-소개","date":"2018-02-16T04:24:31.000Z","updated":"2018-03-30T00:53:51.756Z","comments":true,"path":"2018/02/16/객체지향-프로그래밍-특징-캡슐화-소개/","link":"","permalink":"https://recoveryman.github.io/2018/02/16/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95-%EC%BA%A1%EC%8A%90%ED%99%94-%EC%86%8C%EA%B0%9C/","excerpt":"","text":"캡슐화란객체의 프로퍼티와 메서드를 숨기거나 노출할 때 사용합니다. 캡슐화란?캡슐화(Encapsulation)는 일반적으로 연관 있는 변수와 함수를 클래스로 묶는 작업을 말합니다. 근데 여기까지만 들어보면 왠지 그냥 클래스 만드는 작업 아냐?! 라고 생각할 수 있는데요. 캡슐화에는 은닉성이란 게 있어서 클래스에 담는 내용 중 중요한 데이터나 기능을 외부에서 접근하지 못하게 할 수 있습니다. 예컨데 만약 현실에서 즐겨보는 TV가 케이스로 포장이 되어 있지 않고 그냥 열려있는 채로 널부러져 있다고 생각해 보세요. 감전될 수 있을 뿐만 아니라 고장 나기 십상입니다. 이런 점 때문에 TV는 사용자가 TV를 시청하기 위해 필요한 기능만을 외부로 빼 놓고 이외의 모든 기능(복합한 회로부터 전자부품까지)을 외부에서 접근할 수 없게 포장(캡슐화)을 해둔 것입니다. 방금 알아본 TV 예처럼 객체지향 프로그래밍 세계에서도 프로그래밍을 하다 보면 객체의 중요한 데이터나 기능을 외부에서 접근하지 못하게 하는 경우가 수없이 발생합니다. 예제다음은 앞에서 많이 다뤘던 탭메뉴 입니다. 만약 탭메뉴의 네 번째 메뉴 아이템이 선택된 상태에서 현재 선택한 탭메뉴 정보가 담긴 $selectMenuItem 프로퍼티를 객체 외부에서 접근해 다음과 같이 값을 null 로 변경한 후 첫 번째 탭메뉴를 누르면 어떻게 될까요? 1234567891011121314151617181920212223242526272829303132333435363738394041function TabMenu(selector) &#123; this.$tabMenu = null; this.$menuItems = null; this.$selectMenuItem = null; this.init(selector); this.initEvent();&#125;// 요소 초기화TabMenu.prototype.init = function(selector) &#123; this.$tabMenu = $(selector); this.$menuItems = this.$tabMenu.find(\"li\");&#125;// 이벤트 등록TabMenu.prototype.initEvent = function() &#123; var objThis = this; this.$menuItems.on('click', function(e) &#123; e.preventDefault(); objThis.setSelectItem($(this)); &#125;)&#125;// $menuItems에 해당하는 메뉴 아이템 선택하기TabMenu.prototype.setSelectItem = function($menuItem) &#123; // 기존 선택메뉴 아이템을 비활성화 처리 하기 if(this.$selectMenuItem) this.$selectMenuItem.removeClass('on'); // 신규 메뉴 활성화 /* 탭메뉴 아이템이 클릭되면 $selectItem에는 현재 선택한 탭메뉴 아이템이 저장됩니다. */ this.$selectMenuItem = $menuItem; this.$selectMenuItem.addClass('on');&#125;$(function() &#123; // 인스턴스 생성 var tab1 = new TabMenu('.tab1');&#125;) 현재 세번째 탬메뉴 아이템이 선택된 상태 프로퍼티 값 변경 버튼을 눌러 선택 메뉴 아이템 정보를 null로 변경 12345678910111213141516171819&lt;button class=\"btn_change\"&gt;프로퍼티 값 변경&lt;/button&gt;&lt;script&gt;function TabMenu(selector) &#123; // ~~~~&#125;/* 중략 */$(function() &#123; // 인스턴스 생성 var tab1 = new TabMenu('.tab1'); $('.btn_change').click(function() &#123; // 외부에서 선택 정보 변경 tab1.$selectMenuItem = null; &#125;);&#125;)&lt;/script&gt; 코드 수정 후 세번째 메뉴를 클릭. 그 후 프로퍼티 값 변경 버튼 클릭, 첫번째 메뉴를 누르게 되면? 최종적으로 다음과 같이 정상적으로 동작하지 않는 결과 발생! 의도와는 달리 첫번째 메뉴와 세번째 메뉴가 동시에 선택된 상태로 될 것입니다. 이처럼 $selectItem 정보는 객체 외부에서 접근하지 못하도록 해야 합니다. 바로 이럴 때 캡슐화의 은닉성이 필요합니다. 소스코드 다운받기 [객체지향 프로그래밍 기초] 절차지향 프로그래밍 VS 객체지향 프로그래밍 [객체지향 프로그래밍 기초] 객체지향 프로그래밍의 특징 [객체지향 프로그래밍 기초] 객체지향 프로그래밍 언어에서 제공하는 기본 기능 [객체지향 프로그래밍 특징] 추상화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서 추상화 [객체지향 프로그래밍 특징] 캡슐화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서의 캡슐화 [객체지향 프로그래밍 특징] 클래스 상속 소개 [객체지향 프로그래밍 특징] 클래스 상속 기능 [객체지향 프로그래밍 특징] 자바스크립트에서 클래스 상속 [객체지향 프로그래밍 특징] 자식 클래스와 부모 클래스 연동 처리 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버라이드 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버로딩 [객체지향 프로그래밍 특징] constructor 프로퍼티 활용 [객체지향 프로그래밍 특징] 클래스 상속 규칙 [객체지향 프로그래밍 특징] 다형성 소개 [객체지향 프로그래밍 특징] 다형성과 데이터 타입과의 관계 [객체지향 프로그래밍 특징] 자바스크립트에서 다형성 합성 소개 클래스 상속 VS 합성","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"},{"name":"객체지향 프로그래밍","slug":"JS/js-학습/객체지향-프로그래밍","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"}],"tags":[]},{"title":"[객체지향 프로그래밍 특징] 자바스크립트에서 추상화","slug":"객체지향-프로그래밍-특징-자바스크립트에서-추상화","date":"2018-02-15T16:50:39.000Z","updated":"2018-03-30T00:54:03.983Z","comments":true,"path":"2018/02/16/객체지향-프로그래밍-특징-자바스크립트에서-추상화/","link":"","permalink":"https://recoveryman.github.io/2018/02/16/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%97%90%EC%84%9C-%EC%B6%94%EC%83%81%ED%99%94/","excerpt":"","text":"일반 OOP에서 지원하는 추상화일반 객체지향 프로그래밍에서는 다음과 같은 추상화를 구현할 수 있는 문법을 지원합니다. 일반 클래스(class)일반적인 객체의 프로퍼티와 메서드를 만들 때 사용합니다. 추상클래스(abstract class)선언 부분과 구현 부분이 있는 클래스를 만들 때 사용합니다. 인터페이스(interface)클래스가 반드시 구현하고 있어야 하는 기능(메서드) 목록을 만들 때 사용합니다. 인터페이스에는 구현 부분이 존재하지 않습니다. 자바스크립트에서 추상화자바스크립트에서는 추상 클래스와 인터페이스를 제공하지 않기 때문에 오직 클래스만을 이용해서 추상화 작업을 해야 합니다. 클래스만을 사용해야 하기 때문에 인터페이스의 기능인 클래스가 구현하고 있어야 하는 규약 등을 적용할 수 없습니다. 자바스크립트는 클래스와 비슷하게 만들어서 사용하는 방법 세 가지를 제공합니다. 리터럴 방식 함수활용 방식 프로토타입 방식 탭메뉴를 추상화하기탭메뉴 클래스 이름은 뭐로 할 것인지, 그리고 기능과 속성까지 추상화 해보겠습니다. 풀이 설명소스로 표현하면 다음과 같습니다. 12345678910111213141516function TabMenu(selector) &#123; this.selectIndex; this.$menuItems;&#125;TabMenu.prototype.setMenuItemAt = function(index) &#123; //...&#125;TabMenu.prototype.setMenuItem = function($menuItems) &#123; //..&#125;TabMenu.prototype.getSelectIndex = function() &#123; //..&#125; 이처럼 추상화란 특정 기능을 하는 그룹의 공통된 기능(프로퍼티와 메서드)을 정의하는 작업을 말합니다. [객체지향 프로그래밍 기초] 절차지향 프로그래밍 VS 객체지향 프로그래밍 [객체지향 프로그래밍 기초] 객체지향 프로그래밍의 특징 [객체지향 프로그래밍 기초] 객체지향 프로그래밍 언어에서 제공하는 기본 기능 [객체지향 프로그래밍 특징] 추상화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서 추상화 [객체지향 프로그래밍 특징] 캡슐화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서의 캡슐화 [객체지향 프로그래밍 특징] 클래스 상속 소개 [객체지향 프로그래밍 특징] 클래스 상속 기능 [객체지향 프로그래밍 특징] 자바스크립트에서 클래스 상속 [객체지향 프로그래밍 특징] 자식 클래스와 부모 클래스 연동 처리 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버라이드 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버로딩 [객체지향 프로그래밍 특징] constructor 프로퍼티 활용 [객체지향 프로그래밍 특징] 클래스 상속 규칙 [객체지향 프로그래밍 특징] 다형성 소개 [객체지향 프로그래밍 특징] 다형성과 데이터 타입과의 관계 [객체지향 프로그래밍 특징] 자바스크립트에서 다형성 합성 소개 클래스 상속 VS 합성","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"},{"name":"객체지향 프로그래밍","slug":"JS/js-학습/객체지향-프로그래밍","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"}],"tags":[]},{"title":"[객체지향 프로그래밍 특징] 추상화 소개","slug":"객체지향-프로그래밍-특징-추상화-소개","date":"2018-02-15T08:03:41.000Z","updated":"2018-03-30T00:53:55.828Z","comments":true,"path":"2018/02/15/객체지향-프로그래밍-특징-추상화-소개/","link":"","permalink":"https://recoveryman.github.io/2018/02/15/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95-%EC%B6%94%EC%83%81%ED%99%94-%EC%86%8C%EA%B0%9C/","excerpt":"","text":"추상화란특정 기능을 하는 그룹의 공통된 기능(프로퍼티와 메서드)을 정의하는 작업을 말합니다. 추상화란객체지향 프로그래밍에서 추상화(Abstraction)는 객체들의 공통적인 프로퍼티와 메서드를 뽑아내는 작업을 의미합니다. 좀더 풀어 설명하면 집을 짓기 전 설계도를 그린 후 설계도에 맞게 집을 짓는 것처럼 객체지향 프로그래밍 동네에서도 개발하려고 하는 프로젝트에서 사용하는 객체가 무엇인지 살펴본 후 객체가 가지고 있어야 할 프로퍼티와 메서드를 추상적으로 생각해 설계도를 그리게 됩니다. 예를 들어 사람을 추상화 한다면 다음과 같이 추상화할 수 있습니다. 동물을 추상화해보면 다음과 같이 표현할 수 있습니다. 그런데 여기서 주의해서 볼 사항이 있는데요. 모든 동물이 “날다()”라는 기능을 가진 것이 아니기 때문에 올바르게 추상화를 했다고 할 수 없습니다. 이처럼 추상화는 특정 기능을 하는 그룹의 공통된 기능(프로퍼티와 메서드)을 정의하는 작업을 의미합니다. 좀더 자세히 설명하자면 클래스의 선언 부분과 구현 부분 중 추상화는 오직 선언 부분만을 정의할 뿐 구현 부분은 작업하지 않습니다. 예제TV를 추상화하기먼저 집에서 흔히 볼 수 있는 TV라는 객체를 프로그래밍으로 표현한다고 해보죠. TV의 경우 브라운관 TV부터 요즘 나오는 스마트 TV까지 다양하게 있는데요. 여기에서는 종류를 떠나서 TV라면 기본적으로 가지고 있어야 하는 속성과 기능만을 뽑아보는 거죠. 아마도 다음과 같을 것입니다. 코드로 표현하면 다음과 같습니다. 1234567891011121314151617181920function TV() &#123; this.모델명; this.해상도크기;&#125;TV.prototype.전원On = function() &#123; //...&#125;TV.prototype.전원Off = function() &#123; //...&#125;TV.prototype.채널변경 = function() &#123; //...&#125;TV.prototype.사운드조절기능 = function() &#123; //...&#125; 바로 이처럼 TV라는 객체들이 공통적으로 가지고 있어야 하는 속성(property)과 메서드(method)를 뽑아 내는 작업을 추상화라고 합니다. 이미지 슬라이더를 추상화하기또 하나의 예를 들어 보겠습니다. 이번에는 웹 프론트엔드 실무에서 많이 사용하는 이미지 슬라이더를 만든다고 해보죠. 클래스 이름은 이미지 슬라이더를 의미하는 ImageSlider로 하고 3초마다 이미지가 슬라이더 되는 기능을 startAutoPlay()라는 메서드 이름으로 구현하면 되고 또 외부에서 특정 이미지 슬라이더를 선택할 수 있는 기능은 setImageAt()라는 메서드에 구현하면 될 것 같네요. 지금까지 추상화한 내용을 UML을 이용해 표현하면 다음과 같을 것입니다. 소스로 표현하면 다음과 같습니다. 123456789101112131415161718192021222324function ImageSlider(selector) &#123; this.selectIndex; // 현재 선택된 이미지 index this.$imageList; // 이미지 목록&#125;ImageSlider.prototype.startAutoPlay = function() &#123; // 자동 플레이 기능 시작&#125;ImageSlider.prototype.stopAutoPlay = function() &#123; // 자동 플레이 기능 멈춤&#125;ImageSlider.prototype.nextImage = function() &#123; // 다음 이미지 이동&#125;ImageSlider.prototype.prevImage = function() &#123; // 이전 이미지 이동&#125;ImageSlider.prototype.setImageAt = function(index) &#123; // index번째 이미지 이동&#125; 어떤가요? 추상화 라는 말이 조금 어려워서 그렇지 추상화 단계에서 핵심은 클래스를 설계하는 작업 자체 입니다. 여기까지는 아주 단순한 객체 추상화였습니다. 이미지 슬라이더 추상화하기2 그럼 이번에는 좀더 복잡한 예를 들어보겠습니다. 다음은 앞에서 살펴본 심플 이미지 슬라이더를 추상화한 그림입니다. 다시 한 번 살펴보죠. 여기에서 주의 깊게 살펴볼 부분은 바로 정렬 기능 인터페이스 부분 입니다. 앞에서 간단하게 살펴본 TV객체의 경우 TV객체들이 공통으로 가지고 있어야 하는 내용을 추상화한 것처럼 심플 이미지 갤러리와 연결해서 사용하게 될 정렬 기능 객체들이 공통으로 가지고 있어야 하는 기능을 인터페이스를 이용해 추상화했습니다. 여기서 인터페이스를 사용한 이유는 앞에서 살펴본 것처럼 인터페이스와 연결되는 클래스는 반드시 인터페이스에 정의되어 있는 기능을 구현해야 하는 규약을 적용하기 위해서입니다. [객체지향 프로그래밍 기초] 절차지향 프로그래밍 VS 객체지향 프로그래밍 [객체지향 프로그래밍 기초] 객체지향 프로그래밍의 특징 [객체지향 프로그래밍 기초] 객체지향 프로그래밍 언어에서 제공하는 기본 기능 [객체지향 프로그래밍 특징] 추상화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서 추상화 [객체지향 프로그래밍 특징] 캡슐화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서의 캡슐화 [객체지향 프로그래밍 특징] 클래스 상속 소개 [객체지향 프로그래밍 특징] 클래스 상속 기능 [객체지향 프로그래밍 특징] 자바스크립트에서 클래스 상속 [객체지향 프로그래밍 특징] 자식 클래스와 부모 클래스 연동 처리 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버라이드 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버로딩 [객체지향 프로그래밍 특징] constructor 프로퍼티 활용 [객체지향 프로그래밍 특징] 클래스 상속 규칙 [객체지향 프로그래밍 특징] 다형성 소개 [객체지향 프로그래밍 특징] 다형성과 데이터 타입과의 관계 [객체지향 프로그래밍 특징] 자바스크립트에서 다형성 합성 소개 클래스 상속 VS 합성","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"},{"name":"객체지향 프로그래밍","slug":"JS/js-학습/객체지향-프로그래밍","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"}],"tags":[]},{"title":"[객체지향 프로그래밍 기초] 객체지향 프로그래밍 언어에서 제공하는 기본 기능","slug":"객체지향-프로그래밍-언어에서-제공하는-기본-기능","date":"2018-02-11T14:35:08.000Z","updated":"2018-03-30T00:54:12.513Z","comments":true,"path":"2018/02/11/객체지향-프로그래밍-언어에서-제공하는-기본-기능/","link":"","permalink":"https://recoveryman.github.io/2018/02/11/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%96%B8%EC%96%B4%EC%97%90%EC%84%9C-%EC%A0%9C%EA%B3%B5%ED%95%98%EB%8A%94-%EA%B8%B0%EB%B3%B8-%EA%B8%B0%EB%8A%A5/","excerpt":"","text":"기본 기능 종류일반적으로 객체지향 프로그래밍 언어의 경우 다음과 같이 기본적인 문법 세 가지를 제공합니다. 클래스(class) 인터페이스(interface) 추상클래스(abstract class) 이 세가지 문법을 조합해 객체 지향 프로그래밍의 네 가지 특징을 구현하게 됩니다. 선언 부분과 구현 부분먼저 기본 문법 세 가지를 이해하기 위해서는 선언 부분과 구현 부분에 대한 이해가 필요합니다. 일반적으로 객체는 선언 부분과 구현 부분으로 구성됩니다. 선언 부분선언 부분은 메서드 이름은 뭐고 매개변수는 몇 개인지 등의 메서드 정보가 바로 선언 부분입니다. 선언 부분을 달리 말하면 일종의 규칙입니다. 여기서 규칙이란 구현 부분에서는 선언 부분에 작성되어 있는 메서드 이름과 매개변수를 똑같이 만들어 구현해야 합니다. 그렇지 않으면 오류가 발생해 동작하지 않게 됩니다. 구현 부분구현 부분은 말 그대로 선언 부분에 있는 메서드의 기능을 직접 구현한 코드를 말합니다. 선언 부분과 구현 부분으로 나눠 구현하는 이유는?일반적으로 객체지향 프로그래밍의 경우 선언 부분과 구현 부분으로 나눠 작업을 합니다. 그리고 이를 위해 존재하는 문법이 객체지향 프로그래밍 기본 문법 세 가지 입니다. 먼저 이 기본 문법 세 가지와 선언 부분-구현 부분과의 관계를 살펴보면 다음과 같습니다. 부분 클래스 인터페이스 추상클래스 선언 부분 X O O 구현 부분 O X O 그렇다면 왜? 객체지향 프로그래밍에서는 선언 부분과 구현 부분으로 나눠 작업하는 것일까요? 바로! 객체지향 프로그래밍의 핵심 기능은 다형성(Polymorphism) 때문입니다. 다형성을 적용해 코드를 만들게 되면 특정 작업을 소스 수정을 거의 하지 않고 다양한 방법으로 연결해서 만들 수 있습니다. 클래스주 용도다시 한 번 정리하면 클래스(class)는 연관 있는 변수와 함수를 묶어 재사용하기 위해 사용하는 문법입니다. 선언 부분과 구현 부분의 개념을 적용해 클래스의 용도를 설명하면 클래스는 객체의 실제 동작을 처리하는 구현 부분을 맡게 됩니다. 예를 들어 지금까지 사용한 클래스는 독립적으로 작성하는 클래스 이기 때문에 잘 몰랐겠지만 사실 클래스는 다음과 같이 아직 배우지 않은 두 가지 문법과 조합되어 많이 사용됩니다. 클래스 + 인터페이스 클래스 + 추상클래스 클래스 + 추상클래스 + 인터페이스 이때 선언 부분은 인터페이스와 추상클래스 문법을 이용해 만들고 이들의 구현 부분은 바로 클래스가 담당하게 됩니다. 그럼 왜 선언 부분과 구현 부분을 나눠서 코딩을 할까요? 바로 객체지향 프로그래밍의 핵심인 다형성 때문입니다. 생김새 1234567891011121314151617// 클래스 정의function User(name, age) &#123; // 프로퍼티 만들기 this.userName = name; this.age = age;&#125;// 메서드 만들기User.prototype.showInfo = function() &#123; document.write(\"userName = \" + this.userName + \", age = \" + this.age);&#125;// 인스턴스 생성var user1 = new User(\"recoveryman\", 30);// 메서드 호출user1.showInfo(); 자바스크립트 지원 유무일반 객체지향 프로그래밍 언어의 경우 class라는 명령어를 이용해 클래스를 생성합니다. 하지만 아쉽게도 자바스크립트는 클래스 전용 명령어를 제공하진 않습니다. 대신 자바스크립트에서는 다음과 같이 세 가지 방법을 이용해 클래스를 비슷하게 만들어 사용할 수 있습니다. 오브젝트 리터럴 방식 함수 방식 프로토타입 방식 인터페이스주 용도앞서 설명한 것처럼 객체는 크게 선언 부분과 구현 부분으로 나눈다는 것을 배웠습니다. 인터페이스(interface)는 바로 구현 부분 없이 오직 선언 부분만을 만들 때 사용하는 문법입니다. 좀더 풀어 설명하자면 인터페이스(interface)는 객체가 반드시 구현해야 할 메서드 명세서를 만들 때 주로 사용한다고 볼 수 있습니다. 이렇게 만들어진 인터페이스는 클래스와 연결해 사용됩니다. 인터페이스와 연결한 클래스는 반드시 인터페이스에 명시된 대로 메서드를 만들어 실제 동작하는 구현 부분을 작성해야 합니다. 만약 메서드 이름과 매개변수 개수가 다른 경우 바로 에러가 납니다. 생김새자바스크립트에서는 문법적으로 인터페이스를 지원하지 않기 때문에 다른 언어는 어떻게 지원하는지 살펴봐야 합니다. [JAVA]123456789101112131415161718192021222324252627282930313233// 인터페이스 정의public interface IUser &#123; public void showInfo(); public void setUserName(String name);&#125;// 클래스 정의public class User implements IUser &#123; // 프로퍼티 만들기 private String userName = \"\"; private int age = 0; // 생성자 public User(name, age) &#123; this.userName = name; this.age = age; &#125; // 메서드 만들기 public void showInfo() &#123; System.out.println(\"userName = \" + this.userName + \", age = \" + this.age); &#125; public void setUserName(name) &#123; this.userName = name; &#125;&#125;// 인스턴스 생성User user1 = new User();// 메서드 호출user1.showInfo(); 객체지향 프로그래밍에서 알 수 있는 것처럼 일반 객체지향 프로그래밍의 경우 문법적으로 인터페이스를 지원하기 때문에 이 기능을 이용하면 선언 부분과 구현 부분을 나눠 작업할 수 있습니다. 자바스크립트 지원 유무일반 객체지향 프로그래밍의 경우 interface라는 명령어를 이용해 인터페이스를 생성합니다. 아쉽게도 자바스크립트에서는 인터페이스 문법을 지원하지 않습니다. 다시 한 번 언급하자면 여기서 지원하지 않는다는 의미는 인터페이스와 연결된 클래스에서 구현 코드 작성 시 인터페이스에 선언된 메서드와 다르게 만드는 경우 문법적으로 오류가 발생해 실행조차 할 수 없게 된다는 뜻입니다.바로 이런 경우를 ‘문법을 지원한다.’ 라고 합니다. 그럼 자바스크립트에서는 어떻게 인터페이스를 사용할까요? 자바스크립트에서는 그냥 인터페이스가 있다는 가정하에 코딩을 하는 방법밖에 없습니다. 추상 클래스주 용도추상 클래스(abstract class)를 이해하려면 우선 상속의 개념을 먼저 이해해야 합니다. 일단 간단히 설명하자면 상속은 부모 클래스의 기능을 자식 클래스에서 물려 받아 재사용 할 수 있는 기능 입니다. 흔하디 흔한 코드 복사(Ctrl + C), 코드 붙이기(Ctrl + V) 하나 없이 말이지요. 상속을 사용하다 보면 부모 클래스의 기능 중 특정 기능을 부모 클래스에서 구현하는 게 아니라 자식 클래스에게 구현하도록 강요해야 하는 경우가 발생합니다. 바로 이때 사용하는 문법이 추상 클래스 입니다. 자식 클래스에게 구현을 강요하고 싶은 기능을 부모 클래스의 추상 메서드로 만들어 줍니다. 추상 메서드는 클래스 내에 선언 부분만 있는 메서드를 말합니다. 추상 클래스를 상속받는 자식 클래스는 추상 클래스에 선언되어 있는 추상 메서드의 구현 코드를 반드시 작성해 줘야 합니다. 만약 구현하지 않는 경우 문법적으로 에러가 발생해 실행이 되질 않습니다. 정리해보면 추상 클래스는 일반 클래스 기능과 인터페이스 기능을 합한 형태입니다. 생김새 [부모 클래스(약간의 선언 부분과 구현 부분이 동시에 존재)]12345678910111213141516171819// 클래스 정의abstract class AUser &#123; // 프로퍼티 만들기 private String userName = \"\"; private int age = 0; // 생성자 public User(name, age) &#123; this.userName = name; this.age = age; &#125; // 메서드 만들기 public void showInfo() &#123; System.out.println(\"userName = \" + this.userName + \", age = \" + this.age); &#125; abstract void setUserName(name);&#125; [자식 클래스(구현 부분 존재)]12345678910111213// 클래스 정의public class MyUser extend AUser &#123; public void setUserName(name) &#123; this.userName = name; &#125;&#125;// 인스턴스 생성MyUser user1 = new MyUser();user1.setUserNmae(\"recoveryman\");// 메서드 호출user1.showInfo(); 자바스크립트 지원 유무일반 객체지향 프로그래밍의 경우 abstract라는 명령어를 이용해 추상 클래스와 추상 메서드를 생성합니다. 아쉽게도 자바스크립트에서는 추상 클래스를 위한 문법을 지원하지 않습니다. 그래서 자바스크립트 에서는 추상 클래스가 있다는 가정하에 작업하게 됩니다. UML 소개UML이란?방금 확인한 것처럼 언어마다 클래스와 인터페이스 그리고 추상 클래스 등을 표현하는 방식이 다르다는 것을 확인했습니다. 또, 클래스가 가지고 있는 메서드를 코드로 확인하는 경우 한눈에 파악하기 어려워집니다. 이를 위해서 객체지향 프로그래밍을 위해 UML이란 멋진 도구를 제공합니다. UML은 Unified Modeling Language의 약자로 특별한 의미가 있는 모형을 활용해 객체지향 분석 및 설계에 사용하는 모델링 언어입니다. UML은 수많은 기능을 갖고 있으며 이중 가장 기본적인 단위로 클래스와 인터페이스 그리고 추상 클래스를 비주얼적으로 모델링할 수 있는 기능을 제공합니다. UML로 클래스 표현하기UML로 클래스를 표현하면 다음과 같이 나타낼 수 있습니다. UML을 이용하면 프로그래밍 언어와 상관 없이 클래스를 비주얼하게 설계할 수 있습니다. 이와 동일한 방식으로 인터페이스와 추상 클래스를 표현해 보겠습니다. UML로 인터페이스 표현하기UML로 인터페이스를 표현하면 다음과 같습니다. 예를 들어 자바로 만든 IUser 인터페이스를 UML로 표현하면 다음과 같습니다. 12345// 인터페이스 정의public interface IUser &#123; public void showInfo(); public void setUserName(String name);&#125; IUser 인터페이스를 UML로 표현하면 다음과 같이 표현할 수 있어요. (interface)IUser showInfo()setUserName(name) UML로 추상 클래스 표현하기UML로 추상 클래스를 표현하면 다음과 같습니다. 예를 들어 자바로 만든 AUser 추상 클래스를 UML로 표현하면 다음과 같습니다. 1234abstact class Auser&#123; //... abstact void setUserName(name); // 추상 메서드&#125; AUser 추상클래스를 UML 로 표현하면 다음과 같이 표현할 수 있어요 AUser userName=””age = 0 User(name, age)showInfo()setUserName(name) [객체지향 프로그래밍 기초] 절차지향 프로그래밍 VS 객체지향 프로그래밍 [객체지향 프로그래밍 기초] 객체지향 프로그래밍의 특징 [객체지향 프로그래밍 기초] 객체지향 프로그래밍 언어에서 제공하는 기본 기능 [객체지향 프로그래밍 특징] 추상화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서 추상화 [객체지향 프로그래밍 특징] 캡슐화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서의 캡슐화 [객체지향 프로그래밍 특징] 클래스 상속 소개 [객체지향 프로그래밍 특징] 클래스 상속 기능 [객체지향 프로그래밍 특징] 자바스크립트에서 클래스 상속 [객체지향 프로그래밍 특징] 자식 클래스와 부모 클래스 연동 처리 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버라이드 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버로딩 [객체지향 프로그래밍 특징] constructor 프로퍼티 활용 [객체지향 프로그래밍 특징] 클래스 상속 규칙 [객체지향 프로그래밍 특징] 다형성 소개 [객체지향 프로그래밍 특징] 다형성과 데이터 타입과의 관계 [객체지향 프로그래밍 특징] 자바스크립트에서 다형성 합성 소개 클래스 상속 VS 합성","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"},{"name":"객체지향 프로그래밍","slug":"JS/js-학습/객체지향-프로그래밍","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"}],"tags":[]},{"title":"[객체지향 프로그래밍 기초] 객체지향 프로그래밍의 특징","slug":"객체지향-프로그래밍의-특징","date":"2018-02-11T13:41:21.000Z","updated":"2018-03-30T00:54:07.309Z","comments":true,"path":"2018/02/11/객체지향-프로그래밍의-특징/","link":"","permalink":"https://recoveryman.github.io/2018/02/11/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%98-%ED%8A%B9%EC%A7%95/","excerpt":"","text":"객체지향 프로그래밍의 특징 네 가지(추상화, 캡슐화, 상속, 다형성)와 객체지향 프로그래밍 학습법에 대해 알아보겠습니다. 객체지향 프로그래밍이란?간단한 의미의 객체지향 프로그래밍앞서 살펴본 것처럼 객체지향 프로그래밍이란 객체 단위로 기능을 나눠 구현하는 방식을 말합니다. 이때 클래스 문법은 객체의 속성과 기능을 작성할때 사용한다고 배웠습니다. 또한 클래스 단위 코딩 역시 객체 지향 프로그래밍에 포함된다고도 배웠습니다. 진정한 의미의 객체지향 프로그래밍객체지향 프로그래밍이란 일종의 논문과도 같은 연구 결과의 산물입니다. 이미 우리보다 훨씬 전부터 프로그래밍을 한 선배님들이 어떻게 하면 프로그래밍을 유지보수하기 쉽고 냄새 나지 않는 멋진 코드를 만들 수 있을까 수없이 노력한 끝에 완성한 최상의 결과물 입니다. 이 결과물에는 크게 네가지 특징이 담겨 있습니다. 간단하게 정리해보면 다음과 같습니다. 1)추상화(Abstraction)쉽게 말해 추상화는 설계하는 작업 자체를 나타냅니다. 예를 들어 세탁기를 클래스로 표현한다고 했을때 예상되는 프로퍼티와 메서드를 정의하게 되는데 바로 이 작업을 추상화라고 합니다. 추상화의 가장 큰 특징은 프로퍼티와 메서드의 이름을 작성하는 선언 부분만 만들 뿐 구현 소스를 구현하지 않는다는 점입니다. 연관 문법: 클래스, 추상 클래스, 인터페이스 2)캡슐화(Encapsulation)추상화 작업 내용 중 어떤 프로퍼티와 메서드는 외부에서 접근 가능하고 또 어떤 프로퍼티와 메서드는 외부에서 접근하지 못하게 해야 하는 경우가 있습니다. 바로 이 작업을 캡슐화라고 합니다. 예를 들어 세탁기의 기능 중 사용자에게는 세탁 명령과 세탁 진행 정보만 제공해주면 됩니다. 그 외의 기능은 세탁기 내부에서 일어나는 일이기 때문에 일반 사용자에게는 감춰져 있어야 하는 거죠. 연관 문법: 접근 지정자(private, protected, public) 3)상속(Inheritance)상속은 특정 클래스(부모 클래스)의 속성과 메서드를 하위(자식) 클래스가 물려받는 것을 의미합니다. 예를 들어 일반 세탁기에 말리는 기능이 필요한 경우 일반 세탁기의 기능을 상속받은 후 말리는 기능만 추가하면 일반 세탁기를 전혀 수정하지 않고 원하는 기능을 추가할 수 있습니다. 연관 문법: 상속 4)다형성(Polymorphism)다형성은 객체지향 프로그래밍의 핵심입니다. 다형성을 이용하면 선언 부분과 구현 부분을 나눠 다양하게 처리할 수 있습니다. 일종의 플러그인을 만든다고 보면 됩니다. 연관 문법: 상속, 인터페이스, 추상클래스, 합성 객체지향 프로그래밍 언어란?다시 한 번 설명하자면 객체지향 프로그래밍은 일종의 방법론일 뿐입니다. “이렇게 코딩하면 유지보수하기 쉬운 코드를 만들 수 있어요.” 와 같은 내용이 담긴 문서라는 거죠. 바로 객체지향 프로그래밍 언어란 객체지향 프로그래밍 방법론에 담긴 네 가지 특징을 사용할 수 있게 문법적으로 제공해주는 프로그래밍 언어를 말합니다. 오늘날 가장 대표적인 객체지향 프로그래밍 언어는 C#, JAVA, Objective-C이며 이들은 자기들만의 고유 방식으로 객체지향 프로그래밍 특징 네 가지를 구현하고 있으며 개발자가 사용할 수 있게 다양한 문법을 제공해 줍니다. 정리하자면, 문법이 다르더라도 어떤 방법으로든 객체지향 프로그래밍 특징 네 가지를 사용할 수 있게 되어 있다면 모두 객체지향 프로그래밍 언어로 부른다는 것입니다. 객체지향 프로그래밍 언어 학습법예를 들어 어느 날 회사에 아이폰 개발 의뢰가 들어와 Objective-C를 배워야 한다고 했을 때 예상 학습 기간은 어느 정도 걸릴 거라 생각되나요? 단, 오직 Objective-C 언어만을 배운다는 가정하에 말이지요(UI와 일반 라이브러리 기능 제외). 만약 객체지향 프로그래밍 특징 네 가지의 개념과 사용 용도를 이미 알고 있다면 넉넉잡아 10일 내외면 충분할 것입니다. 이유는 앞에서 알아본 것처럼 자바와 Objective-C 언어 모두 객체지향 프로그래밍 언어이기 때문입니다. “Objective-C는 클래스를 이렇게 만드는 구나, 오! 메서드를 참 특이하게 만드네, 인터페이스를 프로토콜이라고 부르는군!” 식으로 이미 자바에서 알고 사용한 객체지향 프로그래밍 개념을 비교해가며 쭉쭉! 넘어가는 것입니다. 중요한 건 바로 객체지향 프로그래밍 특징 네 가지 개념의 이해입니다. 정리하자면 객체지향 프로그래밍은 특징 네 가지를 저마다의 고유한 방법으로 제공하고 있기 때문에 지금 가장 자신 있게 사용하고 있는 프로그래밍 언어로 객체지향 프로그래밍 특징 네 가지를 배우면 됩니다. 자바스크립트는 객체지향 프로그래밍 언어인가요?결론부터 이야기하자면 아닙니다. 아쉽게도 자바스크립트는 객체지향 프로그래밍 언어가 갖추어야 할 특징 네 가지를 모두 지원하지 않습니다. 기껏해야 상속 정도만 제공하며 그 외의 기능은 거의 지원하지 않습니다. 지원하는 상속마저도 완벽하지 않습니다. 나머지 특징은 지원한다는 가정하에 비슷하게 만들어 사용하거나 아니면 아예 없는 걸로 간주하고 사용하지 않는 거죠. [객체지향 프로그래밍 기초] 절차지향 프로그래밍 VS 객체지향 프로그래밍 [객체지향 프로그래밍 기초] 객체지향 프로그래밍의 특징 [객체지향 프로그래밍 기초] 객체지향 프로그래밍 언어에서 제공하는 기본 기능 [객체지향 프로그래밍 특징] 추상화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서 추상화 [객체지향 프로그래밍 특징] 캡슐화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서의 캡슐화 [객체지향 프로그래밍 특징] 클래스 상속 소개 [객체지향 프로그래밍 특징] 클래스 상속 기능 [객체지향 프로그래밍 특징] 자바스크립트에서 클래스 상속 [객체지향 프로그래밍 특징] 자식 클래스와 부모 클래스 연동 처리 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버라이드 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버로딩 [객체지향 프로그래밍 특징] constructor 프로퍼티 활용 [객체지향 프로그래밍 특징] 클래스 상속 규칙 [객체지향 프로그래밍 특징] 다형성 소개 [객체지향 프로그래밍 특징] 다형성과 데이터 타입과의 관계 [객체지향 프로그래밍 특징] 자바스크립트에서 다형성 합성 소개 클래스 상속 VS 합성","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"},{"name":"객체지향 프로그래밍","slug":"JS/js-학습/객체지향-프로그래밍","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"}],"tags":[]},{"title":"[객체지향 프로그래밍 기초] 절차지향 프로그래밍 VS 객체지향 프로그래밍","slug":"절차지향-프로그래밍-VS-객체지향-프로그래밍","date":"2018-02-05T01:19:04.000Z","updated":"2018-03-30T00:54:18.362Z","comments":true,"path":"2018/02/05/절차지향-프로그래밍-VS-객체지향-프로그래밍/","link":"","permalink":"https://recoveryman.github.io/2018/02/05/%EC%A0%88%EC%B0%A8%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-VS-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/","excerpt":"","text":"일반적으로 프로그래밍 방식은 크게 절차지향 프로그래밍과 객체지향 프로그래밍 방식 두 가지로 나눌 수 있습니다. 이 두가지 방식을 비교해가며 객체지향 프로그래밍에 대해 알아보겠습니다. 절차지향 프로그래밍정의절차지향 프로그래밍(Procedural Oriented Programming)은 문제를 여러 개의 작은 함수로 나눠 작성하며 이 함수들을 원하는 순서에 맞게 작성하는 방식을 말합니다. 이 방식은 전통적인 프로그래밍 방식이며 C, 파스칼 코볼과 같은 초기 프로그래밍 언어가 대표적으로 지원하는 방식입니다. 여기서 지원한다는 의미는 절차적으로 실행할 수 있는 다양한 문법을 제공한다는 의미입니다. 절차지향 프로그래밍 특징절차지향 프로그래밍의 가장 큰 특징은 처리 부분인 함수들에서 전역 데이터를 공유해서 사용한다는 점 입니다. 데이터는 일반적으로 전역 데이터로 만들어지며 함수 호출 시 공유 데이터를 매개변수 값으로 넘기는 구조로 되어 있습니다. 절차지향 프로그래밍 예다음 코드는 함수 기반 탭메뉴 입니다. 먼저 코드를 자세히 보세요. 1234567891011121314151617181920212223242526var $tab1MenuItems = null, $tab2MenuITems = null;$(function() &#123; // 탭메뉴 데이터 생성 $tab1MenuItems = $('.tab1 li'); $tab2MenuItems = $('.tab2 li'); // 탭메뉴 생성 tabMenu($tab1MenuItems); tabMenu($tab2MenuItems);&#125;);// 탭메뉴 생성function tabMenu($menuItems) &#123; $menuItems.click(function(e) &#123; e.preventDefault(); selectMenuItemAt($menuItems, $(this).index()); &#125;)&#125;// n번째 탭메뉴 선택function selectMenuItemAt($menuItems, index) &#123; $menuItems.removeClass(\"on\"); $menuItems.eq(index).addClass(\"on\");&#125; 소스코드 다운받기 설명지금까지 만든 탭메뉴와 약간 다르지만 내용은 모두 같기 때문에 쉽게 이해할 수 있을 것입니다. 코들에서 주의 깊게 살펴볼 내용은 탭메뉴를 생성하는 tabMenu() 함수를 호출할 때와 n번째 탭메뉴를 선택할 수 있는 selectMenuItemAt() 함수를 호출할 때 탭메뉴 아이템 정보($menuItems)를 내부에 가지고 있는 구조가 아니라 매개변수 값으로 넘겨 사용하는 것을 알 수 있습니다. 이는 전형적인 절차지향 프로그래밍 구조입니다. 또한 선택한 탭메뉴 아이템이 없는 상태로 만드는 리셋 처리 기능을 추가하는 아래 예제와 같은 코딩 방법 역시 절차지향 프로그래밍 구조입니다. 1234567891011121314151617181920212223242526272829303132333435363738var $tab1MenuItems = null, $tab2MenuITems = null;$(function() &#123; // 탭메뉴 데이터 생성 $tab1MenuItems = $('.tab1 li'); $tab2MenuItems = $('.tab2 li'); // 탭메뉴 생성 tabMenu($tab1MenuItems); tabMenu($tab2MenuItems); // 탭메뉴 선택 초기화 $('.btnReset').click(function(e) &#123; e.preventDefault(); resetTabMenu($tab1MenuItems); resetTabMenu($tab2MenuItems); &#125;)&#125;);// 탭메뉴 생성function tabMenu($menuItems) &#123; $menuItems.click(function(e) &#123; e.preventDefault(); selectMenuItemAt($menuItems, $(this).index()); &#125;)&#125;// n번째 탭메뉴 선택function selectMenuItemAt($menuItems, index) &#123; $menuItems.removeClass(\"on\"); $menuItems.eq(index).addClass(\"on\");&#125;// 탭메뉴 선택 초기화function resetTabMenu($menuItems) &#123; $menuItems.removeClass(\"on\");&#125; 소스코드 다운받기 설명리셋 버튼 클릭시 선택 초기화를 처리하는 resetTabMenu() 함수를 호출할 때도 메뉴 아이템($menuItems) 정보를 매개 변수 값으로 넘겨 사용하는 것을 알 수 있습니다. 바로 이런 구조를 절차지향 프로그래밍 이라고 부릅니다. 절차지향 프로그래밍의 단점앞의 예제를 통해 확인한 것처럼 절차지향 프로그래밍은 함수 호출 시 전역 데이터를 매개변수 값으로 넘겨 공유해서 사용하는 구조이기 때문에 전역 데이터가 잘못 처리될 수 있는 치명적인 단점을 가지고 있습니다. 즉 데이터가 보호되지 않는다는 의미입니다. 또 하나의 단점은 전역 데이터를 넘겨 받는 식의 구조이다 보니 하나의 프로젝트를 여러 사람으로 나눠 작업하는 방식에는 적합하지 않습니다. 이런 단점 때문에 절차지향 프로그래밍은 규모가 있는 프로젝트에 사용하기 보다 비교적 간단한 프로젝트에 주로 사용합니다. 예를 들자면 간단한 웹사이트 제작 시 내비게이션이나 이미지 슬라이더 그리고 배너 등을 만들 때 함수 단위 코딩을 하는 경우가 바로 절차지향 프로그래밍의 대표적인 예입니다. 절차지향 프로그래밍과 구조적 프로그래밍 그리고 함수기반 프로그래밍아마도 절차지향 프로그래밍 정보를 찾아본 분이라면 절차적 프로그래밍과 많이 비슷한 구조적 프로그래밍과 함수 기반 프로그래밍에 대해 궁금증이 생길 것입니다. 정확한 의미로 보자면 모두 차이점이 있지만 핵심은 세 가지 모두 데이터를 전역에 두고 함수 매개변수 값으로 넘기는 방식으로 대부분의 작업을 처리 한다는 점입니다. 객체지향 프로그래밍정의객체지향 프로그래밍(Object Oriented Programming)은 문제를 여러 개의 객체 단위로 나눠 작업하는 방식을 말합니다. 이 방식은 오늘날 가장 많이 사용하는 대표적인 프로그래밍 방식입니다. JAVA, C#등이 대표적인 객체지향 프로그래밍 언어 입니다. 객체지향 프로그래밍 특징객체지향 프로그래밍의 가장 큰 특징은 클래스를 이용해 연관 있는 처리부분(함수)과 데이터 부분(변수)을 하나로 묶어 객체(인스턴스)를 생성해 사용한다는 점입니다. 객체지향 프로그래밍 예 1234567891011121314151617181920212223242526272829303132$(function() &#123; // 탭메뉴 생성 var tabMenu1 = new TabMenu('.tab1'); var tabMenu2 = new TabMenu('.tab2');&#125;);// 탭메뉴 클래스function TabMenu(selector) &#123; this.init(selector); this.initEvent();&#125;// 탭메뉴 요소 초기화TabMenu.prototype.init = function(selector) &#123; this.tabMenu = $(selector); this.$menuItems = this.tabMenu.find('li');&#125;// 이벤트 초기화TabMenu.prototype.initEvent = function() &#123; var objectThis = this; this.$menuItems.on('click', function(e) &#123; e.preventDefault(); objectThis.setSelectMenuItemAt($(this).index()); &#125;)&#125;// n번째 탭메뉴 선택TabMenu.prototype.setSelectMenuItemAt = function(index) &#123; this.$menuItems.removeClass('on'); this.$menuItems.eq(index).addClass('on');&#125; 소스코드 다운받기 설명코드를 살펴보면 탭메뉴와 관련 있는 기능과 데이터를 모두 TabMenu라는 클래스에 묶여 있으며 이 클래스를 이용해 독립적으로 동작하는 탭메뉴 객체(인스턴스)를 만들었습니다. 이로써 기능을 실행할 때마다 데이터를 넘길 필요 없이 “객체군! 이 기능을 처리하세요.” 식으로 객체 단위로 처리할 수 있습니다. 또한 리셋 처리 기능을 추가하는 경우 다음 예제와 같이 클래스에 메서드를 추가해 객체 단위로 작업할 수 있습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243$(function() &#123; // 탭메뉴 생성 var tabMenu1 = new TabMenu('.tab1'); var tabMenu2 = new TabMenu('.tab2'); $('.btnReset').on('click', function(e) &#123; e.preventDefault(); tabMenu1.resetTabMenu(); tabMenu2.resetTabMenu(); &#125;)&#125;);// 탭메뉴 클래스function TabMenu(selector) &#123; this.init(selector); this.initEvent();&#125;// 탭메뉴 요소 초기화TabMenu.prototype.init = function(selector) &#123; this.tabMenu = $(selector); this.$menuItems = this.tabMenu.find('li');&#125;// 이벤트 초기화TabMenu.prototype.initEvent = function() &#123; var objectThis = this; this.$menuItems.on('click', function(e) &#123; e.preventDefault(); objectThis.setSelectMenuItemAt($(this).index()); &#125;)&#125;// n번째 탭메뉴 선택TabMenu.prototype.setSelectMenuItemAt = function(index) &#123; this.$menuItems.removeClass('on'); this.$menuItems.eq(index).addClass('on');&#125;// 탭메뉴 선택 초기화TabMenu.prototype.resetTabMenu = function() &#123; this.$menuItems.removeClass(\"on\");&#125; 소스코드 다운받기 설명리셋 버튼 클릭 시 선택메뉴를 초기화하고 싶은 경우에도 객체 단위로 resetTabMenu() 메서드를 호출해 각각 처리할 수 있습니다. 객체지향 프로그래밍의 장점앞의 예제를 통해 확인한 것처럼 객체지향 프로그래밍에서는 프로젝트를 독립적인 객체 단위로 분리해서 작업할 수 있기 때문에 여러 개발자와 협업해 규모가 큰 프로젝트를 진행할 수 있는 장점이 있습니다. 객체지향 프로그래밍을 이용하면 여러 개의 객체로 나눠 작업할 수 있습니다. 객체지향 프로그래밍 vs 클래스 기반 프로그래밍위의 글을 보면 클래스 단위 프로그래밍과 객체지향 프로그래밍이 똑같은 내용 아닐까 라고 생각하실 수 있을꺼 같습니다. 결론 부터 이야기 하자면 맞는 말일 수도 있고 아닐 수도 있습니다. 먼저 엄격한 의미해서 해석하면 이 둘은 다음과 같은 차이점이 있습니다. 일반적으로 객체지향 프로그래밍은 객체지향 프로그래밍 네 가지 특징(추상화, 캡슐화, 상속, 다형성)을 골고루 사용해 코딩하는 프로그래밍을 객체지향이라고 부릅니다. 클래스 단위 프로그래밍은 이런 객체지향 특징을 전혀 사용하지 않고 오직 클래스만을 이용해 코딩하는 방식을 말합니다. 이처럼 이 둘은 전혀 다른 프로그래밍 방법입니다. 이와 반대로 클래스 단위 코딩을 객체지향 프로그래밍이라고 부를 수 있는 이유는 클래스를 만들어 코딩하는 자체에 이미 객체지향 프로그래밍 네 가지 특성 중 추상화와 캡슐화를 사용하고 있기 때문입니다. 이처럼 클래스 기반 프로그래밍은 객체지향 프로그래밍에 포함되는 구조를 가지고 있습니다. 그리고 중요한 사실을 하나 알려드리자면 객체지향 프로그래밍을 배우려면 우선 클래스 기반 프로그래밍에 익숙해 있어야 한다는 점입니다. 이유는 앞에서도 언급한 것처럼 객체를 만드는 수단이 클래스이기 때문입니다. 절차지향 프로그래밍 vs 객체지향 프로그래밍그럼 이제부터 무조건 객체지향 프로그래밍을 이용해서 작업해야 하는 걸까요? 아닙니다. 무조건 객체지향 프로그래밍을 할 필요는 없습니다. 간단한 테스트나 프로젝트를 진행하기 위해 함수 기반인 절차지향 방식으로 하면 쉽게 해결할 수 있는 걸 아직 익숙하지도 않은 객체지향 프로그래밍으로 굳이 할 필요는 없습니다. 즉 필요에 따라 두 가지 방식 중 하나를 선택해서 사용하면 됩니다. 만약 규모 있는 사이트나 웹앱 제작이 목적이라면 간단한 예제를 가지고 객체지향 프로그래밍을 연습해보는 것도 좋은 방법입니다. 구분 절차지향 프로그래밍 객체지향 프로그래밍 처리방식 문제를 여러 개의 함수로 나눠 순차적으로 호출해 처리하는 방식 문제를 여러 개의 객체 단위로 나눠 처리하는 방식 단점 오래전 방식이며 협업해서 진행하는 큰 프로젝트에 맞지 않음 학습 난이도가 높음개발자의 활용 능력이 무엇보다 중요 장점 간단한 프로젝트에 용이함비교적 배우기 쉬움 요즘 가장 많이 사용하는 방식협업에서 진행하는 큰 프로젝트에 적합함 [객체지향 프로그래밍 기초] 절차지향 프로그래밍 VS 객체지향 프로그래밍 [객체지향 프로그래밍 기초] 객체지향 프로그래밍의 특징 [객체지향 프로그래밍 기초] 객체지향 프로그래밍 언어에서 제공하는 기본 기능 [객체지향 프로그래밍 특징] 추상화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서 추상화 [객체지향 프로그래밍 특징] 캡슐화 소개 [객체지향 프로그래밍 특징] 자바스크립트에서의 캡슐화 [객체지향 프로그래밍 특징] 클래스 상속 소개 [객체지향 프로그래밍 특징] 클래스 상속 기능 [객체지향 프로그래밍 특징] 자바스크립트에서 클래스 상속 [객체지향 프로그래밍 특징] 자식 클래스와 부모 클래스 연동 처리 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버라이드 [객체지향 프로그래밍 특징] 자바스크립트에서 메서드 오버로딩 [객체지향 프로그래밍 특징] constructor 프로퍼티 활용 [객체지향 프로그래밍 특징] 클래스 상속 규칙 [객체지향 프로그래밍 특징] 다형성 소개 [객체지향 프로그래밍 특징] 다형성과 데이터 타입과의 관계 [객체지향 프로그래밍 특징] 자바스크립트에서 다형성 합성 소개 클래스 상속 VS 합성","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"},{"name":"객체지향 프로그래밍","slug":"JS/js-학습/객체지향-프로그래밍","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/"}],"tags":[]},{"title":"[jQuery플러그인제작] extend() 메서드를 활용한 플러그인 옵션 처리","slug":"jQuery플러그인제작-extend-메서드를-활용한-플러그인-옵션-처리","date":"2018-01-15T01:38:11.000Z","updated":"2018-02-04T12:44:58.000Z","comments":true,"path":"2018/01/15/jQuery플러그인제작-extend-메서드를-활용한-플러그인-옵션-처리/","link":"","permalink":"https://recoveryman.github.io/2018/01/15/jQuery%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8%EC%A0%9C%EC%9E%91-extend-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EC%98%B5%EC%85%98-%EC%B2%98%EB%A6%AC/","excerpt":"","text":"jQuery 플러그인의 경우 기능을 변경할 수 있는 옵션값이 존재합니다. jQuery 에서 제공하는 extend() 메서드를 활용해 좀 더 효율적인 옵션값 처리 방법을 학습해 보겠습니다. 기본 옵션값플러그인을 만들다 보면 플러그인 호출 시 넘겨야 하는 매개변수 값이 많은 경우가 있습니다. 이 값들은 주로 옵션값 입니다. 옵션값은 일반적으로 jQuery 플러그인을 만들때 기본 옶션값을 만들어 사용하고 사용자가 필요로 할때 원하는 값으로 변경할 수 있는 구조로 만듭니다. 먼저 [jQuery플러그인제작] jQuery 플러그인 만들기 에서 예제로 만들어 봤던 플러그인을 확인해 보겠습니다.소스코드 다운받기 [javascript]1234567891011121314151617(function($) &#123; $.fn.removeLi = function() &#123; this.each(function(index) &#123; var $target = $(this); $target.delay(index * 1000).animate(&#123; height: 0 &#125;, 500, \"easeInQuint\" function() &#123; $target.remove(); &#125;) &#125;) return this; &#125;&#125;)(jQuery)$(function() &#123; $(\".menu\").removeLi();&#125;) 코드를 살펴보면 지연시간(5번라인: 1000)과 애니메이션 진행시간(7번라인: 500) 그리고 이징값(7번라인 500 뒤)이 각각 1000밀리초, 500밀리초, “easeInQuint”로 고정돼 있는 것을 확인할 수 있습니다. 현재로서는 이들의 값을 수정해야 하는 경우 플러그인의 내부 코드를 직접 수정해줘야 합니다. 이들의 값을 좀더 쉽게 수정할 수 있게 플러그인에 옵션 값을 추가해 보겠습니다. 추가로 플러그인의 기본 옵션값을 만들어 사용자가 옵션값을 설정하지 않는 경우 기본 옵션값이 적용되게 만들어 보겠습니다. 먼저 풀이 순서에 맞게 다음 내용을 입력해 주세요. 12345678910111213141516171819202122232425262728293031// 플러그인 만들기(function($) &#123; $.defaultOption = &#123; duration: 500, easing: \"easeInQuint\", delayTime: 1000 &#125; $.fn.removeAni = function(duration, easing, delayTime) &#123; // 사용자 옵션 정보 유무 판단 후, 값이 없는 경우 기본값으로 설정 duration = duration || $.defaultOption.duration; easing = easing || $.defaultOption.easing; delayTime = delayTime || $.defaultOption.delayTime; // 옵션값을 변경 this.each(function(index) &#123; var $target = $(this); $target.delay(index * delayTime).animate(&#123; height: 0 &#125;, duration, easing, function() &#123; $target.remove(); &#125;) &#125;) return this; &#125;&#125;)(jQuery)$(function() &#123; // 플러그인 호출 $('.menu li').removeAni();&#125;) 소스코드 다운받기 상단 코드를 기준으로 3번라인: 먼저 오브젝트 리터럴을 이용해 기본 옵션값을 만듭니다. $.defaultOption = {} 9번라인: removeAni 플러그인에 매개변수(duration, easing, delayTime)를 신규로 추가해 줍니다. $.fn.removeAni = function(duration, easing, delayTime) {} 11~13번라인: 옵션값이 없는 경우 기본 옵션값으로 설정할 수 있게 구문을 작성합니다. duration = duration || $.defaultOption.duration; easing = easing || $.defaultOption.easing; delayTime = delayTime || $.defaultOption.delayTime; 20번라인: animate() 메서드에 하드 코딩된 애니메이션 시 값과 이징 함수 값 그리고 지연시간 값 대신 매개변수를 채워 줍니다. $target.delay(index * delayTime).animate({height: 0 }, duration, easing, function() {$target.remove(); }) 소스코드를 다운받아서 removeAni플러그인을 실행시켜 보세요! 123456789/*@ duration = Type: number@ easing = Type: string@ delayTime = Type: number*/$(function() &#123; // 플러그인 호출 $('.menu li').removeAni(duration, easing, delayTime);&#125;) jQuery의 extend() 메서드 소개1 소개jQuery의 extend() 메서드는 객체의 기능(프로퍼티와 메서드)을 합칠 때 사용하는 메서드 입니다. 이 기능은 특히 플러그인 제작 시 옵션값 처리에 유용하게 사용됩니다. 사용법var result = jQuery.extend(target[,object1][,objectN]); 매개변수target: 합쳐진 기능을 최종적으로 저장할 객체object1, objectN: 합쳐질 기능을 가진 객체 리턴값리턴값은 target에 저장되는 값과 같습니다. extend() 메서드 기능예제를 통해 extend() 메서드의 기능을 알아보겠습니다. 12345678910111213141516171819202122232425262728$(function() &#123; var target = &#123; property1: \"a\", property2: \"b\", method1: function() &#123; console.log(\"m1()\"); &#125;, method2: function() &#123; console.log(\"m2()\"); &#125; &#125; var object1 = &#123; property1: \"1_a\", property3: \"1_c\", method1: function() &#123; console.log(\"1_m1()\"); &#125;, method3: function() &#123; console.log(\"1_m3()\"); &#125; &#125; var result = jQuery.extend(target, object1); console.log(\"target = \", target); console.log(\"object1 = \", object1); console.log(\"result = \", result);&#125;) 소스코드 다운받기 결과 설명코드 입력 후 실행 결과를 살펴보면 object1의 기능이 모두 target으로 합쳐지는 것을 확인할 수 있습니다. 또, target과 object1이 같은 기능을 가진 경우 target의 기능은 무시되고 object1의 기능이 우선적으로 합쳐지는 것을 확인할 수 있습니다. 팁var result = jQuery.extend(target, object1); 이 코드는var result = $.extend(target, object1); 이렇게 줄여 쓸 수 있습니다. extend 메서드 사용 시 주의사항 및 해결책extend() 메서드 사용 시 주의해야 할 사실이 하나 있는데요. 앞 예제의 실행 결과에서도 알 수 있는 것처럼 extend() 메서드 실행 후 target 자체도 변경된다는 것입니다. 즉 target과 extend() 메서드의 결과 값이 같게 된다는 것입니다. 뒤에서 설명하겠지만 플러그인에서 extend() 메서드를 활용해 옵션값을 처리할 때 target에 해당하는 기본 옵션값이 변경되면 안 되는 경우가 있습니다. 이때는 다음과 같이 첫 번째 매개변수 값이 빈 값을 넣어주면 됩니다. 예제 실행 후 결과를 확인해 봅시다. 123456789101112131415161718192021222324252627282930$(function() &#123; var target = &#123; property1: \"a\", property2: \"b\", method1: function() &#123; console.log(\"m1()\"); &#125;, method2: function() &#123; console.log(\"m2()\"); &#125; &#125; var object1 = &#123; property1: \"1_a\", property3: \"1_c\", method1: function() &#123; console.log(\"1_m1()\"); &#125;, method3: function() &#123; console.log(\"1_m3()\"); &#125; &#125; var result = $.extend(null, target, object1); // 또는 // var result = jQuery.extend(&#123;&#125;, target, object1); console.log(\"target = \", target); console.log(\"object1 = \", object1); console.log(\"result = \", result);&#125;) 소스코드 다운받기 결과 이어서 extend가 jQuery 플러그인에서 어떻게 유용하게 사용되는지 알아보겠습니다. extend() 메서드를 활용한 플러그인 옵션 처리extend() 메서드를 활용하면 좀 더 쉽게 플러그인 옵션 처리를 할 수 있습니다. 다음 내용은 앞에서 만든 removeAni 플러그인에 extend() 메서드를 활용해 옵션 처리를 한 예제입니다. 123456789101112131415161718192021222324252627282930313233// 플러그인 만들기(function($) &#123; $.defaultOption = &#123; duration: 500, easing: \"easeInQuint\", delayTime: 1000 &#125; $.fn.removeAni = function(options) &#123; // 사용자 옵션 정보 유무 판단 후, 값이 없는 경우 기본값으로 설정 options = $.extend(null, $.defaultOption, options); // 옵션값을 변경 this.each(function(index) &#123; var $target = $(this); $target.delay(index * options.delayTime).animate(&#123; height: 0 &#125;, options.duration, options.easing, function() &#123; $target.remove(); &#125;) &#125;) return this; &#125;&#125;)(jQuery)$(function() &#123; // 플러그인 호출 $('.menu li').removeAni(&#123; duration: 1000, easing: \"easeOutElastic\", delayTime: 500 &#125;);&#125;) 소스코드 다운받기 설명 9번라인: 먼저 removeAni 플러그인에서 옵션값을 3개의 매개변수(duration, easing, delayTime) 대신 하나의 오브젝트 리터럴을 만들어 사용할 것이기 때문에 매개변수를 하나의 매개변수로 변경해 줍니다. $.fn.removeAni = function(options) {} 11번라인: extend() 메서드를 활용해 기본 옵션값과 사용자가 입력한 옵션값을 합쳐 줍니다. options = $.extend(null, $.defaultOption, options); 16,18번라인: 지연시간과 애니메이션 시간 그리고 이징 함수 정보를 11번 라인에서 만든 옵션값으로 변경해 줍니다. $target.delay(index * options.delayTime).animate({height: 0 }, options.duration, options.easing, function() {$target.remove(); }) 29~31번라인: 옵션값을 오브젝트 리터럴로 변경해 줍니다. [jQuery플러그인제작] jQuery 확장 소개 [jQuery플러그인제작] jQuery유틸리티 만들기 [jQuery플러그인제작] jQuery 플러그인 만들기 [jQuery플러그인제작] 함수 기반 플러그인 만들기 [jQuery플러그인제작] 클래스 기반 플러그인 만들기 [jQuery플러그인제작] 플러그인 그룹 만들기 [jQuery플러그인제작] extend() 메서드를 활용한 플러그인 옵션 처리","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"}],"tags":[]},{"title":"[jQuery플러그인제작] 플러그인 그룹 만들기","slug":"jQuery플러그인제작-플러그인-그룹-만들기","date":"2018-01-10T23:30:29.000Z","updated":"2018-01-15T01:39:42.000Z","comments":true,"path":"2018/01/11/jQuery플러그인제작-플러그인-그룹-만들기/","link":"","permalink":"https://recoveryman.github.io/2018/01/11/jQuery%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8%EC%A0%9C%EC%9E%91-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EA%B7%B8%EB%A3%B9-%EB%A7%8C%EB%93%A4%EA%B8%B0/","excerpt":"","text":"jQuery 플러그인을 만들다 보면 하나 이상의 연관된 플러그인을 만들게 됩니다. 이 포스팅에서는 플러그인 그룹 만드는 방법과 플러그인 간의 연동 방법을 해보겠습니다. 소개플러그인 그룹이란 연관된 클래스 기반으로 jQuery 플러그인을 만들 때 클래스 인스턴스를 연관 있는 플러그인에서 공유 해서 사용하는 구조룰 의미합니다. 예제[jQuery플러그인제작] 클래스 기반 플러그인 만들기에서 만든 tabMenu 플러그인을 좀 더 확장해 보겠습니다. 소스코드 다운받기 이전장 마지막에 적어놨던것과 같이 페이지 로딩 시 원하는 탭메뉴의 원하는 탭을 미리 선택하는 기능을 만들어 보겠습니다. [플러그인 그룹 플러그인 js 코드]12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273(function($) &#123; function TabMenu(selector) &#123; var $tabMenu = null; var $menuItems = null; var $selectMenuItem = null; // 요소 초기화 및 이벤트 등록 호출 this.init(selector); this.initEvent(); &#125; // 요소 초기화 TabMenu.prototype.init = function(selector) &#123; this.$tabMenu = $(selector); this.$menuItems = this.$tabMenu.find(\"ul\").find(\"li\"); &#125; // 이벤트 등록 TabMenu.prototype.initEvent = function() &#123; var objThis = this; this.$menuItems.on('click', function(e) &#123; e.preventDefault(); objThis.setSelectItem($(this)); &#125;) &#125; // $menuItem에 해당하는 메뉴 아이템 선택하기 TabMenu.prototype.setSelectItem = function($menuItem) &#123; // 기존 선택메뉴 아이템을 비활성화 처리 if(this.$selectMenuItem)&#123; this.$selectMenuItem.removeClass('on'); &#125; // 신규 아이템 활성화 처리하기 this.$selectMenuItem = $menuItem; this.$selectMenuItem.addClass('on'); &#125; // 인덱스에 해당하는 메뉴 아이템 선택하기 TabMenu.prototype.setSelectItemAt = function(index) &#123; var $menuItem = this.$menuItems.eq(index); // 기존 메서드 재사용 this.setSelectItem($menuItem); &#125; $.fn.tabMenu = function() &#123; this.each(function(index) &#123; // 인스턴스 생성 var tabMenu = new TabMenu(this); $(this).data(\"tabMenu\", tabMenu); &#125;) return this; &#125; // n번째 탭메뉴 아이템 선택하기 $.fn.selectTabMenuItemAt = function(selectIndex) &#123; this.each(function(index) &#123; // 저장한 TabMenu 객체 구하기 var tabMenu = $(this).data(\"tabMenu\"); if(tabMenu) &#123; // n번째 메뉴 아이템 선택하기 tabMenu.setSelectItem(tabMenu.$menuItems.eq(selectIndex)) &#125; &#125;) return this; &#125;&#125;)(jQuery)$(function() &#123; $(\".tab1\").tabMenu().selectTabMenuItemAt(1); $(\".tab2\").tabMenu().selectTabMenuItemAt(2);&#125;) 결과소스코드 다운받기 우선 [플러그인 그룹 플러그인 js 코드] 기준으로 51번 라인: 먼저 기존 tabMenu 플러그인 구문에 생성한 TabMenu 클래스 인스턴스를 data()를 활용해 저장합니다. data() 메서드를 통해서 어떤 값이 들어가 있는지 확인이 가능합니다. 57번 라인: n번째 탭메뉴 아이템을 선택하는 플러그인(selectTabMenuItemAt)을 신규로 만듭니다. 이 selectTabMenuItemAt 플러그인은 n번째 탭메뉴를 선택하게 하는 플러그인 입니다. 60번 라인: 51번 라인에서 저장한 탭메뉴 인스턴스를 구합니다. 아래와 같은 형태의 값이 변수에 담기게 됩니다. 63번 라인: 이 라인은 if 문으로 감싸져 있습니다. if 문에서는 60번 라인의 지역변수 tabMenu에 값이 담기게 되어 true를 반환합니다. 그래서 그 안의 63번째 라인이 실행되는데요. 탭메뉴에서 제공하는 setSelectItem() 메서드를 호출해 n번째에 해당하는 메뉴 아이템을 활성화해 주는 기능을 하고 있습니다. 아래 그림을 보시면 63번 라인의 코드에 대한 의미를 알 수 있습니다. 결론플러그인 그룹이란?예제를 가지고 설명하면 tabMenu 플러그인과 selectTabMenuItemAt 플러그인이 탭메뉴 플러그인 그룹이 됩니다. 플러그인 그룹 구조특정 플러그인에서 생성한 클래스의 인스턴스를 다른 플러그인에서 재사용 해야하는 경우 jQuery의 data() 메서드를 활용해 생성한 인스턴스를 저장해 재사용 하면 됩니다. [jQuery플러그인제작] jQuery 확장 소개 [jQuery플러그인제작] jQuery유틸리티 만들기 [jQuery플러그인제작] jQuery 플러그인 만들기 [jQuery플러그인제작] 함수 기반 플러그인 만들기 [jQuery플러그인제작] 클래스 기반 플러그인 만들기 [jQuery플러그인제작] 플러그인 그룹 만들기 [jQuery플러그인제작] extend() 메서드를 활용한 플러그인 옵션 처리","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"}],"tags":[]},{"title":"[jQuery플러그인제작] 클래스 기반 플러그인 만들기","slug":"jQuery플러그인제작-클래스-기반-플러그인-만들기","date":"2018-01-10T07:22:45.000Z","updated":"2018-01-15T01:39:54.000Z","comments":true,"path":"2018/01/10/jQuery플러그인제작-클래스-기반-플러그인-만들기/","link":"","permalink":"https://recoveryman.github.io/2018/01/10/jQuery%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8%EC%A0%9C%EC%9E%91-%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B8%B0%EB%B0%98-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/","excerpt":"","text":"01. 문법123456789101112131415161718192021(function($) &#123; function MyClass() &#123; this.프로퍼티1; this.프로퍼티2; // ... &#125; MyClass.prototype.메서드1 = function() &#123; // ... &#125; MyClass.prototype.메서드2 = function() &#123; // ... &#125; $.fn.플러그인이름 = function() &#123; this.each(function(index) &#123; // 인스턴스 생성 var obj = new MyClass(); &#125;) return this; &#125;&#125;)(jQuery) 문법을 살펴보면 기능을 prototype 기반 클래스로 만든 후 플러그인 에서 클래스 인스턴스를 생성한 후 사용하는 구조로 돼 있습니다. 이렇게 구성하면 [jQuery플러그인제작] 함수 기반 플러그인 만들기 에서 가지고 있던 문제점을 해결할 수 있습니다. 예를 들어 탭메뉴가 3개라면 init(), initEvent(), setSelectItem() 메서드는 모두 prototype 에 만들어지기 때문에 공유해서 사용됩니다. 또한 이 메서드들은 오직 한번만 만들어 집니다. 참고: 함수 단위 코딩vs클래스 단위 코딩 02. 예제예제를 해보기 전에 먼저 함수 단위 코딩vs클래스 단위 코딩에서 만들어 보았던 예제 하나를 먼저 확인해 보겠습니다.소스코드 다운받기위의 코드를 클래스 기반 플러그인으로 제작하기. 풀이클래스 기반 플러그인 역시 jQuery 플러그인 문법에 맞게 플러그인 기본 구조를 만들어 줍니다. 코드에 대한 설명은 [jQuery플러그인제작] 함수 기반 플러그인 만들기에서 하단의 클래스 단위 코딩을 참고하시기 바랍니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354(function($) &#123; function TabMenu(selector) &#123; var $tabMenu = null; var $menuItems = null; var $selectMenuItem = null; // 요소 초기화 및 이벤트 등록 호출 this.init(selector); this.initEvent(); &#125; // 요소 초기화 TabMenu.prototype.init = function(selector) &#123; this.$tabMenu = $(selector); this.$menuItems = this.$tabMenu.find(\"ul\").find(\"li\"); &#125; // 이벤트 등록 TabMenu.prototype.initEvent = function() &#123; var objThis = this; this.$menuItems.on('click', function(e) &#123; e.preventDefault(); objThis.setSelectItem($(this)); &#125;) &#125; // $menuItem에 해당하는 메뉴 아이템 선택하기 TabMenu.prototype.setSelectItem = function($menuItem) &#123; // 기존 선택메뉴 아이템을 비활성화 처리 if(this.$selectMenuItem)&#123; this.$selectMenuItem.removeClass('on'); &#125; // 신규 아이템 활성화 처리하기 this.$selectMenuItem = $menuItem; this.$selectMenuItem.addClass('on'); &#125; // 인덱스에 해당하는 메뉴 아이템 선택하기 TabMenu.prototype.setSelectItemAt = function(index) &#123; var $menuItem = this.$menuItems.eq(index); // 기존 메서드 재사용 this.setSelectItem($menuItem); &#125; $.fn.tabMenu = function() &#123; this.each(function(index) &#123; // 인스턴스 생성 var obj = new MyClass(); &#125;) return this; &#125;&#125;)(jQuery) 우선 함수 단위 코딩vs클래스 단위 코딩의 클래스 단위 코딩 부분을 jQuery 플러그인 으로 사용할 수 있게 포장을 했습니다. 클래스 단위 로 플러그인을 만들기 때문에 인스턴스를 생성해 줘야 합니다. 다음의 코드를 보시기 바랍니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354(function($) &#123; function TabMenu(selector) &#123; var $tabMenu = null; var $menuItems = null; var $selectMenuItem = null; // 요소 초기화 및 이벤트 등록 호출 this.init(selector); this.initEvent(); &#125; // 요소 초기화 TabMenu.prototype.init = function(selector) &#123; this.$tabMenu = $(selector); this.$menuItems = this.$tabMenu.find(\"ul\").find(\"li\"); &#125; // 이벤트 등록 TabMenu.prototype.initEvent = function() &#123; var objThis = this; this.$menuItems.on('click', function(e) &#123; e.preventDefault(); objThis.setSelectItem($(this)); &#125;) &#125; // $menuItem에 해당하는 메뉴 아이템 선택하기 TabMenu.prototype.setSelectItem = function($menuItem) &#123; // 기존 선택메뉴 아이템을 비활성화 처리 if(this.$selectMenuItem)&#123; this.$selectMenuItem.removeClass('on'); &#125; // 신규 아이템 활성화 처리하기 this.$selectMenuItem = $menuItem; this.$selectMenuItem.addClass('on'); &#125; // 인덱스에 해당하는 메뉴 아이템 선택하기 TabMenu.prototype.setSelectItemAt = function(index) &#123; var $menuItem = this.$menuItems.eq(index); // 기존 메서드 재사용 this.setSelectItem($menuItem); &#125; $.fn.tabMenu = function() &#123; this.each(function(index) &#123; // 인스턴스 생성 var tabMenu = new TabMenu(this); &#125;) return this; &#125;&#125;)(jQuery) 50번 라인에서 tabMenu 플러그인 내부에서 TabMenu 클래스의 인스턴스를 생성하는 구문을 작성해 주었습니다. 다만 이렇게 코드를 작성했어도 아직은 페이지가 시작하자마자 원하는 탭을 선택할 수 없습니다.그건 다음장에서 확인해 보도록 하겠습니다. 프로토타입 클래스 기반 플러그인 결과소스코드 다운받기 [jQuery플러그인제작] jQuery 확장 소개 [jQuery플러그인제작] jQuery유틸리티 만들기 [jQuery플러그인제작] jQuery 플러그인 만들기 [jQuery플러그인제작] 함수 기반 플러그인 만들기 [jQuery플러그인제작] 클래스 기반 플러그인 만들기 [jQuery플러그인제작] 플러그인 그룹 만들기 [jQuery플러그인제작] extend() 메서드를 활용한 플러그인 옵션 처리","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"}],"tags":[]},{"title":"[jQuery플러그인제작] 함수 기반 플러그인 만들기","slug":"jQuery플러그인제작-함수-기반-플러그인-만들기","date":"2018-01-09T07:50:15.000Z","updated":"2018-01-15T01:40:00.000Z","comments":true,"path":"2018/01/09/jQuery플러그인제작-함수-기반-플러그인-만들기/","link":"","permalink":"https://recoveryman.github.io/2018/01/09/jQuery%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8%EC%A0%9C%EC%9E%91-%ED%95%A8%EC%88%98-%EA%B8%B0%EB%B0%98-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/","excerpt":"","text":"구문[구문]12345678910111213141516(function($) &#123; this.each(function(index) &#123; // 이 안쪽에 플러그인 구현 코드가 위치 var 변수1; var 변수2; function 함수1() &#123; // ... &#125; function 함수2() &#123; // ... &#125; &#125;)&#125;)(jQuery) [함수기반 플러그인 이란?]플러그인 구현 코드를 each() 메서드의 매개변수 값으로 넘기는 함수 내부에 작성하는 구조를 의미합니다. 예제예제를 해보기 전에 먼저 함수 단위 코딩vs클래스 단위 코딩에서 만들어 보았던 예제 하나를 먼저 확인해 보겠습니다.소스코드 다운받기 파일을 실행하거나 jsFiddle 로 확인해 보시면 이렇게 독립적으로 실행되는 두개의 탭메뉴를 확인할 수 있습니다. 코드를 살펴보면 여러개의 변수와 함수로 구성이 되어 있는데요. 코드 설명은 함수 단위 코딩vs클래스 단위 코딩 에서 설명을 했기에 생략하겠습니다. 이번 예제는 바로 함수기반으로 만들어진 탭메뉴를 jQuery 플러그인 으로 만드는 것입니다. $(&quot;.tabArea&quot;).tabMenu(); 같이 jQuery 스타일로 구문이 동작할 수 있게 tabMenu 플러그인을 만들어 보겠습니다. 풀이[01] jQuery 플러그인 기본 구조 만들기 123456789101112131415// tabMenu 플러그인(function($) &#123; $.fn.tabMenu = function() &#123; this.each(function(index) &#123; // 구현 코드 위치 console.log(this); &#125;) return this; &#125;&#125;)(jQuery)$(function() &#123; // 플러그인 호출 $('.tabArea').tabMenu();&#125;) 3번 라인: jQuery 플러그인 구조에 맞게 tabMenu플러그인을 만들어 줍니다. 4번 라인: 선택자에 해당하는 노드 개수만큼 탭메뉴를 생성하기 위해 each() 메서드를 실행합니다. 6번 라인: 탭메뉴 코드를 작성하기 전 탭메뉴 개수만큼 each() 메서드로 넘긴 콜백함수가 실행되는지 확인하기 위해 현재 루프에 해당하는 노드(this)를 콘솔창에 출력합니다. 코드를 입력한 후 크롬브라우저에서 console창을 확인해봤습니다.소스코드 다운받기 [02] 탭메뉴 구현코드 넣기우선 탭메뉴가 구현되는 구현코드를 jQuery 플러그인 구조 안에 this.each(function(index) { })사이에 넣어줍니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445// tabMenu 플러그인(function($) &#123; $.fn.tabMenu = function() &#123; this.each(function(index) &#123; // 구현 코드 위치 var $tabMenu = null; var $menuItems = null; var $selectMenuItem = null; // 요소 초기화 function init(selector) &#123; $tabMenu = $(selector); $menuItems = $tabMenu.find(\"ul\").find(\"li\"); &#125; // 이벤트 등록 function initEvent() &#123; $menuItems.on('click', function(e) &#123; e.preventDefault(); setSelectItem($(this)); &#125;) &#125; // $menuItem에 해당하는 메뉴 아이템 선택하기 function setSelectItem($menuItem) &#123; // 기존 선택메뉴 아이템을 비활성화 처리 if($selectMenuItem)&#123; $selectMenuItem.removeClass('on'); &#125; $selectMenuItem = $menuItem; $selectMenuItem.addClass('on'); &#125; // 인덱스에 해당하는 메뉴 아이템 선택하기 function setSelectItemAt(index) &#123; setSelectItem($menuItems.eq(index)); &#125; init(selector); initEvent(); &#125;) return this; &#125;&#125;)(jQuery) 이 코드를 넣은 플러그인을 실행시키면 위 코드의 40번째 라인에서 선택자의 문제로 코드가 동작하지 않습니다. 때문에 jQuery 플러그인 tabMenu() 가 호출될때 현재 노드를 반환해 줘야 합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445// tabMenu 플러그인(function($) &#123; $.fn.tabMenu = function() &#123; this.each(function(index) &#123; // 구현 코드 위치 var $tabMenu = null; var $menuItems = null; var $selectMenuItem = null; // 요소 초기화 function init(selector) &#123; $tabMenu = $(selector); $menuItems = $tabMenu.find(\"ul\").find(\"li\"); &#125; // 이벤트 등록 function initEvent() &#123; $menuItems.on('click', function(e) &#123; e.preventDefault(); setSelectItem($(this)); &#125;) &#125; // $menuItem에 해당하는 메뉴 아이템 선택하기 function setSelectItem($menuItem) &#123; // 기존 선택메뉴 아이템을 비활성화 처리 if($selectMenuItem)&#123; $selectMenuItem.removeClass('on'); &#125; $selectMenuItem = $menuItem; $selectMenuItem.addClass('on'); &#125; // 인덱스에 해당하는 메뉴 아이템 선택하기 function setSelectItemAt(index) &#123; setSelectItem($menuItems.eq(index)); &#125; init(this); // this로 현재 노드를 반환 initEvent(); &#125;) return this; &#125;&#125;)(jQuery) 결과소스코드 다운받기 정리앞 예제를 이용해 기존 함수 기반으로 만들어진 탭메뉴를 jQuery 플러그인 방식으로 만들어 봤습니다. 하지만 이 방식에는 tabMenu 플러그인에 의해 탭메뉴가 만들어 지는 만큼 init(), initEvent() 등의 내부 함수가 중복해서 만들어 지는 문제점이 있습니다. 다음 장에선 prototype 클래스를 이용해서 이 문제를 해결한 플러그인을 제작해 보겠습니다. [jQuery플러그인제작] jQuery 확장 소개 [jQuery플러그인제작] jQuery유틸리티 만들기 [jQuery플러그인제작] jQuery 플러그인 만들기 [jQuery플러그인제작] 함수 기반 플러그인 만들기 [jQuery플러그인제작] 클래스 기반 플러그인 만들기 [jQuery플러그인제작] 플러그인 그룹 만들기 [jQuery플러그인제작] extend() 메서드를 활용한 플러그인 옵션 처리","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"}],"tags":[]},{"title":"[jQuery플러그인제작] jQuery 플러그인 만들기 ","slug":"jQuery플러그인제작-jQuery-플러그인-만들기","date":"2018-01-04T05:44:43.000Z","updated":"2018-01-15T01:40:06.000Z","comments":true,"path":"2018/01/04/jQuery플러그인제작-jQuery-플러그인-만들기/","link":"","permalink":"https://recoveryman.github.io/2018/01/04/jQuery%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8%EC%A0%9C%EC%9E%91-jQuery-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/","excerpt":"","text":"jQuery 플러그인 소개제이쿼리 플러그인은 아코디언 메뉴, 탭메뉴, 슬라이더 등과 같이 특정 기능을 재사용 할 때 사용하고자 하는 포장 기술 입니다. jQuery 플러그인 구조12345678(function($) &#123; $.fn.플러그인이름 = function() &#123; this.each(function(index) &#123; // 기능 구현 &#125;) return this; &#125;&#125;)(jQuery) jQuery 유틸리티의 경우 jQuery 클래스 메서드로 만드는 것과 달리 jQuery 플러그인은 jQuery 클래스의 fn 이란 곳에 만듭니다. 여기서 fn은 protorype을 줄여쓴 닉네입 입니다. 예를 들어 지금까지 즐겨 사용한 find(), filter(), children() 등의 기능은 다음과 같이 표현할 수 있습니다. 12345678910111213function jQuery() &#123; // ...&#125;jQuery.prototype.find = function() &#123; // ...&#125;jQuery.prototype.filter = function() &#123; // ...&#125;jQuery.prototype.children = function() &#123; // ...&#125; 즉 사용 해왔던 jQuery 플러그인은 모두 jQuery 의 인스턴스 메서드일 뿐입니다. 인스턴스 프로퍼티와 메서드vs클래스 프로퍼티와 메서드 사용자 플러그인 또한 동일한 구조를 가지므로 다음과 같이 jQuery 클래스 메서드(플러그인 이름)를 추가한 것뿐입니다. 123456789function jQuery() &#123; // ...&#125;// ...jQuery.prototype.플러그인이름 = function() &#123; // ...&#125; jQuery 플러그인 구조 분석jQuery 플러그인을 만들기 위해서는 jQuery 유틸리티와 달리 jQuery 플러그인은 내부 구조를 확실히 알고 있어야 합니다.p 태그의 외곽선을 붉은색으로 바꿔주는 간단한 플러그인제작을 하면서 설명하겠습니다. [예제1]1234567891011121314// redColor 플러그인 정의(function($) &#123; $.fn.redColor = function() &#123; this.each(function(index) &#123; $(this).css('border', '4px solid #f00'); &#125;) return this; &#125;&#125;)(jQuery)$(function() &#123; // redColor 플러그인 사용 $('p').redColor();&#125;) 소스코드 다운받기 [1.] this.each()*: 일단 this.each() 를 해석하기 위해서는 앞에 위치한 this가 무엇을 의미하는지 파악해야 합니다. 앞에서도 알아본 것처럼 $.fn.redColor을 풀어서 설명하면 다음과 같이 표현할 수 있습니다. 12345678910111213141516$.fn.redColor = function() &#123; this.each(function(index) &#123; $(this).css('border', '4px solid #f00'); &#125;) return this;&#125;// 위 코드와 아래 코드는 동일합니다.// 달라진 점은 $.fn 을 풀어쓰면 $.prototype 으로 사용할 수 있습니다.$.prototype.redColor = function() &#123; this.each(function(index) &#123; $(this).css('border', '4px solid #f00'); &#125;) return this;&#125; 즉 redColor 플러그인은 jQuery 메서드를 부르는 또하나의 이름일 뿐 클래스의 일반 메서드와 동일하다는 것을 알 수 있습니다. 클래스의 일반 메서드를 사용하기 위해서는 먼저 인스턴스를 생성해야 하는데요. 이 인스턴스는 바로 아래 코드중 3번 코드에 의해 실행됩니다. [클래스의 일반 메서드를 사용하기 위한 인스턴스 생성]1234$(function() &#123; // redColor 플러그인 사용 $('p').redColor();&#125;) 정리하자면 $(&#39;p&#39;).redColor(); 부분의 $(&#39;p&#39;) 에 의해서 인스턴스가 생성되고 접근연산자(.)를 활용해 신규 생성한 redColor() 메서드(신규 플러그인)를 호출한 것이 됩니다.이에 따라 redColor() 메서드 내부의 this는 redColor() 메서드를 호출한 jQuery 객체 자체가 되며 this.each()는 jQuery 에서 제공하는 eahc() 메서드를 호출한 것이 됩니다. [2.] $(this).css(‘border’, ‘4px solid #f00’);: each() 메서드 내부에서 this 는 현재 처리하고 있는 자바스크립트 DOM 노드 입니다. 자바스크립트에는 스타일을 변경할때 유용하게 사용하는 .css() 메서드가 없기 때문에 $(this) 구문을 이용해 jQuery 인스턴스를 생성한 후 css() 메서드를 사용했습니다. [3.] return this의 정체: $(&#39;p&#39;).redColor().on(...)과 같이 redColor() 플러그인 호출 후 jQuery 메서드를 체인구조로 호출할 수 있게 하기 위해서는 this 를 리턴해줘야 합니다. 좀더 풀어서 설명하면 $(&#39;p&#39;).redColor().on(...)을 다음과 같이 표현할 수도 있습니다. 12var $temp = $('p').redColor();$temp.on('...'); 이때 $temp에 저장되는 값이 바로 return this 값이 됩니다. [1.] 에서 알아본 것처럼 this는 jQuery 인스턴스 이기 때문에 $temp.on() 메서드를 연속해서 호출할 수 있게 됩니다. 사용자 정의 jQuery플러그인 만들기li를 순차적으로 지우는 플러그인 만들기 [Markup]1234567&lt;ul class=\"menu\"&gt; &lt;li&gt;menu1&lt;/li&gt; &lt;li&gt;menu2&lt;/li&gt; &lt;li&gt;menu3&lt;/li&gt; &lt;li&gt;menu4&lt;/li&gt; &lt;li&gt;menu5&lt;/li&gt;&lt;/ul&gt; [jQuery plugin]1234567891011121314151617(function($) &#123; $.fn.removeLi = function() &#123; this.each(function(index) &#123; var $target = $(this); $target.delay(index * 1000).animate(&#123; height: 0 &#125;, 500, function() &#123; $target.remove(); &#125;) &#125;) return this; &#125;&#125;)(jQuery)$(function() &#123; $(\".menu\").removeLi();&#125;) 결과 (결과를 다시 보고 싶을 땐 다른 탭 클릭 후 result 탭 클릭) 소스코드 다운받기 [jQuery플러그인제작] jQuery 확장 소개 [jQuery플러그인제작] jQuery유틸리티 만들기 [jQuery플러그인제작] jQuery 플러그인 만들기 [jQuery플러그인제작] 함수 기반 플러그인 만들기 [jQuery플러그인제작] 클래스 기반 플러그인 만들기 [jQuery플러그인제작] 플러그인 그룹 만들기 [jQuery플러그인제작] extend() 메서드를 활용한 플러그인 옵션 처리","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"}],"tags":[]},{"title":"[jQuery플러그인제작] jQuery유틸리티 만들기","slug":"jQuery플러그인제작-jQuery유틸리티-만들기","date":"2017-12-28T08:02:19.000Z","updated":"2018-01-15T01:40:16.000Z","comments":true,"path":"2017/12/28/jQuery플러그인제작-jQuery유틸리티-만들기/","link":"","permalink":"https://recoveryman.github.io/2017/12/28/jQuery%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8%EC%A0%9C%EC%9E%91-jQuery%EC%9C%A0%ED%8B%B8%EB%A6%AC%ED%8B%B0-%EB%A7%8C%EB%93%A4%EA%B8%B0/","excerpt":"","text":"유틸리티 소개 jQuery 유틸리티는 jQuery 의 trim() 메서드와 같이 주로 도움을 주는 기능을 합니다. jQuery 유틸리티는 jQuery 인스턴스를 생성하지 않고 직접 접근해서 사용 합니다. 12345jQuery.유틸리티();// 또는$.유틸리티(); jQuery 에서 기본으로 제공해 주는 유틸리티 - 바로가기 유틸리티 구조[문법]123456(function($) &#123; $.유틸리티 = function() &#123; // 기능구현 &#125;&#125;)(jQuery);jQuery.유틸리티(); // 사용하기 2번 라인의 $ 는 jQuery 클래스 자체를 나타내며 jQuery 의 클래스 메서드 입니다. 즉. 클래스 인스턴스를 생성하지 않고 바로 접근해서 사용할 수 있다는 의미 입니다. 인스턴스 프로퍼티와 메서드vs클래스 프로퍼티와 메서드 [사용법]12345jQuery.유틸리티();// 또는$.유틸리티(); 사용법은 일반 클래스 메서드 호출하듯 호출. [사용 예]12345$(function() &#123; var str = \" 회복맨 \"; console.log($.trim(str)); console.log(jQuery.trim(str));&#125;) 사용자 정의 jQuery 유틸리티 만들기인자로 숫자를 넣으면 3자리 마다 콤마(,) 를 삽입 하는 유틸리티 1234567891011121314151617181920212223(function($) &#123; $.addComma = function(value) &#123; // 숫자를 문자로 형변환 var data = value + \"\"; // 문자를 배열로 var aryResult = data.split(\"\"); // 배열 요소를 뒤에서 세자리 수마다 콤마 추가 하기 var startIndex = aryResult.length - 3; for( var i = startIndex; i &gt; 0; i -= 3 )&#123; aryResult.splice(i, 0, \",\"); &#125; // 배열을 문자열 처리후 리턴 return aryResult.join(\"\"); &#125;&#125;)(jQuery);// 사용console.log($.addComma(123))console.log($.addComma(12345))console.log($.addComma(12345678)) 소스코드 다운받기 [jQuery플러그인제작] jQuery 확장 소개 [jQuery플러그인제작] jQuery유틸리티 만들기 [jQuery플러그인제작] jQuery 플러그인 만들기 [jQuery플러그인제작] 함수 기반 플러그인 만들기 [jQuery플러그인제작] 클래스 기반 플러그인 만들기 [jQuery플러그인제작] 플러그인 그룹 만들기 [jQuery플러그인제작] extend() 메서드를 활용한 플러그인 옵션 처리","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"}],"tags":[]},{"title":"[jQuery플러그인제작] jQuery 확장 소개","slug":"jQuery플러그인제작-jQuery-확장-소개","date":"2017-12-28T05:08:04.000Z","updated":"2018-01-15T01:40:12.000Z","comments":true,"path":"2017/12/28/jQuery플러그인제작-jQuery-확장-소개/","link":"","permalink":"https://recoveryman.github.io/2017/12/28/jQuery%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8%EC%A0%9C%EC%9E%91-jQuery-%ED%99%95%EC%9E%A5-%EC%86%8C%EA%B0%9C/","excerpt":"","text":"jQuery 확장에는 유틸리티와 플러그인 두 가지가 있습니다. jQuery 확장이란123456// 자바스크립트 방식var tabMenu1 = new TabMenu('.tabMenu1');TabMenuenu.setSelectAt(1);// jQuery 플러그인 방식$(\".tabMenu1\").setSelectAt(1); jQuery 확장 요소 종류1.유틸리티 문자열의 공백을 제거해주는 jQuery의 trim() 메서드와 같은 유틸리티는 주로 도움을 주는 기능을 합니다.jQuery 인스턴스를 생성하지 않고 jQuery 클래스에 직접 접근하여 사용합니다. 1jQuery.유틸리티(); 1$.유틸리티(); 2.플러그인 특정 기능을 재사용 하고자 할 때 사용하는 포장 기능 입니다. 1$('선택자').플러그인(옵션); 12var $결과 = $('선택자');$결과.플러그인(옵션); [jQuery플러그인제작] jQuery 확장 소개 [jQuery플러그인제작] jQuery유틸리티 만들기 [jQuery플러그인제작] jQuery 플러그인 만들기 [jQuery플러그인제작] 함수 기반 플러그인 만들기 [jQuery플러그인제작] 클래스 기반 플러그인 만들기 [jQuery플러그인제작] 플러그인 그룹 만들기 [jQuery플러그인제작] extend() 메서드를 활용한 플러그인 옵션 처리","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"}],"tags":[]},{"title":"패키지","slug":"패키지","date":"2017-12-27T07:21:44.000Z","updated":"2017-12-28T04:46:52.000Z","comments":true,"path":"2017/12/27/패키지/","link":"","permalink":"https://recoveryman.github.io/2017/12/27/%ED%8C%A8%ED%82%A4%EC%A7%80/","excerpt":"","text":"패키지란함수는 특정 알고리즘이나 구문의 영역을 나누기 위해 사용하는 포장 기술.클래스는 연관있는 변수와 함수를 묶을때 사용. 패키지는 연관있는 클래스를 묶을 때 사용 자바스크립트에서 패키지자바스크립트는 다른 언어와 달리 패키지 문법을 제공하지 않습니다.그래서 패키지 스럽게 흉내를 냅니다. 123456789101112131415161718192021222324252627282930313233var study = &#123;&#125;;study.ui = &#123;&#125;// property 선언study.ui.TabMenu = function() &#123; this.property = \"TAB MENU\";&#125;study.ui.Slider = function() &#123; this.property = \"SLIDER\"&#125;// method 선언study.ui.TabMenu.prototype.method = function() &#123; return this.property;&#125;study.ui.Slider.prototype.method = function() &#123; return this.property;&#125;// 버전및 제작자 정보study.version = \"0.1.0\";study.getInfo = function() &#123; var info = &#123; developer: \"반찬가게알바\", email: \"고등어@등푸른생선.com\", desc: \"저희 가게의 반찬은 고등어가 제일 맛있습니다!\" &#125; return info;&#125;// 인스턴스 생성var tabMenu = new study.ui.TabMenu();var slider = new study.ui.Slider(); 위의 코드를 약간만 정리해 보면 다음과 같이 나올듯 합니다. 1234567891011121314151617181920212223242526272829303132var study = &#123; // 클래스 프로퍼티 메소드 를 여기에 넣었습니다. version: \"0.1.0\", getInfo: function() &#123; var info = &#123; developer: \"반찬가게알바\", email: \"고등어@등푸른생선.com\", desc: \"저희 가게의 반찬은 고등어가 제일 맛있습니다!\" &#125; return info; &#125;&#125;;study.ui = &#123; // property 선언을 ui 안쪽에 두었습니다. TabMenu: function() &#123; this.property = \"TAB MENU\"; &#125;, Slider: function() &#123; this.property = \"SLIDER\" &#125;&#125;// method 선언study.ui.TabMenu.prototype.method = function() &#123; return this.property;&#125;study.ui.Slider.prototype.method = function() &#123; return this.property;&#125;// 인스턴스 생성var tabMenu = new study.ui.TabMenu();var slider = new study.ui.Slider(); 사용 방법[사용]123456// 인스턴스 프로퍼티 메소드 사용tabMenu.method();slider.method();// 클래스 프로퍼티 메소드 사용study.getInfo().desc; 결과 클래스정의 3가지 비교 함수 단위 코딩vs클래스 단위 코딩 인스턴스 프로퍼티와 메서드vs클래스 프로퍼티와 메서드 패키지","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"}],"tags":[]},{"title":"인스턴스 프로퍼티와 메서드vs클래스 프로퍼티와 메서드","slug":"인스턴스-프로퍼티와-메서드vs클래스-프로퍼티와-메서드","date":"2017-12-27T02:07:02.000Z","updated":"2017-12-28T04:36:02.000Z","comments":true,"path":"2017/12/27/인스턴스-프로퍼티와-메서드vs클래스-프로퍼티와-메서드/","link":"","permalink":"https://recoveryman.github.io/2017/12/27/%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9Cvs%ED%81%B4%EB%9E%98%EC%8A%A4-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0%EC%99%80-%EB%A9%94%EC%84%9C%EB%93%9C/","excerpt":"","text":"인스턴스 프로퍼티와 메서드란[인스턴스 프로퍼티와 메서드]클래스의 인스턴스를 생성 후 사용할 수 있는 프로퍼티와 메서드를 뜻함 [예]12var tabMenu1 = new TabMenu(\".tab1\");tabMenu1.setSelectItemAt(1); 클래스 프로퍼티와 메서드란[클래스 프로퍼티와 메서드]인스턴스를 생성하지 않고도 사용할 수 있는 프로퍼티와 메서드 만드는 방법 [문법]12345function 클래스_이름() &#123; // ...&#125;클래스_이름.프로퍼티 = 값;클래스_이름.메서드 = function()&#123;&#125; 여기서 클래스 이름은 인스턴스가 아닙니다. [차이]123456789101112131415161718function TabMenu() &#123; // ..&#125;// 인스턴스 프로퍼티와 메서드TabMenu.prototype.property1 = \"string\";TabMenu.prototype.method1 = function()&#123;return \"method1\"&#125;;// 클래스 프로퍼티와 메서드TabMenu.property2 = \"string\";TabMenu.method2 = function()&#123;return \"method2\"&#125;;var tabMenu = new TabMenu();console.log(\"1. \" + tabMenu.property1);console.log(\"2. \" + tabMenu.property2);console.log(\"3. \" + tabMenu.method1());console.log(\"4. \" + tabMenu.method2()); 결과 콘솔로 나온 결과 중에서 2, 4번의 출력은 저렇게 하면 안되고 다음과 같이 해야 합니다. [클래스 프로퍼티와 메서드 출력]12console.log(\"2. \" + TabMenu.property2);console.log(\"4. \" + TabMenu.method2()); 결과[클래스 프로퍼티와 메서드 의 주 용도]주로 도움을 주는 유틸리티성 기능이나 또는 실행하더라도 내부 데이터에 영향을 주지 않고 독립적으로 실행되는 기능이나 정보를 담을 때 사용 예 12345678910111213141516function TabMenu() &#123; // .. &#125;TabMenu.version = \"0.1.0\";TabMenu.getInfo = function() &#123; var info = &#123; developer: \"반찬가게알바\", email: \"고등어@등푸른생선.com\", desc: \"저희 가게의 반찬은 고등어가 제일 맛있습니다!\" &#125; return info;&#125;console.log(TabMenu.version);console.log(TabMenu.getInfo()); 클래스 프로퍼티와 메서드는 없거나 추가되더라도 기능이 동작하는데 전혀 지장을 주지 않습니다. 클래스정의 3가지 비교 함수 단위 코딩vs클래스 단위 코딩 인스턴스 프로퍼티와 메서드vs클래스 프로퍼티와 메서드 패키지","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"}],"tags":[]},{"title":"함수 단위 코딩vs클래스 단위 코딩","slug":"함수-단위-코딩vs클래스-단위-코딩","date":"2017-12-26T02:00:59.000Z","updated":"2017-12-28T04:24:46.000Z","comments":true,"path":"2017/12/26/함수-단위-코딩vs클래스-단위-코딩/","link":"","permalink":"https://recoveryman.github.io/2017/12/26/%ED%95%A8%EC%88%98-%EB%8B%A8%EC%9C%84-%EC%BD%94%EB%94%A9vs%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%8B%A8%EC%9C%84-%EC%BD%94%EB%94%A9/","excerpt":"","text":"함수단위 코딩1함수만을 이용해서 다음과 같이 독립적으로 동작하는 n개의 탭패널을 제작 가능 합니다. 소스코드 다운받기 이렇게 만든 함수는 두가지 단점이 있습니다. tabMenu() 함수를 호출할 때마다 내부에 선언된 중첩 함수가 만들어 집니다. tabMenu 함수를 호출할 때마다 내부에 들어가는 함수들이 중복해서 만들어 집니다. 외부에서 내부 속성과 함수를 접근할 수 없습니다. javascript 탭을 눌러보시면 setSelectItemAt 함수를 tabMenu 함수 외부에서 호출할 수 없습니다. 함수단위 코딩2함수만을 이용한 함수단위 코딩으로도 함수 내부의 함수를 호출하는 방법이 있습니다. 소스코드 다운받기 먼저 함수 내부의 함수를 호출하기 위해 내부 함수를 객체로 포장해 리턴해 줍니다. tabMenu 함수를 호출할 때 변수로 한번 감싸줍니다. 이렇게 감싼 변수는 tabMenu 함수 내부에 객체 리터럴 방식으로 리턴해준 함수를 사용할 수 있습니다. 아마 갑자기 객체 리터널이 나와서 이해가 안가실 수 있습니다.그래서 아래 코드를 보시고 결과를 예측하시면 좋을듯 합니다. 1234567891011121314151617181920212223242526// 1.function a() &#123; // ..&#125;console.log(\"함수 a 는 어떻게 출력될까요? \" + a);console.log(\"함수 a 를 '실행'시키면 어떻 뭐가 출력 될까요? \" + a());console.log(\"함수 a 의 타입은? \" + (typeof a));console.log(\"함수 a 가 '실행'시키면 그 타입은? \" + (typeof a()));// 2.function b() &#123; var str = \"string\"&#125;console.log(\"함수 b 는 어떻게 출력될까요? \" + b);console.log(\"함수 b 를 '실행'시키면 어떻 뭐가 출력 될까요? \" + b());console.log(\"함수 b 의 타입은? \" + (typeof b));console.log(\"함수 b 가 '실행'시키면 그 타입은? \" + (typeof b()));// 3.function c() &#123; return \"string\";&#125;console.log(\"함수 c 는 어떻게 출력될까요? \" + c);console.log(\"함수 c 를 '실행'시키면 어떻 뭐가 출력 될까요? \" + c());console.log(\"함수 c 의 타입은? \" + (typeof c));console.log(\"함수 c 가 '실행'시키면 그 타입은? \" + (typeof c())); ..........결과 함수를 호출하면 리턴해온 반환값에 의해 타입이 바뀌게 되는걸 알 수 있습니다.그래서 마지막에 객체를 반환하게 될 경우 타입이 객체로 바뀌게 됩니다. 123456789function d() &#123; return &#123; str: \"string\" &#125;&#125;console.log(\"함수 d 는 어떻게 출력될까요? \" + d);console.log(\"함수 d 를 '실행'시키면 어떻 뭐가 출력 될까요? \" + d());console.log(\"함수 d 의 타입은? \" + (typeof d));console.log(\"함수 d 가 '실행'시키면 그 타입은? \" + (typeof d())); 결과 함수안에 객체(Object)를 리턴하게 되면 객체가 되므로 객체의 프로퍼티 또는 메서드를 사용할 수 있게 됩니다. 클래스 단위 코딩 소스코드 다운받기 클래스 단위 코딩은 함수 단위 코딩에서 가지고 있는 단점들을 해소할 수 있습니다. 클래스 단위 코딩에서 보이듯 프로토 타입 방식의 경우 여러개의 인스턴스에서 메서드를 공유해서 사용합니다. 함수단위 코딩과는 다르게 함수 외부에서 함수 내부로 접근할 수 있는 형태를 가지고 있습니다. 클래스정의 3가지 비교 함수 단위 코딩vs클래스 단위 코딩 인스턴스 프로퍼티와 메서드vs클래스 프로퍼티와 메서드 패키지","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"}],"tags":[]},{"title":"this (2) - 이벤트리스너,메서드,메서드 내부의 중첩 함수에서의 this","slug":"this-2","date":"2017-12-12T23:48:57.000Z","updated":"2017-12-13T15:16:48.000Z","comments":true,"path":"2017/12/13/this-2/","link":"","permalink":"https://recoveryman.github.io/2017/12/13/this-2/","excerpt":"","text":"자바스크립트 this (2)이벤트 리스너에서의 this예제 [다음 7,8,9 결과 예상해보기]1234567891011var num = 1;$(function() &#123; $('.btn').on('click', function() &#123; this.num = 2; num = 3; console.log(num); console.log(this.num); console.log(window.num); &#125;)&#125;) 예제 다운받기..........결과제이쿼리를 사용한 예제 입니다.클래스명이 btn 인 엘리먼트를 클릭하면 안의 내용을 실행 합니다.예제의 결과를 보시면 조금 헷갈리실 수 있습니다. 4번 라인의 this.num 은 $(‘.btn’) 이라는 객체의 속성(property) 로 들어게 됩니다. 변수와는 다릅니다.※ $(‘.btn’) 은 제이쿼리에 의해 객체(object) 가 됩니다. console.log(typeof $(‘.btn’)); 을 찍어서 확인하시면 $(‘.btn’) 의 데이터 타입이 나옵니다. 5번 라인의 num 은 $(‘.btn’) 의 익명함수 내부에서 지역변수 num을 찾습니다. 익명함수 내부에서 지역변수 num이 없기에 한단계 위인 $(function(){}) 에서 지역변수 num 을 찾습니다. 거기도 없기 때문에 window 전역객체에 선언된 전역변수 num을 찾아서 3이라는 값을 할당합니다. 7번 라인의 num 은 전역에 선언된 num 을 의미합니다. 8번 라인의 this.num은 함수를 호출한 시점이 되는 $(‘.btn’) 객체의 속성(property) 인 num 을 의미합니다. 9번 라인의 window.num 은 윈도우 객체에 선언된 num을 의미합니다. 7번과 9번의 num은 동일한 객체안에 있습니다. 메서드에서의 this예제 [다음 9,10,11 결과 예측해보기]123456789101112131415var num = 1;function MyClass() &#123; this.num = 2;&#125;MyClass.prototype.method1 = function() &#123; this.num = 3; num = 4; console.log(num); console.log(this.num); console.log(window.num);&#125;var my1 = new MyClass();my1.method1(); .............결과 3번 라인의 this.num 은 아직은 어떤 객체의 num 이될지 알 수 없는 상태 입니다. MyClass 라는 함수(클래스)를 어떻게 호출하냐에 따라 달라집니다. (클래스로 사용할 함수는 앞 글자를 대문자로 표시하는 규칙이 있습니다.) 6번 라인의 this.num 은 MyClass 를 호출한 객체의 속성(property)이 됩니다. 아직은 어떤 객체의 속성이 될지 모르는 상태 입니다. 7번 라인의 num 은 자세히 보시면 method1 이라는 함수 안의 변수처럼 보입니다. 다만 앞에 예약어인 var 가 없기 때문에 지역변수 num 을 찾다가 없으니깐 window 전역객체의 변수 num에 4라는 값이 할당되게 됩니다. 9번 라인의 num 은 15번 라인에서 my1.method1(); 을 호출할 때 안의 실행절차에 따라 전역변수 num 에 4라는 값이 할당됩니다. 10번 라인의 this.num은 method1 을 호출한 객체인 my1 의 속성(property) 로써 3이라는 값이 할당받게 됩니다. 11번 라인의 window.num 은 1번 라인의 num 입니다. 7번 라인의 동작에 따라 1번 라인의 num 은 4라는 값을 할당 받았습니다. 메서드 내부의 중첩 함수에서의 this[다음 10,11,12 결과 예측해보기]123456789101112131415161718var num = 1;function MyClass() &#123; this.num = 2;&#125;MyClass.prototype.method1 = function() &#123; function inner() &#123; this.num = 3; num = 4; console.log(num); console.log(this.num); console.log(window.num); &#125; inner();&#125;var my1 = new MyClass();my1.method1(); ...........결과아마 11 번 라인의 this.num 이 왜 4가 찍히는지 조금 의아할 수 있습니다.중첩함수 내부의 this 는 window 객체를 의미합니다. 메서드 안의 중첩함수도 예외는 아닙니다.앞선 포스팅에서 중첩함수 내부의 this 에 대해서 포스팅 한 적이 있습니다. 10번 라인의 num 은 inner 함수 내부에서 지역변수 num을 찾습니다. 근데 지역변수 num이 없으니 한단계 위인 MyClass 함수에서의 지역변수 num을 찾습니다. 그래도 없으니까 window 객체의 num 을 찾아 4 라는 값을 할당해주게 됩니다. 11번 라인의 this.num 은 중첩함수 inner 안에 있습니다. 중첩함수 내부의 this 는 window 객체 입니다. 따라서 7번 라인에 의해 전역변수 num 에 3 이라는 값을 대입했지만. 8번라인의 코드에 의해 num 이 4라는 값을 가지게 되므로 4를 출력합니다. 12번 라인은 전역변수 num을 의미합니다. 1번라인을 바라보고 있습니다. 8번 라인에 의해 4라는 값을 할당받게 되어서 4가 찍힙니다. this (1) - 일반함수,일반중첩함수 의 this this (2) - 이벤트리스너,메서드,메서드 내부의 중첩 함수에서의 this","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"}],"tags":[]},{"title":"this (1) - 일반함수,일반중첩함수 의 this","slug":"this-1","date":"2017-12-12T12:54:23.000Z","updated":"2017-12-13T15:18:30.000Z","comments":true,"path":"2017/12/12/this-1/","link":"","permalink":"https://recoveryman.github.io/2017/12/12/this-1/","excerpt":"","text":"자바스크립트 this (1)this는 일반적으로 메서드를 호출한 객체가 저장되어 있는 속성 콘솔 찍어보기 전까지 예상하기 어려운 녀석이네요.코딩을 하면서 조금씩 움찔움찔 합니다. 어… 이게 이걸 가르키나 하구요. 일반 함수에서의 this1234567891011var data = 10;function outer() &#123; this.data = 20; data = 30; console.log(\"1. data = \" + data); // 30 console.log(\"2. this.data = \" + this.data); // 30 console.log(\"3. window.data = \" + window.data); // 30&#125;outer(); outer 라는 함수를 호출하기 전에 this가 무엇인지 생각해 봅시다......예상하신게 이 다음 적을 결과와 같다면 아마 this를 이미 잘 아시는 분이실꺼 같습니다.저는 자바스크립트 에서의 this 는 많이 공부해야 하지만 얕게 알고있는 내용이라도 몇자 남겨 보겠습니다.자바스크립트의 this만 하더라도 책한권의 분량이 나온다고 하니 많이 공부가 필요할듯싶습니다.이 글에서 전달하고자 하는 부분이 잘못되어 있으면 지적 부탁드립니다.후에 명확한 내용을 전달할 수 있을때 다시 포스팅 하겠습니다....결과 일반 함수에서의 this 는 window 객체를 가르키고 있습니다. 3번 라인의 this.data = 20; 은 전역변수 data 에 20을 할당해 줍니다. 4번 라인의 data = 30; 은 지역변수 num을 일단 찾고 없으면 전역으로 올라가 전역변수 data 를 찾습니다. 그리고 그 전역변수 data 에 30을 다시 할당합니다. 그래서 모두 같은 30 이라는 값이 출력이 되고 있네요. 여기서 알 수 있는 사실은this는 무조건 ‘객체’ 입니다. 그리고 좀 더 명확하게 알기 위해서는 ‘함수를 호출한 시점’을 알아야 합니다.간단한 코드로 예를 보여드리겠습니다. 12345function a() &#123; console.log(this);&#125;a(); 이 코드를 콘솔로 찍어보면 window 객체가 찍힙니다. 이 윈도우 객체를 펼쳐보면 a 라는 함수가 보입니다. 이렇다는 건 다음의 코드로도 a함수를 호출할 수 있습니다.같은 결과가 나오고 있네요.두번째로 알 수 있는건 이렇게 호출한 시점의 ‘객체’ 가 this 가 됩니다. 그럼 예제의 3번 코드와 4번 코드 사이에지역변수 data 을 넣어보겠습니다. 예제2 123456789101112var data = 10;function outer() &#123; this.data = 20; var data = 50; data = 100; console.log(\"1. data = \" + data); // 100 console.log(\"2. this.data = \" + this.data); // 20 console.log(\"3. window.data = \" + window.data); // 20&#125;outer(); 3번 코드에 의해 전역변수 data 에 20 이 할당 4번 코드 에 의해 outer 함수 안에 지역변수 data 에 50 이라는 값을 가짐 5번 코드에 의해 outer 함수 안의 지역변수 data 에 100 이라는 값이 담김 7번 에서의 data 는 함수 내부의 지역변수를 data을 찾음 // 100 8번 에서의 this.data 은 a라는 함수를 호출한 window 객체의 data(전역변수) 을 찾음 // 20 9번 에서의 window.data 은 전역변수 data 을 가르킴. // 20 결과 일반 중첩 함수에서의 this[다음 7,8,9번 코드의 출력값 예상하기]123456789101112var data = 10;function outer() &#123; function inner() &#123; this.data = 20; data = 30; console.log(\"1. data = \" + data); console.log(\"2. this.data = \" + this.data); console.log(\"3. window.data = \" + window.data); &#125; inner();&#125; 이 예제도 this 가 무엇을 가르키는지 맞추셨다면 this 를 이미 잘 아시는 분이실듯 합니다. ...자바스크립트를 이제 막 접하신 분들이라면 위의 예제를 해보고 난 뒤 inner 함수가 호출되는 시점을 찾았을 것이라 생각됩니다.inner 함수는 outer 함수 안에서 실행이 되니깐 아마 예상하기론 outer 함수가 찍혀있지 않을까 예상실꺼 같다고 생각이 듭니다...............일단 inner 함수를 호출해 보기 위해 첫번째 시도를 하겠습니다.이 사진에서 보시다시피 inner 함수는 outer 라는 함수 내부에 있기 때문에 그냥 inner 함수를 호출 못시킴니다. 따라서 outer라는 함수를 호출해야지 outer 함수 내부의 동작을 수행하면서 inner 함수가 호출이 됩니다.그런데 잘 보시면 outer 함수가 콘솔로 찍혀 있을 줄 알았지만 예상과는 다르게 콘솔로 찍은 문제의 답이 찍혀져 있었네요. 4번 라인의 this.data 는 inner 함수 내부에 있습니다. inner 함수는 outer 함수 내부에 있는 함수 입니다. 일반 중첩 함수에서 this는 ‘window’ 가 됩니다. 5번 라인은 data 는 지역변수 data 를 먼저 찾고 없으면 전역으로 올라갑니다. 전역에 선언되어 있는 data 변수에 30 이라는 값을 할당 합니다. 7번 라인은 지역변수 data 를 찾고 없으니까 전역으로 올라가서 data 를 찾습니다. data 는 30이라는 값이 할당되어 있습니다. 8번 라인은 함수를 호출한 시점이 되는 객체의 data 변수를 의미합니다. data 변수는 window 객체에서의 변수로 정의되어 있습니다. 9번 라인은 윈도우 전역객체의 data 변수를 의미합니다. this (1) - 일반함수,일반중첩함수 의 this this (2) - 이벤트리스너,메서드,메서드 내부의 중첩 함수에서의 this","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"}],"tags":[]},{"title":"클래스정의 3가지 비교","slug":"클래스정의-3가지-비교","date":"2017-12-10T13:14:43.000Z","updated":"2017-12-28T04:24:44.000Z","comments":true,"path":"2017/12/10/클래스정의-3가지-비교/","link":"","permalink":"https://recoveryman.github.io/2017/12/10/%ED%81%B4%EB%9E%98%EC%8A%A4%EC%A0%95%EC%9D%98-3%EA%B0%80%EC%A7%80-%EB%B9%84%EA%B5%90/","excerpt":"","text":"특징 방식 특징 프로토타입방식 일반적인 클래스 제작 방법인스턴스마다 공통된 메서드를 공유해서 사용하는 장점이 있음jQuery도 prototype방식으로 만들어져 있음 함수 방식 간단한 클래스 제작 시 사용인스탄스마다 메서드가 독립적으로 만들어지는 단점이 있음 리터럴 방식 클래스 만드는 용도는 아니며 주로 여러개의 매개변수를 그룹으로 묶어 함수의 매개변수로 보낼 때 사용정의와 함께 인스턴스가 만들어지는 장점이 있음. 단! 인스턴스는 오직 하나만 만들 수 있음 클래스 정의 방법(포장) 비교리터럴방식 123456789var 인스턴스 = &#123; 프로퍼티1: 초깃값, 프로퍼티2: 초깃값, 메서드1: function() &#123; &#125;, 메서드2: function() &#123; &#125;&#125; 함수방식 123456789function 클래스이름() &#123; this.프로퍼티1 = 초깃값; this.프로퍼티2 = 초깃값; this.메서드1 = function() &#123; &#125; this.메서드2 = function() &#123; &#125;&#125; 프로토타입 방식 123456789function 클래스이름()&#123; this.프로퍼티1 = 초깃값; this.프로퍼티2 = 초깃값;&#125;클래스이름.prototype.메서드1 = function() &#123;&#125;클래스이름.prototype.메서드2 = function() &#123;&#125; 인스턴스 생성 방법 리터럴 방식 함수 방식 프로토타입 방식 var 인스턴스 = {}; var 인스턴스 = new 클래스이름(); var 인스턴스 = new 클래스이름(); 객체 외부에서 프로퍼티와 메서드 접근 방법리터럴 방식 123456789101112var 인스턴스 = &#123; 프로퍼티1: 초깃갑, 프로퍼티2: 초깃갑, 메서드1: function() &#123; &#125; 메서드2: function() &#123; &#125;&#125;인스턴스.프로퍼티1;인스턴스.메서드1(); 함수방식 123456789101112function 클래스이름() &#123; this.프로퍼티1 = 초깃값; this.프로퍼티2 = 초깃값; this.메서드1 = function() &#123; &#125; this.메서드2 = function() &#123; &#125;&#125;인스턴스.프로퍼티1;인스턴스.메서드1(); 프로토타입 방식 123456789101112function 클래스이름()&#123; this.프로퍼티1 = 초깃값; this.프로퍼티2 = 초깃값;&#125;클래스이름.prototype.메서드1 = function() &#123;&#125;클래스이름.prototype.메서드2 = function() &#123;&#125;인스턴스.프로퍼티1;인스턴스.메서드1(); 객체 내부에서 프로퍼티와 메서드 접근 방법리터럴 방식 1234567891011var 인스턴스 = &#123; 프로퍼티1: 초깃갑, 프로퍼티2: 초깃갑, 메서드1: function() &#123; alert(this.프로퍼티1); this.메서드2(); &#125; 메서드2: function() &#123; &#125;&#125; 함수방식 1234567891011function 클래스이름() &#123; this.프로퍼티1 = 초깃값; this.프로퍼티2 = 초깃값; this.메서드1 = function() &#123; alert(this.프로퍼티1); this.메서드2(); &#125; this.메서드2 = function() &#123; &#125;&#125; 프로토타입 방식 1234567891011function 클래스이름()&#123; this.프로퍼티1 = 초깃값; this.프로퍼티2 = 초깃값;&#125;클래스이름.prototype.메서드1 = function() &#123; alert(this.프로퍼티1); this.메서드2();&#125;클래스이름.prototype.메서드2 = function() &#123;&#125; 클래스정의 3가지 비교 함수 단위 코딩vs클래스 단위 코딩 인스턴스 프로퍼티와 메서드vs클래스 프로퍼티와 메서드 패키지","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"js 학습","slug":"JS/js-학습","permalink":"https://recoveryman.github.io/categories/JS/js-%ED%95%99%EC%8A%B5/"}],"tags":[]},{"title":"jQuery 마우스휠2","slug":"jQuery-마우스휠2","date":"2017-12-07T04:18:57.000Z","updated":"2017-12-07T04:51:32.000Z","comments":true,"path":"2017/12/07/jQuery-마우스휠2/","link":"","permalink":"https://recoveryman.github.io/2017/12/07/jQuery-%EB%A7%88%EC%9A%B0%EC%8A%A4%ED%9C%A02/","excerpt":"","text":"앞에서 했던 이론이 이해가 되셨다면이제 UI를 만드는건 아주 쉽겟죠? 음수값(마우스를 내릴때)과 양수값(마우스를 올릴때)을 조건식으로 걸어주면 브라우저 이벤트객체 이슈를 고려한 UI 를 만들 수 있겠죠! 더해서 jQuery 플러그 인 중에 Scroll Lock 를 적절하게 응용한다면재밌는 UI를 만드리라 생각합니다! Scroll Lockdemo자 일단 이전글에 있던 마크업을 미리 복사해 줍니다. ㅋㅋ;; 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt;&lt;/style&gt; &lt;script src=\"http://code.jquery.com/jquery-1.11.3.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; $(\"html, body\").on('mousewheel DOMMouseScroll', function(e) &#123; var E = e.originalEvent; delta = 0; if (E.detail) &#123; delta = E.detail * -40; &#125;else&#123; delta = E.wheelDelta; &#125;; &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 이제 body 안에간단하게 ul, li 태그를 사용하여 몇가지 작성해 보도록 합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; *&#123;margin: 0;padding: 0;list-style-type: none;&#125; .clearfix&#123;*zoom: 1;&#125; .clearfix:after&#123;content: '';display: block;clear: both;&#125; div&#123;position: relative;width: 1000px;height: 200px;margin: 0 auto;overflow: hidden;&#125; ul&#123;position: absolute;left: 0;top: 0;width: 3000px;&#125; ul li&#123;width: 1000px;height: 200px;float: left;&#125; .box1&#123;background-color: #b3c4f8;&#125; .box2&#123;background-color: #f8bfb4;&#125; .box3&#123;background-color: #b4f8b6;&#125; &lt;/style&gt; &lt;script src=\"http://code.jquery.com/jquery-1.11.3.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; $(\"html, body\").on('mousewheel DOMMouseScroll', function(e) &#123; var E = e.originalEvent; delta = 0; if (E.detail) &#123; delta = E.detail * -40; &#125;else&#123; delta = E.wheelDelta; &#125;; &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;ul class=\"clearfix\"&gt; &lt;li class=\"box1\"&gt;&lt;/li&gt; &lt;li class=\"box2\"&gt;&lt;/li&gt; &lt;li class=\"box3\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 이런식으로??div 의 크기는 현재 보여줄 li 의 크기만큼ul 의 크기는 li 의 갯수 곱하기 li의 width 값 만큼.( 이 부분은 스크립트로 처리하는게 범용성이 뛰어나겠죠? ) 자.. 스크립트를 작성해 봅니다. 스크립트는 자꾸자꾸 스스로 시도해 보면서 시행착오를 겪어봅시다.시행 착오를 직접 겪는것과 안겪는것은 큰 차이가 있습니다!정말로요..이 예제는 별거 아니지만…ㅠㅠ;; 저는 헤맸어요..;;.................................. iframe 에 스크롤 이 생겨서 휠 이벤트 를 보여주기 힘드네요 ㅎㅎ; 소스코드 다운받기 이걸 참고 하셔서 UI 를 만들어 보셔요 위의것과 동일합니다. jQuery 마우스휠1 jQuery 마우스휠2","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"마크업부터 시작하는 UI","slug":"JS/마크업부터-시작하는-UI","permalink":"https://recoveryman.github.io/categories/JS/%EB%A7%88%ED%81%AC%EC%97%85%EB%B6%80%ED%84%B0-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-UI/"}],"tags":[]},{"title":"jQuery 마우스휠1","slug":"jQuery-마우스휠1","date":"2017-12-07T00:26:43.000Z","updated":"2017-12-07T04:50:20.000Z","comments":true,"path":"2017/12/07/jQuery-마우스휠1/","link":"","permalink":"https://recoveryman.github.io/2017/12/07/jQuery-%EB%A7%88%EC%9A%B0%EC%8A%A4%ED%9C%A01/","excerpt":"","text":"마우스 휠을 이용하여 이벤트를 만들어 봅시다.이 장에서는 마우스 휠에 대한 이론을 살펴 보도록 합시다. 예제용 UI를 찾아보려고 했는데 도통 간단한게 없어서 일단 예를 보여드리도록 하겠습니다. 마우스 휠을 아랫방향으로 했을 때에는 -120마우스 휠을 윗 방향으로 했을 때에는 120 이라는 숫자가 뜨죠? 이해를 돕기 위해 js 피들의 javascript 탭에 주석으로 달아 놓긴 했지만다시한번 글을 적어보도록 하겠습니다. 일단 제가 설치한 브라우저는크롬(Chrome), 익스(IE), 파이어폭스(Firefox) 기준으로 말씀드리겠습니다. 다른 브라우저는 테스트 해보진 않았지만 아마도(죄송합니다.. ㅠㅠ)익스, 크롬, 사파리, 오페라 의 경우엔mousewheel 이라는 이벤트를 사용할 수 있고 파이어폭스 의 경우엔DOMMouseScroll 이라는 이벤트를 사용할 수 있습니다. 즉… 파이어 폭스는 mousewheel 이라는 이벤트가 없기 때문에mousewheel 과 DOMMouseScroll 이벤트 두개를 동시에 걸어주는 메서드인 .on() 를 사용해야 합니다. Example123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=\"ko\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt;&lt;/style&gt; &lt;script src=\"http://code.jquery.com/jquery-1.11.3.min.js\"&gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; $(\"html, body\").on('mousewheel DOMMouseScroll', function(e) &#123; var E = e.originalEvent; delta = 0; console.log(E); if (E.detail) &#123; delta = E.detail * -40; $('body').text(delta); &#125;else&#123; delta = E.wheelDelta; $('body').text(delta); &#125;; &#125;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 일단 저의 마크업은 이렇습니다.이 마크업을 보시면 13번 라인에 콘솔창으로 E 를 찍어보게 됩니다.크롬에서 E 에 담긴걸 찍어보도록 하겠습니다.여기서 function()의 괄호 안에 있는 e 는 mousewheel 입니다! WheelEvent {}이라는 게 뜨죠? 정확히 13번 라인입니다.이걸 펼쳐보면… wheelDelta 라는 속성이 있습니다. 저 값이마우스 휠을 ‘내리게’ 되면 -120 을 출력하고마우스 휠을 ‘올리게’ 되면 120 을 출력합니다. 익스도 마찬가지로 크롬과 동일하게e.originalEvent 의 속성으로 wheelDelta 속성을 사용합니다. 하지만 파이어폭스는e.originalEvent &lt;- 여기서의 e 는 DOMMouseScroll 이벤트 입니다. 파이어폭스 에서도 똑같이 위와같은 마크업의 13번째 라인이 콘솔창에 출력 되었습니다.저 DOMMouseScroll 을 클릭해 보면 detail 이라는 속성이 들어있습니다.저 detail 속성은 파이어폭스에서만 사용할수 있는e.originalEvent 의 속성 입니다. 하지만…크롬도 익스도 120을 출력하는데얘만 3 출력하게 놔둔다면조건문을 이용한 UI를 만들때 불편하겠죠??? 그래서 -40을 곱하기 해주는 겁니다.파이어 폭스는 마우스를 휠을 올릴경우 음수값을마우스 휠을 내릴경우 양수값을 출력합니다. jQuery 마우스휠1 jQuery 마우스휠2","categories":[{"name":"JS","slug":"JS","permalink":"https://recoveryman.github.io/categories/JS/"},{"name":"마크업부터 시작하는 UI","slug":"JS/마크업부터-시작하는-UI","permalink":"https://recoveryman.github.io/categories/JS/%EB%A7%88%ED%81%AC%EC%97%85%EB%B6%80%ED%84%B0-%EC%8B%9C%EC%9E%91%ED%95%98%EB%8A%94-UI/"}],"tags":[]}]}